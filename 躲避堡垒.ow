设置
{
	主程序
	{
		描述: "随机事件 3.0 已上线\n!!!使用全英雄逃出生天!!!\n————————————————\n代码【SVMQK】  | 最近更新：26.0108.1\n\nowmod.net/2650\n\n企鹅聊天群：445152554\n\n原作［OW2 PASTION ESCAPE］"
		模式名称: "躲避堡垒3"
	}

	大厅
	{
		地图轮换: 完成比赛后
		比赛语音聊天: 启用
		玩家上限 队伍1: 8
		玩家上限 队伍2: 0
		观战者人数上限: 12
		返回大厅: 从不
		队列中的玩家可以加入: 是
	}

	模式
	{
		勇夺锦旗
		{
			得分后旗帜刷新时间: 15.0
			旗帜归还时间: 4.0
			旗帜掉落后锁定时间: 5.0

			启用地图
			{
				阿育陀耶 972777519512063901
			}
		}

		突击模式
		{
			// 启用地图
			// {
			// 	66号公路 972777519512068153 972777519512068154 972777519512068194
			// 	“地平线”月球基地 972777519512068154
			// 	努巴尼 972777519512068154
			// 	哈瓦那 972777519512068153 972777519512068154
			// 	国王大道 972777519512068153 972777519512068292
			// 	多拉多 972777519512068153 972777519512068292
			// 	好莱坞 972777519512068153 972777519512068154
			// 	巴黎 972777519512068292
			// 	帕拉伊苏 972777519512068154 972777519512068292
			// 	沃斯卡娅工业区 972777519512068292
			// 	渣客镇 972777519512068154
			// 	监测站：直布罗陀 972777519512068154 972777519512068292
			// 	艾兴瓦尔德 972777519512068292 972777519512068154
			// 	花村 972777519512068154
			// 	里阿尔托 972777519512068292 972777519512068154
			// 	阿努比斯神殿 972777519512068154
			// 	香巴里寺院 972777519512068153
			// 	中城 972777519512068154 972777519512068153
			// 	皇家赛道 972777519512068154 972777519512068153
			// 	埃斯佩兰萨 972777519512068154
			// 	新皇后街 972777519512068154 972777519512068197
			// 	斗兽场
			// 	鲁纳塞彼 972777519512068154
			// 	南极半岛
			// }
			启用地图
			{
				66号公路 972777519512068153 972777519512068154 972777519512068194
				“地平线”月球基地 972777519512068154
				努巴尼 972777519512068154
				哈瓦那 972777519512068153 972777519512068154
				国王大道 972777519512068153 972777519512068292
				多拉多 972777519512068153 972777519512068292
				好莱坞 972777519512068153 972777519512068154
				巴黎 972777519512068292
				帕拉伊苏 972777519512068154 972777519512068292
				沃斯卡娅工业区 972777519512068292
				渣客镇 972777519512068154
				监测站：直布罗陀 972777519512068154 972777519512068292
				艾兴瓦尔德 972777519512068292 972777519512068154
				花村 972777519512068154
				里阿尔托 972777519512068292 972777519512068154
				阿努比斯神殿 972777519512068154
				香巴里寺院 972777519512068153
				中城 972777519512068154 972777519512068153
				皇家赛道 972777519512068154 972777519512068153
				埃斯佩兰萨 
				新皇后街 972777519512068154 972777519512068197
				斗兽场 972777519512068154
				鲁纳塞彼 972777519512068154
				南极半岛 972777519512068153
				漓江塔 972777519512068153
				萨摩亚
				釜山
				绿洲城
				万圣节好莱坞
				万圣节艾兴瓦尔德
				圣诞节国王大道
				圣诞节暴雪世界
				春节漓江塔
				新渣客城
				阿努比斯王座
				花冈
				苏拉瓦萨
			}
			// 禁用地图
			// {
			// 	地图工坊室内
			// 	地图工坊岛屿
			// 	地图工坊岛屿（夜间）
			// 	地图工坊空地
			// 	地图工坊空地（夜间）
			// 	地图工坊绿幕
			// 	尼泊尔
			// 	新渣客城
			// 	// 春节漓江塔
			// 	漓江塔
			// 	// 绿洲城
			// 	花冈
			// 	苏拉瓦萨
			// 	阿努比斯王座
			// 	// 萨摩亚
			// 	// 釜山
				
			// 	// 阿特利斯
			// }
		}

		综合
		{
			启用威能: 开启
			复生时间: 10%
			威能充能速度: 500%
			急救包刷新时间: 75%
			敌方生命条: 关闭
			游戏模式开始: 手动
			英雄限制: 关闭
			阵亡镜头: 关闭
		}
	}

	英雄
	{
		队伍1
		{
			技能冷却时间: 40%

			堡垒
			{
				生命值: 150%
			}
		}

		队伍2
		{
			受到伤害量: 25%
			技能冷却时间: 0%
			生命值: 500%

			堡垒
			{
				A-36战术榴弹冷却时间: 0%
				A-36战术榴弹击退倍率: 150%
				弹道速度: 175%
				无需装弹: 开启
				生命值: 500%
			}
		}

		综合
		{
			战斗时终极技能充能速度: 0%
			无需装弹: 开启
			终极技能自动充能速度: 0%

			D.Va
			{
				推进器冷却时间: 125%
			}

			半藏
			{
				“跃”冷却时间: 60%
				音冷却时间: 0%
			}

			卡西迪
			{
				战术翻滚冷却时间: 50%
			}

			回声
			{
				飞行冷却时间: 33%
			}

			天使
			{
				守护天使冷却时间: 67%
			}

			奥丽莎
			{
				强固防御冷却时间: 50%
				标枪旋击冷却时间: 70%
			}

			安娜
			{
				麻醉镖冷却时间: 67%
			}

			巴蒂斯特
			{
				受到治疗量: 50%
				弹道速度: 500%
				投射物重力: 0%
				生命值: 50%
				维生力场冷却时间: 20%
			}

			布丽吉塔
			{
				屏障护盾充能速度: 500%
				能量盾击冷却时间: 80%
			}

			弗蕾娅
			{
				疾冲冷却时间: 67%
				疾冲距离: 130%
			}

			托比昂
			{
				可用武器: 仅限锻造锤
				热力过载冷却时间: 20%
				热力过载持续时间: 40%
				部署炮台: 关闭
			}

			探奇
			{
				钻地持续时间倍率: 25%
			}

			末日铁拳
			{
				悍猛格挡冷却时间: 50%
				火箭重拳冷却时间: 80%
				裂地重拳冷却时间: 80%
			}

			朱诺
			{
				滑翔推进冷却时间: 67%
				滑翔推进持续时间倍率: 50%
			}

			查莉娅
			{
				垂直跳跃速度: 140%
				投射屏障冷却时间: 56%
				粒子屏障冷却时间: 46%
				粒子炮辅助攻击击退倍率: 200%
			}

			死神
			{
				幽灵形态冷却时间: 75%
				暗影步冷却时间: 300%
			}

			毛加
			{
				蛮力冲撞冷却时间: 80%
			}

			温斯顿
			{
				喷射背包冷却时间: 80%
				屏障发射器冷却时间: 83%
			}

			源氏
			{
				闪冷却时间: 75%
			}

			狂鼠
			{
				震荡地雷冷却时间: 100%
				震荡地雷击退倍率: 100%
			}

			猎空
			{
				闪回冷却时间: 50%
				闪现冷却时间: 50%
			}

			生命之梭
			{
				生命之握冷却时间: 84%
				生命之握和愈疗灵花射程: 200%
				花瓣平台冷却时间: 84%
			}

			破坏球
			{
				动力铁球始终激活: 关闭
			}

			禅雅塔
			{
				治疗量: 200%
				生命值: 150%
			}

			秩序之光
			{
				传送面板冷却时间: 66%
				哨戒炮: 关闭
			}

			美
			{
				冰墙冷却时间: 67%
			}

			艾什
			{
				延时雷管冷却时间: 50%
				短筒猎枪冷却时间: 40%
			}

			莫伊拉
			{
				消散冷却时间: 50%
				生化之球治疗最大值: 500%
			}

			莱因哈特
			{
				冲锋冷却时间: 75%
			}

			西格玛
			{
				动能俘获冷却时间: 75%
				实验屏障冷却时间: 50%
				质量吸附冷却时间: 50%
			}

			路霸
			{
				呼吸器冷却时间: 100%
				// 呼吸器充能速度: 100%
			}

			雾子
			{
				“瞬”距离倍率: 143%
				铃冷却时间: 43%
			}

			黑百合
			{
				终极技能持续时间无限: 开启
			}

            骇灾
			{
				尖刺墙冷却时间: 92%
				尖刺墙击退: 0%
				尖刺墙生命值: 25%
				尖刺护体资源消耗: 0%
			}

			黑影
			{
				位移传动冷却时间: 0%
			}
		}
	}

    地图工坊
	{
		随机事件扩展包: 开启
		自动重开时间间隔（小时）: 3.500
		难度: [4]
		
	}

	扩展
	{
		增益状态效果
		减益状态效果
		增益效果和减益效果声音
		能量爆炸效果
		生成更多机器人
	}
}

变量
{
	全局:
		0: bastionPosition
		1: heroRingPosition
		2: resetPosition
		3: creditsPosition
		4: endPosition
		5: heroList
		6: missingHeroes
		7: maxDeath
		8: I
		9: kills
		10: bastionBotTargetPrefer
		11: difficulty
		12: scoreboardArray
		13: firstPlace
		14: secondPlace
		15: thirdPlace
		16: textIDs
		17: savedIndex
		18: savedHero
		19: savedDeaths
		20: savedIsWinner
		21: savedSkipCount
		22: savedJoinTime
		23: devList
		24: __currentMap__
		25: dmgReduction
		26: blackList
		27: rebootTime
		28: targetPlayer
		29: targetPlayerIndex
		30: thirdPersonPosition
		31: debugMode
		32: debugInfo
		33: devPlayer
		34: bastionBotSeconFire
		35: difficultyText
		36: controlCenterPosition
		37: controlJumpPosition
		38: controlRespawnPosition
		39: controlRespawnAxis
		40: controlRespawnAxisThreshold
		43: mapTitleRelation
		44: allTitle
		45: titlePlayer
		47: playerTitleRelation
		48: rgbList
		49: savedWinnerTime
		51: savedA36TGrenade
		52: savedA36TGrenadeHit
		53: savedA36TGrenadeDmg
		54: savedA36TGrenadeAlive
		55: turnSpeedMultiplier
		56: berserkerTime
		57: eventId
		58: eventDuration
		59: eventName
		60: eventDesc
		61: eventCount
		62: eventRoll
		63: eventType
		64: eventDurationHud
		69: hashTag
		70: dlcBerserker
		71: dlcVishkarEvent
		72: vishkarEventActivated
		// 73: vishkarEvent
		79: globalEvent
		80: globalEventId
		81: buffEvent
		82: buffEventId
		83: debuffEvent
		84: debuffEventId
		85: mechEvent
		86: mechEventId
		89: obstrucVis
		90: heroColor
		91: breathRed
		92: breathPurple
		93: breathBlue
		94: breathOrange
		95: breathGold
		100: springBoardPosition
		101: portalPosition
		102: heroGender
		105: __currentMapText__
		106: __currentPioneerText__
		107: __currentMapPioneerText__
		127: antiCrashActivated

	玩家:
		0: heroNumber
		1: progressionDeathCount
		2: skipCount
		3: isWinner
		4: dmgReduc
		5: anaSleepLimit
		6: temp
		7: attacker
		8: I
		9: target
		10: aimPosition
		11: turnSpeed
		12: tempAimPosition
		13: nearestTargetOutOfLoS
		14: dvaStart
		15: healID
		16: isInPosition
		17: rainbowOff
		18: runDeathCount
		19: joinTime
		20: menu
		21: menuTextID
		22: isDev
		23: debugInfo
		24: third
		25: hasNano
		26: nanoEffect
		27: invincible
		28: invincibleEffect
		29: isAirWalkEnabled
		30: isPortalEnabled
		31: controlCenterIndex
		32: controlJumpIndex
		33: controlPlayerRespawnPosition
		37: playerTitleAndColor
		38: titleTextID
		39: rgb_vect
		40: info_pvar
		41: rgb_activated
		42: winnerTime
		43: playerTitles
		44: playerTitleIndex
		45: playerTitleRelationIndex
		46: playerTitleWhileIndex
		50: A36TGrenade
		51: A36TGrenadeHit
		52: A36TGrenadeDmg
		53: A36TGrenadeAlive
		57: ignoreObstrucVis
		58: eventMission
		59: eventEffectPlayers
		60: eventId
		61: eventLastId
		62: eventType
		63: eventDuration
		64: eventName
		65: eventDesc
		66: eventCount
		67: eventLucky
		68: eventEffect
		69: categoryRoll
		70: combatRegen
		71: mod_speed_event
		72: mod_speed_perma
		74: mod_heal_event // 造成治疗量
		75: heal_recv // 受到治疗
		76: healing_global
		80: mod_dmg_taken // 受到伤害
		81: mod_dmg_perma
		84: healthId
		85: hack_timer
		86: targetWeight
		87: targetSilence
		88: hudTextId
		89: heart_steel
		90: obstrucVis
		91: sizeHealth
		92: eventDurationHud
		93: possess
		94: possessed
		95: empProMax
		96: setPlayerHP
		97: dlcTimeChallenge
		98: toggleSpectate
		99: knockback
		110: tempIndices
		111: tempMapIndices
		112: tempMapMatches
}

子程序
{
	0: savePlayerData
	1: progressHero
	2: setDifficulty
	3: setThirdPerson
	4: setPlayerTitle
	5: setPlayerEvent
	6: clearPlayerEvent
	7: updatePlayerStats
	8: stopCombatRegen
	9: setPlayerHP
	10: setEventDuration
	12: resetPlayerCD
	14: clearEventEffect
	17: createBastionBot
	
}

禁用 规则("声明：本模式代码不得用于商业用途")
{
	事件
	{
		持续 - 全局;
	}
}

禁用 规则("在模式描述中保留原作者署名与原模式代码的前提下，你可基于本模式及其代码进行二次创作与发布")
{
	事件
	{
		持续 - 全局;
	}
}

规则("OverPy Map Detection")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		If(数组包含(数组(地图(阿育陀耶), 地图(黑森林), 地图(黑森林), 地图(暴雪世界), 地图(釜山), 地图(釜山), 地图(釜山), 地图(城堡), 地图(吉拉德堡), 地图(阿特利斯), 地图(皇家赛道), 地图(斗兽场),
			地图(多拉多), 地图(生态监测站：南极洲), 地图(艾兴瓦尔德), 地图(艾兴瓦尔德), 地图(埃斯佩兰萨), 地图(阿努比斯王座), 地图(花村), 地图(花村), 地图(哈瓦那), 地图(好莱坞), 地图(好莱坞), 地图(
			“地平线”月球基地), 地图(伊利奥斯), 地图(伊利奥斯), 地图(伊利奥斯), 地图(伊利奥斯), 地图(苏拉瓦萨), 地图(渣客镇), 地图(新渣客城), 地图(国王大道), 地图(国王大道), 地图(漓江塔控制中心), 地图(漓江塔控制中心),
			地图(漓江塔庭院), 地图(漓江塔庭院), 地图(漓江塔夜市), 地图(漓江塔夜市), 地图(漓江塔), 地图(漓江塔), 地图(马莱温多), 地图(中城), 地图(墓园), 地图(尼泊尔), 地图(尼泊尔), 地图(尼泊尔), 地图(尼泊尔), 地图(
			尼泊尔), 地图(新皇后街), 地图(努巴尼), 地图(绿洲城), 地图(绿洲城), 地图(绿洲城), 地图(绿洲城), 地图(帕拉伊苏), 地图(巴黎), 地图(佩特拉), 地图(训练靶场), 地图(里阿尔托), 地图(66号公路), 地图(
			阿努比斯神殿), 地图(沃斯卡娅工业区), 地图(监测站：直布罗陀), 地图(地图工坊室内), 地图(地图工坊空地), 地图(地图工坊空地), 地图(地图工坊绿幕), 地图(地图工坊岛屿), 地图(地图工坊岛屿), 地图(香巴里寺院)), 当前地图));
			全局.__currentMap__ = 当前地图;
			中止;
		End;
		全局.__currentMap__ = 射线命中位置(矢量(500, 100, 500), 矢量(-500, -100, -500), 空, 空, 假);
		If(全局.__currentMap__ == 矢量(0, 0, 0) || 全局.__currentMap__ == 矢量(-500, -100, -500));
			全局.__currentMap__ = 射线命中位置(矢量(30, 5, 0), 矢量(-30, -10, -10), 空, 空, 假);
			If(全局.__currentMap__ == 矢量(-30, -10, -10));
				全局.__currentMap__ = 射线命中位置(矢量(200, 20, 100), 矢量(100, -100, -100), 空, 空, 假);
				If(全局.__currentMap__ == 矢量(100, -100, -100));
					全局.__currentMap__ = 射线命中位置(矢量(300, 20, -100), 矢量(300, -100, 100), 空, 空, 假);
					If(全局.__currentMap__ == 矢量(300, -100, 100));
						全局.__currentMap__ = 射线命中位置(矢量(50, 100, -150), 矢量(-50, -100, -160), 空, 空, 假);
						If(全局.__currentMap__ == 矢量(-50, -100, -160));
							全局.__currentMap__ = 射线命中位置(矢量(0, 300, 340), 矢量(0, -100, -300), 空, 空, 假);
							If(全局.__currentMap__ == 矢量(0, -100, -300));
								全局.__currentMap__ = 射线命中位置(矢量(140, 10, -240), 矢量(200, -10, -300), 空, 空, 假);
								If(全局.__currentMap__ == 矢量(200, -10, -300));
									全局.__currentMap__ = 射线命中位置(矢量(-180, 30, 60), 矢量(-180, -50, -60), 空, 空, 假);
								End;
							End;
						End;
					End;
				End;
			End;
		End;
		全局.__currentMap__ = 100 * 取整(Y方向分量(全局.__currentMap__), 上) + 10 * 取整(X方向分量(全局.__currentMap__), 至最近) + 取整(Z方向分量(全局.__currentMap__),
			下);
		If(全局.__currentMap__ == 10121);
			全局.__currentMap__ = 射线命中位置(矢量(-60, 20, -60), 矢量(60, -10, 60), 空, 空, 假);
			If(全局.__currentMap__ == 矢量(60, -10, 60));
				全局.__currentMap__ = 射线命中位置(矢量(-180, -70, 60), 矢量(-180, -100, -60), 空, 空, 假);
			End;
			全局.__currentMap__ = 100 * 取整(Y方向分量(全局.__currentMap__), 上) + 10 * 取整(X方向分量(全局.__currentMap__), 至最近) + 取整(Z方向分量(全局.__currentMap__),
				下);
		End;
		// If(数组包含(数组(地图(釜山), 地图(南极半岛), 地图(伊利奥斯), 地图(漓江塔), 地图(尼泊尔), 地图(绿洲城), 地图(萨摩亚)), 全局.__currentMap__));
			全局.controlCenterPosition =  数组(目标位置(0), 目标位置(1), 目标位置(2));
		// END;
	}
}

规则("Initialize global variables")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		// 禁用 全局.dlcBerserker = 地图工坊设置开关(自定义字符串("2. DLC 扩展内容"), 自定义字符串("狂暴之心（即将到来）"), 假, 6);
		全局.dlcVishkarEvent = 地图工坊设置开关(自定义字符串("2. DLC 扩展内容"), 自定义字符串("随机事件扩展包"), 真, 5);
		全局.rebootTime = 地图工坊设置实数(自定义字符串("1. 游戏"), 自定义字符串("自动重开时间间隔（小时）"), 3.500, 1, 4, 0) * 3600;
		全局.debugMode = 地图工坊设置开关(自定义字符串("1. 游戏"), 自定义字符串("Debug 模式"), 假, 5);
		全局.hashTag = 单次赋值(全局.debugMode) ? 假 : 真;
		全局.bastionBotTargetPrefer = 地图工坊设置组合(自定义字符串("1. 游戏"), 自定义字符串("AI 堡垒瞄准规则"), 0, 数组(自定义字符串("自动"), 自定义字符串("近距离优先"), 自定义字符串("低生命值优先")), 2);
		全局.difficulty = 地图工坊设置组合(自定义字符串("1. 游戏"), 自定义字符串("难度"), 1, 数组(自定义字符串("简单"), 自定义字符串("一般"), 自定义字符串("困难"), 自定义字符串("专家"), 自定义字符串("传奇"),
			自定义字符串("地狱：无法跳过英雄")), 1);
		全局.dmgReduction = 地图工坊设置开关(自定义字符串("1. 游戏"), 自定义字符串("全英雄威能充能"), 真, 4);
		全局.bastionBotSeconFire = 地图工坊设置开关(自定义字符串("1. 游戏"), 自定义字符串("AI 堡垒使用榴弹（忽略难度）"), 假, 3);
		全局.turnSpeedMultiplier = 全局.difficulty < 4 ? 4 + 全局.difficulty : 10 * 0.800;
		全局.maxDeath = 5 * 全局.difficulty;
		全局.savedIndex = 空数组;
		全局.savedHero = 空数组;
		全局.savedDeaths = 空数组;
		全局.savedIsWinner = 空数组;
		全局.savedSkipCount = 空数组;
		全局.savedJoinTime = 空数组;
		全局.devList = 数组(自定义字符串("他又"), 自定义字符串("别感冒"));
		全局.devPlayer = 空数组;
		全局.mapTitleRelation = 空数组;
		全局.obstrucVis = 空数组;
		全局.heroGender[0] = 数组(英雄(无漾), 英雄(骇灾), 英雄(毛加), 英雄(生命之梭), 英雄(拉玛刹), 英雄(死神), 英雄(西格玛), 英雄(源氏), 英雄(温斯顿), 英雄(巴蒂斯特), 英雄(士兵：76), 英雄(破坏球), 英雄(卡西迪), 英雄(卢西奥), 英雄(莱因哈特), 英雄(半藏), 英雄(末日铁拳), 英雄(路霸), 英雄(托比昂), 英雄(禅雅塔), 英雄(狂鼠), 英雄(堡垒));
		全局.heroGender[1] = 已过滤的数组(全部英雄, !数组包含(全局.heroGender[0], 当前数组元素));
	}
}

规则("Setup Blacklist")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.blackList = 空数组;
		修改全局变量(blackList, 添加至数组, 字符串分割(自定义字符串("船长-六十块就这样没了-Pakho"), 自定义字符串("-")));
	}
}

规则("Remove Player from Blacklist")
{
	事件
	{
		玩家加入比赛;
		队伍1;
		全部;
	}

	条件
	{
		数组包含(全局.blackList, 自定义字符串("{0}", 事件玩家)) == 真;
	}

	动作
	{
		移除玩家(事件玩家);
	}
}

规则("Update devPlayer from devList")
{
	事件
	{
		玩家加入比赛;
		队伍1;
		全部;
	}

	条件
	{
		数组包含(全局.devList, 自定义字符串("{0}", 事件玩家)) == 真;
		数组包含(全局.devPlayer, 自定义字符串("{0}", 事件玩家)) == 假;
	}

	动作
	{
		修改全局变量(devPlayer, 添加至数组, 事件玩家);
	}
}

规则("Update targetPlayer when player left")
{
	事件
	{
		玩家离开比赛;
		队伍1;
		全部;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 无视条件);
		全局.targetPlayerIndex = 0;
		全局.targetPlayer = 首个(已排序的数组(所有玩家(队伍1), 当前数组元素.joinTime));
	}
}

规则("initialize color array")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.rgbList = 数组(
			矢量(255, 0, 0),    // 红
            矢量(255, 165, 0),  // 橙
            矢量(255, 255, 0),  // 黄
            矢量(0, 255, 0),    // 绿
            矢量(0, 0, 255),    // 蓝
            矢量(75, 0, 130),   // 靛
            矢量(238, 130, 238) // 紫
		);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		全局.breathRed = 数组(
            矢量(238, 75, 43),       // 朱红
            矢量(233, 116, 81),     // 锡耶纳色
            矢量(210, 43, 43),   // 镉红色
			矢量(220, 20, 60), // 深红
			矢量(255, 36, 0), // 猩红
            矢量(255, 50, 50),     // 亮红
            矢量(255, 0, 0)        // 纯红
        );

		全局.breathPurple = 数组(
            矢量(161, 73, 197), // 紫色
            矢量(93, 63, 211),       // 虹膜色
			矢量(218, 112, 214), // 兰花色
			矢量(112, 41, 99), // 拜占庭色
            矢量(191, 64, 191),     // 亮紫色
            矢量(204, 204, 255),        // 长春花色
			矢量(128, 0, 128)   // 紫色
        );

		全局.breathBlue = 数组(
			矢量(85, 178, 204), // 基础蓝
			矢量(120, 200, 225), // 天蓝
			矢量(160, 220, 240), // 浅天蓝
			矢量(25, 80, 120), // 深海军蓝
			矢量(45, 125, 165), // 宝石蓝
			矢量(200, 235, 245), // 淡蓝
			矢量(230, 245, 250) // 冰蓝
		);

		全局.breathOrange = 数组(
			矢量(250, 121, 0), // 基础橘 rgb(250, 121, 0)
			矢量(255, 140, 0), // 亮橙色 rgb(255, 140, 0)
			矢量(255, 220, 180), // 奶油橙 rgb(255, 220, 180)
			矢量(255, 160, 50), // 浅橙色 rgb(255, 160, 50)
			矢量(255, 200, 150), // 桃橙色 rgb(255, 200, 150)
			矢量(255, 180, 100), // 柔橙色 rgb(255, 180, 100)
			矢量(230, 105, 0) // 深橙色 rgb(230, 105, 0)
		);

		全局.breathGold = 数组(
			矢量(255, 215, 0), // 金色 rgb(255, 215, 0)
			矢量(238, 201, 0), // 深金色 rgb(238, 201, 0)
			矢量(255, 223, 70), // 金黄色 rgb(255, 223, 70)
			矢量(255, 239, 128), // 浅金色 rgb(255, 239, 128)
			矢量(218, 165, 32), // 金菊色 rgb(218, 165, 32)
			矢量(250, 250, 210), // 浅金菊色 rgb(250, 250, 210)
			矢量(184, 134, 11) // 暗金色 rgb(184, 134, 11)
			// 矢量(180, 150, 50), // 古金色 rgb(180, 150, 50)
// 矢量(200, 170, 60), // 暗金色 rgb(200, 170, 60)
// 矢量(220, 185, 75), // 暖金色 rgb(220, 185, 75)
// 矢量(240, 200, 90), // 中金色 rgb(240, 200, 90)
// 矢量(255, 215, 0), // 黄金色 rgb(255, 215, 0)
// 矢量(255, 225, 80), // 亮金色 rgb(255, 225, 80)
// 矢量(255, 235, 140), // 浅金色 rgb(255, 235, 140)
// 矢量(255, 245, 180) // 淡金色 rgb(255, 245, 180)
		);

		全局.heroColor = 数组(
			矢量(124, 62, 82),//REAPER 0 rgb(124, 62, 82)
			矢量(214, 145, 65),//TRACER 1 rgb(214, 145, 65)
			矢量(236, 233, 189),//MERCY 2 rgb(236, 233, 189)
			矢量(185, 179, 137),//HANZO 3 rgb(185, 179, 137)
			矢量(191, 115, 110),//TORBJÖRN 4 rgb(191, 115, 110)
			矢量(148, 161, 165),//REINHARDT 5 rgb(148, 161, 165)
			矢量(60, 126, 204),//PHARAH 6 rgb(60, 126, 204)
			矢量(160, 169, 186),//WINSTON 7 rgb(160, 169, 186)
			矢量(157, 105, 166),//WIDOWMAKER 8 rgb(157, 105, 166)
			矢量(124, 143, 122),//BASTION 9 rgb(124, 143, 122)
			矢量(45, 187, 209),//SYMMETRA 10 rgb(45, 187, 209)
			矢量(236, 229, 128),//ZENYATTA 11 rgb(236, 229, 128)
			矢量(149, 239, 66),//GENJI 12 rgb(149, 239, 66)
			矢量(179, 139, 80),//ROADHOG 13 rgb(179, 139, 80)
			矢量(173, 90, 95),//CASSIDY 14 rgb(173, 90, 95)
			矢量(236, 190, 82),//JUNKRAT 15 rgb(236, 190, 82)
			矢量(231, 130, 184),//ZARYA 16 rgb(231, 130, 184)
			矢量(109, 121, 149),//SOLDIER: 76 17 rgb(109, 121, 149)
			矢量(132, 201, 81),//LÚCIO 18 rgb(132, 201, 81)
			矢量(237, 147, 199),//D.VA 19 rgb(237, 147, 199)
			矢量(09, 171, 235),//MEI 20 rgb(9, 171, 235)
			矢量(118, 93, 189),//SOMBRA 21 rgb(118, 93, 189)
			矢量(131, 83, 76),//DOOMFIST 22 rgb(131, 83, 76)
			矢量(110, 137, 177),//ANA 23 rgb(110, 137, 177)
			矢量(69, 139, 66),//ORISA 24 rgb(69, 139, 66)
			矢量(139, 98, 94),//BRIGITTE 25 rgb(139, 98, 94)
			矢量(151, 113, 228),//MOIRA 26 rgb(151, 113, 228)
			矢量(219, 147, 66),//WRECKING BALL 27 rgb(219, 147, 66)
			矢量(198, 28, 65),//SOJOURN 28 rgb(198, 28, 65)
			矢量(105, 105, 104),//ASHE 29 rgb(105, 105, 104)
			矢量(154, 202, 243),//ECHO 30 rgb(154, 202, 243)
			矢量(85, 178, 204),//BAPTISTE 31 rgb(85, 178, 204)
			矢量(212, 135, 143),//KIRIKO 32 rgb(212, 135, 143)
			矢量(142, 181, 215),//JUNKER QUEEN 33 rgb(142, 181, 215)
			矢量(148, 160, 165),//SIGMA 34 rgb(148, 160, 165)
			矢量(157, 140, 208),//RAMATTRA 35 rgb(157, 140, 208)
			矢量(224, 182, 198),//LIFEWEAVER 36 rgb(224, 182, 198)
			矢量(220, 132, 125),//MAUGA 37 rgb(220, 132, 125)
			矢量(183, 168, 142),//ILLARI 38 rgb(183, 168, 142)
			矢量(121, 97, 78),//VENTURE 39 rgb(121, 97, 78)
			矢量(173, 143, 203),//HAZARD 40 rgb(173, 143, 203)
			矢量(114, 31, 163),//JUNO 41 rgb(114, 31, 163)
			矢量(54, 127, 221),//FREJA 42 rgb(54, 127, 221)
			矢量(238, 75, 43),//朱红 43 rgb(238, 75, 43)
			矢量(93, 63, 211),//拜占庭 44 rgb(93, 63, 211)
			矢量(196, 30, 58)//枢机红 45 rgb(196, 30, 58)
		);
	}
}

规则("initialize title array")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.titlePlayer = 空数组;
		修改全局变量(titlePlayer, 添加至数组, 字符串分割(自定义字符串("他又-别感冒-草艮-烛台与南九-顾北酒笙-WildRage-尘风歌者-吾携秋水揽星河-寒霜冰湮-Cold-豆本豆豆奶-神之岛風咲"), 自定义字符串("-")));
		修改全局变量(titlePlayer, 添加至数组, 字符串分割(自定义字符串("溪云初起日沉阁-卖核弹的小女孩-挽风-水濑祈-别打老顾我啊-看啊情-眼镜小宅-初一吖-锦木千束-她说话有股孩子气-白银之鹰"), 自定义字符串("-")));
		修改全局变量(titlePlayer, 添加至数组, 字符串分割(自定义字符串("蝎子莱莱-雨鸢-Jargon-我心飞扬-绿里奇迹-EruIluvatar-糯米进脑子-半夜汽笛-雷个大憨憨-一痕沙-Augenstern-明月有时"), 自定义字符串("-")));
		// 全局.titlePlayer = 数组(
		// 	自定义字符串("他又"), // 0
        //     自定义字符串("别感冒"), // 1
        //     自定义字符串("草艮"), // 2
        //     自定义字符串("烛台与南九"), // 3
        //     自定义字符串("顾北酒笙"), // 4
        //     自定义字符串("WildRage"), // 5
        //     自定义字符串("尘风歌者"), // 6
        //     自定义字符串("吾携秋水揽星河"), // 7
        //     自定义字符串("寒霜冰湮"), // 8
        //     自定义字符串("Cold"), // 9
        //     自定义字符串("豆本豆豆奶"), // 10
        //     自定义字符串("神之岛風咲"), // 11
        //     自定义字符串("溪云初起日沉阁"), // 12
        //     自定义字符串("卖核弹的小女孩"), // 13
        //     自定义字符串("挽风"), // 14
        //     自定义字符串("水濑祈"), // 15
        //     自定义字符串("别打老顾我啊"), // 16
        //     自定义字符串("看啊情"), // 17
        //     自定义字符串("眼镜小宅"), // 18
        //     自定义字符串("初一吖"), // 19
        //     自定义字符串("锦木千束"), // 20
		// 	自定义字符串("她说话有股孩子气"), // 21
		// 	自定义字符串("白银之鹰"), // 22
		// 	自定义字符串("蝎子莱莱"), // 23
		// 	自定义字符串("雨鸢"), // 24
		// 	自定义字符串("Jargon"), // 25
		// 	自定义字符串("我心飞扬"), // 26
		// 	自定义字符串("绿里奇迹"), // 27
		// 	自定义字符串("EruIluvatar"), // 28
		// 	自定义字符串("糯米进脑子"), // 29
		// 	自定义字符串("半夜汽笛"),  // 30
		// 	自定义字符串("雷个大憨憨"),  // 31
		// 	自定义字符串("一痕沙")  // 32
		// );
		等待(服务器负载 / 100 * 0.500, 无视条件);
		全局.allTitle = 数组(
			数组(自定义字符串("{0}{1}", 全局.__currentMapPioneerText__ != 空 ? 全局.__currentMapPioneerText__ : 当前地图, 全局.__currentPioneerText__ != 空 ? 全局.__currentPioneerText__ : 自定义字符串("开拓者")), 全局.heroColor[12]), // 0
			数组(自定义字符串("这是一个超长的称号测试字段如果到这里还没有被截断说明确实很长你说得对但是广告位招租啊哈大OW是我的家乡"), 空), // 1
            数组(自定义字符串("地图不是我做的"), 空), // 2
            数组(自定义字符串("野生开发者"), 空), // 3
            数组(自定义字符串("堡垒建筑师"), 空), // 4
			数组(自定义字符串("友善的地图维护者"), 空), // 5
            数组(自定义字符串("三合一地图作者"), 空), // 6
            数组(自定义字符串("害群之马"), 空), // 7
            数组(自定义字符串("纯害战士"), 空), // 8
			数组(自定义字符串("{0}征服者", 全局.__currentMapText__ != 空 ? 全局.__currentMapText__ : 当前地图), 全局.heroColor[43]), // 9 地图称号模板
            数组(自定义字符串("{0}主宰", 全局.__currentMapText__ != 空 ? 全局.__currentMapText__ : 当前地图), 全局.heroColor[44]),   // 10 地图称号模板
			数组(自定义字符串("专家幸存者"), 矢量(236, 153, 0)), // 11
			数组(自定义字符串("传奇挑战者"), 矢量(200, 0, 19)), // 12
            数组(自定义字符串("地狱穿梭者"), 矢量(161, 73, 197)), // 13
            数组(自定义字符串("终极闪避"), 全局.heroColor[1]), // 14
			数组(自定义字符串("轻装上阵"), 全局.heroColor[2]), // 15
            数组(自定义字符串("完美无缺"), 矢量(0, 230, 151)), // 16
			数组(自定义字符串("永不言弃"), 矢量(0, 230, 151)), // 17
			数组(自定义字符串("坚韧不拔"), 矢量(255, 255, 255)), // 18
			数组(自定义字符串("速通传奇"), 矢量(0, 230, 151)), // 19
			数组(自定义字符串("闪避の神"), 全局.heroColor[28]), // 20
			数组(自定义字符串("智瞳开拓者"), 全局.heroColor[12]), // 21
			数组(自定义字符串("大难不死"), 全局.heroColor[45]), // 22
            数组(自定义字符串("胜天半子"), 全局.breathOrange), // 23
           	数组(自定义字符串("堡垒の偶像"), 矢量(200, 0, 19)), // 24
		   	数组(自定义字符串("第一颗蛋"), 矢量(200, 0, 19)), // 25
		   	数组(自定义字符串("我还能吃"), 矢量(238, 75, 43)), // 26
			数组(自定义字符串("万象归一"), 全局.breathRed), // 27
			数组(自定义字符串("守望旅行家"), 全局.heroColor[33]), // 28
			数组(自定义字符串("万域天穹"), 全局.breathPurple), // 29
			数组(自定义字符串("狂暴烈焰"), 全局.heroColor[28]), // 30
			数组(自定义字符串("万蛋丛中过"), 全局.heroColor[28]), // 31
			数组(自定义字符串("天选之子"), 全局.heroColor[11]), // 32
			数组(自定义字符串("幸运星"), 全局.heroColor[3]), // 33
			数组(自定义字符串("赌王"), 全局.breathGold), // 34
			数组(自定义字符串("福星高照"), 全局.heroColor[32]), // 35
			数组(自定义字符串("倒霉蛋"), 全局.heroColor[22]), // 36
			数组(自定义字符串("What can i say"), 全局.heroColor[11]), // 37 混沌化身
			数组(自定义字符串("我命由我"), 全局.breathBlue), // 38 
			数组(自定义字符串("赌神"), 全局.breathGold), // 39
			数组(自定义字符串(" 牢 大 "), 空), // 40
			数组(自定义字符串("V我50"), 全局.heroColor[37]), // 41
			数组(自定义字符串("钢门"), 全局.heroColor[11]), // 42
			数组(自定义字符串("开了"), 全局.heroColor[20]) // 43
			
		);

		全局.playerTitleRelation = 数组(
			// 玩家0: "他又" - 全部称号
            数组(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43), 
			// 玩家1: "芋泥玛奇朵" - 全部称号
            数组(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43),
            // 玩家"草艮"的称号索引: 11,12
           	数组(12, 13),
    
			// 玩家3: "烛台与南九" - 3个称号
			数组(12, 13, 25),
			
			// 玩家4: "顾北酒笙" - 4个称号
			数组(12, 16, 19, 13),
			
			// 玩家5: "WildRage" - 1个称号
			数组(12, 13, 22, 25),
			
			// 玩家6: "尘风歌者" - 10个称号
			数组(12, 13, 16, 18, 19, 15, 14, 22, 25, 31),
			
			// 玩家7: "吾携秋水揽星河" - 7个称号
			数组(12, 16, 17, 13, 19, 22, 15, 14, 16, 27, 28, 29, 32, 33, 35, 37),
			
			// 玩家8: "寒霜冰湮" - 7个称号
			数组(12, 16, 17, 13, 19, 22, 15, 14, 27, 28, 29, 33, 37),
			
			// 玩家9: "Cold" - 9个称号
			数组(16, 17, 12, 13, 19, 22, 15, 14, 25, 31, 37),
			
			// 玩家10: "豆本豆豆奶" - 8个称号
			数组(16, 12, 17, 19, 13, 22, 14, 25, 36),
			
			// 玩家11: "神之岛風咲" - 3个称号
			数组(16),
			
			// 玩家12: "溪云初起日沉阁" - 5个称号
			数组(19, 16, 17, 12, 13, 22, 25, 36),
			
			// 玩家13: "卖核弹的小女孩" - 3个称号
			数组(19, 16, 12, 13, 22, 27, 28, 29, 33, 37),
			
			// 玩家14: "挽风" - 5个称号
			数组(15, 14, 19, 16, 12),
			
			// 玩家15: "水濑祈" - 4个称号
			数组(12, 13, 22),
			
			// 玩家16: "别打老顾我啊" - 5个称号
			数组(12, 13, 16, 19, 22),
			
			// 玩家17: "看啊情" - 4个称号
			数组(12, 16, 13, 22),
			
			// 玩家18: "眼镜小宅" - 4个称号
			数组(12, 13, 14, 15, 16, 19, 22, 33),
			
			// 玩家19: "初一吖" - 3个称号
			数组(12, 13, 16, 22, 25, 31, 32, 37),
			
			// 玩家20: "锦木千束" - 3个称号
			数组(12, 13, 16),

			// 玩家21: "她说话有股孩子气"
			数组(12, 16, 19),

			// 玩家22: "白银之鹰"
			数组(12, 13, 19),

			// 玩家23: 蝎子莱莱
			数组(12, 13, 16, 19, 22),

			// 玩家24: 雨鸢
			数组(12, 13, 22, 33, 36, 37),

			// 玩家25: Jargon
			数组(12, 13, 22),

			// 玩家26: 我心飞扬
			数组(12, 13),

			// 玩家27: 绿里奇迹
			数组(12, 13, 19),

			// 玩家28: EruIluvatar
			数组(12, 13, 19, 22),

			// 玩家29: 糯米进脑子
			数组(12, 13, 19, 22),

			// 玩家30: 半夜汽笛
			数组(12, 13, 22, 37),

			// 玩家31: 雷个大憨憨
			数组(12, 13),

			// 玩家32: 一痕沙
			数组(12, 22),

			// 玩家33: Augenstern
			数组(12, 13, 22, 33),

			// 玩家34: 明月有时
			数组(12, 13, 22)
        );
	}
}

规则("initialize event flag")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		总计消耗时间 > (单次赋值(全局.debugMode) ? 20 : 120);
		全局.vishkarEventActivated != 单次赋值(全局.dlcVishkarEvent);
	}

	动作
	{
		全局.vishkarEventActivated = 单次赋值(全局.dlcVishkarEvent);
		禁用 等待直到(总计消耗时间 > 全局.rebootTime, 999999986991104.000);
		中止;
	}
}

规则("initialize event array")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.vishkarEventActivated == 真;
	}

	动作
	{
		全局.globalEvent = 空数组;
		全局.globalEventId = 空数组;
		全局.globalEvent[0] = 数组(自定义字符串("势不可挡"), 自定义字符串("堡垒获得控制免疫"), 120);
		修改全局变量(globalEventId, 添加至数组, 0);

		全局.globalEvent[1] = 数组(自定义字符串("超算进化"), 自定义字符串("堡垒发射榴弹会附带1.5秒的控制特效"), 60);
		修改全局变量(globalEventId, 添加至数组, 1);

		全局.globalEvent[2] = 数组(自定义字符串("任务：生存"), 自定义字符串("持续期间内玩家团队总阵亡次数不超过10次"), 120);
		修改全局变量(globalEventId, 添加至数组, 2);

		全局.globalEvent[3] = 数组(自定义字符串("任务：占领"), 自定义字符串("倒计时结束时目标点范围内有4名玩家"), 120);
		// 修改全局变量(globalEventId, 添加至数组, 3);

		全局.globalEvent[4] = 数组(自定义字符串("任务：竞速"), 自定义字符串("倒计时结束时有 50% 以上的玩家挑战进度过半"), 600);
		修改全局变量(globalEventId, 添加至数组, 4);
	
		全局.buffEvent = 空数组;
		全局.buffEventId = 空数组;
		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 1：增益"), 自定义字符串("奥利维娅的礼物"), 真, 0), 2);
		全局.buffEvent[0] = 数组(自定义字符串("奥利维娅的礼物"), 自定义字符串("你好"), 5);
		修改全局变量(buffEventId, 添加至数组, 0);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 1：增益"), 自定义字符串("疾风祝福"), 真, 1), 2);
		全局.buffEvent[1] = 数组(自定义字符串("疾风祝福"), 自定义字符串("移动速度提高50%"), 20);
		修改全局变量(buffEventId, 添加至数组, 1);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 1：增益"), 自定义字符串("钢铁防线"), 真, 2), 2);
		全局.buffEvent[2] = 数组(自定义字符串("钢铁防线"), 自定义字符串("获得1500点临时护甲与25%伤害减免"), 25);
		修改全局变量(buffEventId, 添加至数组, 2);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 1：增益"), 自定义字符串("肾上腺素"), 真, 3), 2);
		全局.buffEvent[3] = 数组(自定义字符串("肾上腺素"), 自定义字符串("获得50%额外伤害减免"), 20);
		修改全局变量(buffEventId, 添加至数组, 3);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 1：增益"), 自定义字符串("生命源泉"), 真, 4), 2);
		全局.buffEvent[4] = 数组(自定义字符串("生命源泉"), 自定义字符串("每秒恢复15%最大生命值"), 30);
		修改全局变量(buffEventId, 添加至数组, 4);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 1：增益"), 自定义字符串("黑粉来袭"), 真, 5), 2);
		全局.buffEvent[5] = 数组(自定义字符串("黑粉来袭"), 自定义字符串("显示正在瞄准你的堡垒数量"), 20);
		修改全局变量(buffEventId, 添加至数组, 5);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 1：增益"), 自定义字符串("足力健"), 真, 6), 2);
		全局.buffEvent[6] = 数组(自定义字符串("足力健"), 自定义字符串("持续移动1秒获得3%可叠加的移动速度"), 45);
		修改全局变量(buffEventId, 添加至数组, 6);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 1：增益"), 自定义字符串("血肉再生"), 真, 7), 2);
		全局.buffEvent[7] = 数组(自定义字符串("血肉再生"), 自定义字符串("获得50+25%最大生命值的临时生命值，每4秒自动刷新"), 90);
		修改全局变量(buffEventId, 添加至数组, 7);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 1：增益"), 自定义字符串("心之钢"), 真, 8), 2);
		全局.buffEvent[8] = 数组(自定义字符串("心之钢"), 自定义字符串("阵亡后永久增加0.75%最大生命值"), 120);
		修改全局变量(buffEventId, 添加至数组, 8);

		// 2.0
		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：增益"), 自定义字符串("危险感知"), 真, 9), 2);
		全局.buffEvent[9] = 数组(自定义字符串("危险感知"), 自定义字符串("被锁定时获得60%移动速度与25%伤害减免"), 20);
		修改全局变量(buffEventId, 添加至数组, 9);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：增益"), 自定义字符串("反应装甲"), 真, 10), 2);
		全局.buffEvent[10] = 数组(自定义字符串("反应装甲"), 自定义字符串("获得一个可恢复的护甲\n如果堡垒对你的伤害未能击穿护甲\n堡垒将被短暂击晕"), 60);
		修改全局变量(buffEventId, 添加至数组, 10);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：增益"), 自定义字符串("死亡延迟"), 真, 11), 2);
		全局.buffEvent[11] = 数组(自定义字符串("死亡延迟"), 自定义字符串("受到致命伤害时\n阵亡将被延迟到事件结束后"), 30);
		修改全局变量(buffEventId, 添加至数组, 11);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：增益"), 自定义字符串("有我有你"), 真, 12), 2);
		全局.buffEvent[12] = 数组(自定义字符串("有我有你"), 自定义字符串("长按{0}附身一名队友\n该队友获得你最大生命值5%伤害减免\n你获得25%治疗增益并且会治疗队友", 按钮(互动)), 120);
		修改全局变量(buffEventId, 添加至数组, 12);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：增益"), 自定义字符串("↑↑↓↓←→←→BABA"), 真, 13), 2);
		全局.buffEvent[13] = 数组(自定义字符串("↑↑↓↓←→←→BABA"), 自定义字符串("如果在事件持续期间阵亡，你会在5秒前的位置复活，事件立刻结束"), 120);
		修改全局变量(buffEventId, 添加至数组, 13);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：增益"), 自定义字符串("费斯卡光子护盾"), 真, 14), 2);
		全局.buffEvent[14] = 数组(自定义字符串("费斯卡光子护盾"), 自定义字符串("所有人获得一个可恢复的护盾\n其数值为你最大生命值的 20%\n护盾持续到你阵亡或事件结束"), 120);
		修改全局变量(buffEventId, 添加至数组, 14);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 3：增益"), 自定义字符串("费斯卡呼吸机"), 真, 15), 2);
		全局.buffEvent[15] = 数组(自定义字符串("费斯卡呼吸机"), 自定义字符串("不受所有阻挡视线机制效果的影响"), 90);
		修改全局变量(buffEventId, 添加至数组, 15);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 3：增益"), 自定义字符串("向我靠拢"), 真, 16), 2);
		全局.buffEvent[16] = 数组(自定义字符串("向我靠拢"), 自定义字符串("你和你附近的队友每5秒获得2.5秒伤害免疫"), 30);
		修改全局变量(buffEventId, 添加至数组, 16);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 3：增益"), 自定义字符串("我独自闯关"), 真, 17), 2);
		全局.buffEvent[17] = 数组(自定义字符串("我独自闯关"), 自定义字符串("获得伤害减免、治疗增益、移速加成与击退抵抗"), 120);
		修改全局变量(buffEventId, 添加至数组, 17);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 3：增益"), 自定义字符串("坚定"), 真, 18), 2);
		全局.buffEvent[18] = 数组(自定义字符串("坚定"), 自定义字符串("获得95%击退抵抗\r受到击退获得5%可叠加的伤害减免并回复8%最大生命值"), 120);
		修改全局变量(buffEventId, 添加至数组, 18);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 3：增益"), 自定义字符串("胜利意志"), 真, 19), 2);
		全局.buffEvent[19] = 数组(自定义字符串("胜利意志"), 自定义字符串("生命值低于30%触发，获得5秒伤害免疫并清除负面状态，回复所有已损失生命值"), 30);
		修改全局变量(buffEventId, 添加至数组, 19);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 3：增益"), 自定义字符串("任务：菲迪皮德斯之力"), 真, 20), 2);
		全局.buffEvent[20] = 数组(自定义字符串("任务：菲迪皮德斯之力"), 自定义字符串("持续移动42.195秒后永久获得5%移速加成"), 45);
		修改全局变量(buffEventId, 添加至数组, 20);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 3：增益"), 自定义字符串("心之钢 Pro"), 真, 21), 2);
		全局.buffEvent[21] = 数组(自定义字符串("心之钢 Pro"), 自定义字符串("基于心之钢层数提升最大生命值，数值为心之钢层数×2"), 90);
		修改全局变量(buffEventId, 添加至数组, 21);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 3：增益"), 自定义字符串("数值之力"), 真, 22), 2);
		全局.buffEvent[22] = 数组(自定义字符串("数值之力"), 自定义字符串("获得 500% 治疗增益与受治疗增益"), 90);
		修改全局变量(buffEventId, 添加至数组, 22);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 3：增益"), 自定义字符串("我按Q辣"), 真, 23), 2);
		全局.buffEvent[23] = 数组(自定义字符串("我按Q辣"), 自定义字符串("持续移动获得终极技能充能，终极技能持续期间获得75%伤害减免"), 120);
		修改全局变量(buffEventId, 添加至数组, 23);

		// "debuff"
		全局.debuffEvent = 空数组;
		全局.debuffEventId = 空数组;

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 1：减益"), 自定义字符串("重力异常"), 真, 0), 2);
		全局.debuffEvent[0] = 数组(自定义字符串("重力异常"), 自定义字符串("移动速度降低50%，跳跃高度降低70%"), 20);
		修改全局变量(debuffEventId, 添加至数组, 0);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 1：减益"), 自定义字符串("电磁脉冲"), 真, 1), 2);
		全局.debuffEvent[1] = 数组(自定义字符串("电磁脉冲"), 自定义字符串("被侵入，无法使用技能"), 8);
		修改全局变量(debuffEventId, 添加至数组, 1);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 3：减益"), 自定义字符串("吸血鬼"), 真, 2), 2);
		全局.debuffEvent[2] = 数组(自定义字符串("吸血鬼"), 自定义字符串("队友使用技能时会消耗你 10% 最大生命值"), 30);
		修改全局变量(debuffEventId, 添加至数组, 2);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 1：减益"), 自定义字符串("易损"), 真, 3), 2);
		全局.debuffEvent[3] = 数组(自定义字符串("易损"), 自定义字符串("受到的所有伤害提高25%"), 25);
		修改全局变量(debuffEventId, 添加至数组, 3);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 1：减益"), 自定义字符串("限速40"), 真, 4), 2);
		全局.debuffEvent[4] = 数组(自定义字符串("限速40"), 自定义字符串("移动时每秒损失25+7.5%最大生命值"), 25);
		修改全局变量(debuffEventId, 添加至数组, 4);

		// 2.0
		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：减益"), 自定义字符串("引力异常"), 真, 5), 2);
		全局.debuffEvent[5] = 数组(自定义字符串("引力异常"), 自定义字符串("被持续性拉向最近的堡垒，移动速度降低25%"), 20);
		修改全局变量(debuffEventId, 添加至数组, 5);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：减益"), 自定义字符串("骨质疏松"), 真, 5), 2);
		全局.debuffEvent[6] = 数组(自定义字符串("骨质疏松"), 自定义字符串("移动速度随时间降低，最多50%"), 30);
		修改全局变量(debuffEventId, 添加至数组, 6);
		
		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：减益"), 自定义字符串("电磁脉冲 ProMax"), 真, 7), 2);
		全局.debuffEvent[7] = 数组(自定义字符串("电磁脉冲 ProMax"), 自定义字符串("被侵入，无法使用技能，以你为中心扩散至75米以内的队友"), 8);
		修改全局变量(debuffEventId, 添加至数组, 7);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：减益"), 自定义字符串("能量泄漏"), 真, 8), 2);
		全局.debuffEvent[8] = 数组(自定义字符串("能量泄漏"), 自定义字符串("使用技能会消耗25%生命值"), 30);
		修改全局变量(debuffEventId, 添加至数组, 8);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：减益"), 自定义字符串("生命在于运动"), 真, 9), 2);
		全局.debuffEvent[9] = 数组(自定义字符串("生命在于运动"), 自定义字符串("每秒扣除1.5%最大生命值，移动时扣除速度翻倍"), 45);
		修改全局变量(debuffEventId, 添加至数组, 9);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：减益"), 自定义字符串("有难同当"), 真, 10), 2);
		全局.debuffEvent[10] = 数组(自定义字符串("有难同当"), 自定义字符串("受到的75%伤害会扩散给15米内的友方"), 30);
		修改全局变量(debuffEventId, 添加至数组, 10);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：减益"), 自定义字符串("狂欢盛宴"), 真, 11), 2);
		全局.debuffEvent[11] = 数组(自定义字符串("狂欢盛宴"), 自定义字符串("当你在盛宴期间内阵亡，堡垒将进入10秒狂暴状态"), 45);
		修改全局变量(debuffEventId, 添加至数组, 11);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：减益"), 自定义字符串("无能的丈夫/妻子"), 真, 12), 2);
		全局.debuffEvent[12] = 数组(自定义字符串("无能的丈夫/妻子"), 自定义字符串("附近的友方将被击倒2秒"), 2);
		修改全局变量(debuffEventId, 添加至数组, 12);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 3：减益"), 自定义字符串("重伤"), 真, 13), 2);
		全局.debuffEvent[13] = 数组(自定义字符串("重伤"), 自定义字符串("造成治疗与受到的治疗降低85%"), 45);
		修改全局变量(debuffEventId, 添加至数组, 13);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 3：减益"), 自定义字符串("减半"), 真, 14), 2);
		全局.debuffEvent[14] = 数组(自定义字符串("减半"), 自定义字符串("每5秒损失50%生命值，当生命值低于5%时立即阵亡"), 45);
		修改全局变量(debuffEventId, 添加至数组, 14);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 3：减益"), 自定义字符串("舍己为人"), 真, 15), 2);
		全局.debuffEvent[15] = 数组(自定义字符串("舍己为人"), 自定义字符串("基于玩家数量降低你的最大生命值，每名玩家降低1%，由其他玩家均分"), 5);
		修改全局变量(debuffEventId, 添加至数组, 15);

		// "机制"
		全局.mechEvent = 空数组;
		全局.mechEventId = 空数组;

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 3：机制"), 自定义字符串("极限挑战"), 真, 0), 2);
		全局.mechEvent[0] = 数组(自定义字符串("极限挑战"), 自定义字符串("获得99%伤害减免，生命值被锁定在30%，无法受到任何治疗与生命恢复效果"), 60);
		修改全局变量(mechEventId, 添加至数组, 0);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 1：机制"), 自定义字符串("纳米战甲"), 真, 1), 2);
		全局.mechEvent[1] = 数组(自定义字符串("纳米战甲"), 自定义字符串("获得最大生命值800%的临时生命值，被减速25%"), 15);
		修改全局变量(mechEventId, 添加至数组, 1);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 1：机制"), 自定义字符串("赌徒"), 真, 2), 2);
		全局.mechEvent[2] = 数组(自定义字符串("赌徒"), 自定义字符串("长按{0}触发：50%概率永久损失/增加10%最大生命值", 按钮(装填)), 15);
		修改全局变量(mechEventId, 添加至数组, 2);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 1：机制"), 自定义字符串("有点松弛"), 真, 3), 2);
		全局.mechEvent[3] = 数组(自定义字符串("有点松弛"), 自定义字符串("移动时产生阻挡友方视线的迷雾"), 45);
		修改全局变量(mechEventId, 添加至数组, 3);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 1：机制"), 自定义字符串("体积膨胀"), 真, 4), 2);
		全局.mechEvent[4] = 数组(自定义字符串("体积膨胀"), 自定义字符串("体积变大175%，最大生命值提高400%，获得20%伤害减免"), 60);
		修改全局变量(mechEventId, 添加至数组, 4);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 1：机制"), 自定义字符串("迷你形态"), 真, 5), 2);
		全局.mechEvent[5] = 数组(自定义字符串("迷你形态"), 自定义字符串("体积缩小60%，最大生命值降低50%，获得25%移速加成"), 60);
		修改全局变量(mechEventId, 添加至数组, 5);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 1：机制"), 自定义字符串("悄悄滴进村"), 真, 6), 2);
		全局.mechEvent[6] = 数组(自定义字符串("悄悄滴进村"), 自定义字符串("下蹲隐身，移动速度降低 25%"), 30);
		修改全局变量(mechEventId, 添加至数组, 6);

		// 2.0
		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：机制"), 自定义字符串("紧急避障"), 真, 7), 2);
		全局.mechEvent[7] = 数组(自定义字符串("紧急避障"), 自定义字符串("受到伤害3秒内移动速度提高 80%"), 45);
		修改全局变量(mechEventId, 添加至数组, 7);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：机制"), 自定义字符串("逆风而行"), 真, 8), 2);
		全局.mechEvent[8] = 数组(自定义字符串("逆风而行"), 自定义字符串("移动速度提高 60%，但只能向后移动"), 30);
		修改全局变量(mechEventId, 添加至数组, 8);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：机制"), 自定义字符串("刹车失灵"), 真, 9), 2);
		全局.mechEvent[9] = 数组(自定义字符串("刹车失灵"), 自定义字符串("不受控的向前移动，移动速度会逐渐提高至 175%"), 45);
		修改全局变量(mechEventId, 添加至数组, 9);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 3：机制"), 自定义字符串("冲锋激励"), 真, 10), 2);
		全局.mechEvent[10] = 数组(自定义字符串("冲锋激励"), 自定义字符串("持续移动5秒获得100能量，能量充满后转化为临时护甲"), 90);
		修改全局变量(mechEventId, 添加至数组, 10);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 3：机制"), 自定义字符串("生命在于反击"), 真, 11), 2);
		全局.mechEvent[11] = 数组(自定义字符串("生命在于反击"), 自定义字符串("基于已损失生命值获得移速加成与伤害减免，每损失1%生命值获得1%加成（最高75%）"), 90);
		修改全局变量(mechEventId, 添加至数组, 11);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 3：机制"), 自定义字符串("屁动力"), 真, 12), 2);
		全局.mechEvent[12] = 数组(自定义字符串("屁动力"), 自定义字符串("长按{0}朝你的前方飞行，飞行时获得50%伤害减免", 按钮(跳跃)), 30);
		修改全局变量(mechEventId, 添加至数组, 12);

		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 3：机制"), 自定义字符串("赌徒：生命投资"), 真, 13), 2);
		// 全局.mechEvent[13] = 数组(自定义字符串("赌徒：生命投资"), 自定义字符串("长按{0}消耗 50% 生命值，从增益/减益事件组中随机抽取一个事件。", 按钮(装填)), 15);
		// 修改全局变量(mechEventId, 添加至数组, 13);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 3：机制"), 自定义字符串("赌徒：竞速挑战"), 真, 13), 2);
		全局.mechEvent[13] = 数组(自定义字符串("赌徒：竞速挑战"), 自定义字符串("长按{0}消耗50%生命值\n49%概率永久获得/损失5%移速加成\n2% 概率永久获得/损失 12% 移速加成", 按钮(装填)), 15);
		修改全局变量(mechEventId, 添加至数组, 13);
	}
}

规则("[VishkarEvent]: set player event")
{
	事件
	{
		子程序;
		setPlayerEvent;
	}

	动作
	{
		事件玩家.categoryRoll = 随机整数(0, 100);
		if(事件玩家.categoryRoll <= 40);
            // 增益事件 40%
            事件玩家.eventType = 0;
			事件玩家.eventId = 随机整数(0, 100) < 33 ? 数组随机取值(全局.buffEventId) : 数组随机取值(从数组中移除(全局.buffEventId, 事件玩家.eventLastId));
			事件玩家.eventName = 首个(全局.buffEvent[事件玩家.eventId]);
			事件玩家.eventDesc = 全局.buffEvent[事件玩家.eventId][1];
			事件玩家.eventDuration = 最后(全局.buffEvent[事件玩家.eventId]);
			根据条件跳过(事件玩家.eventId == 0, 1);
			事件玩家.eventCount[0] += 1;
			事件玩家.eventLucky = 事件玩家.eventLucky > 0 ? 事件玩家.eventLucky + 1 : 1;
        else if(事件玩家.categoryRoll <= 80);
			// 减益事件 40%
			事件玩家.eventType = 1;
			事件玩家.eventId = 随机整数(0, 100) < 33 ? 数组随机取值(全局.debuffEventId) : 数组随机取值(从数组中移除(全局.debuffEventId, 事件玩家.eventLastId));
			事件玩家.eventName = 首个(全局.debuffEvent[事件玩家.eventId]);
			事件玩家.eventDesc = 全局.debuffEvent[事件玩家.eventId][1];
			事件玩家.eventDuration = 最后(全局.debuffEvent[事件玩家.eventId]);
			事件玩家.eventCount[1] += 1;
			事件玩家.eventLucky = 事件玩家.eventLucky < 0 ? 事件玩家.eventLucky - 1 : -1;
		else;
			// 机制事件 20%
			事件玩家.eventType = 2;
			事件玩家.eventId = 随机整数(0, 100) < 50 ? 数组随机取值(全局.mechEventId) : 数组随机取值(从数组中移除(全局.mechEventId, 事件玩家.eventLastId));
			事件玩家.eventName = 首个(全局.mechEvent[事件玩家.eventId]);
			事件玩家.eventDesc = 全局.mechEvent[事件玩家.eventId][1];
			事件玩家.eventDuration = 最后(全局.mechEvent[事件玩家.eventId]);
			事件玩家.eventCount[2] += 1;
		end;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		事件玩家.eventLastId = 事件玩家.eventId;
		根据条件跳过(事件玩家.eventDesc == 空, 4);
		根据条件跳过(事件玩家.eventId == 666, 2);
		小字体信息(事件玩家, 自定义字符串("  {0}  触发事件：{1}（{2}）", 技能图标字符串(英雄(黑影), 按钮(终极技能)), 事件玩家.eventName, 事件玩家.eventDuration > 0 ? 自定义字符串("{0}秒", 事件玩家.eventDuration) : 自定义字符串("一次性")));
		小字体信息(事件玩家, 自定义字符串("  {0}  事件效果：{1}", 技能图标字符串(英雄(黑影), 按钮(终极技能)), 事件玩家.eventDesc));
		调用子程序(setEventDuration);
	}
}

规则("[VishkarEvent]: player event end")
{
	事件
	{
		子程序;
		clearPlayerEvent;
	}

	动作
	{
		停止限制阈值(事件玩家);
		停止定向阈值(事件玩家);
		事件玩家.combatRegen = 假;
		事件玩家.categoryRoll = 空;
		事件玩家.eventId = -1;
		事件玩家.eventType = 空;
		事件玩家.eventDuration = 空;
		事件玩家.eventName = 空;
		事件玩家.eventDesc = 空;
		事件玩家.mod_speed_event = 空;
		事件玩家.mod_heal_event = 空;
		事件玩家.heal_recv = 空;
		事件玩家.mod_dmg_taken = 空;
		事件玩家.targetWeight = 空;
		事件玩家.targetSilence = 假;
		事件玩家.knockback = 空;
		事件玩家.sizeHealth = 1;
		根据条件跳过(事件玩家.isWinner, 1);
		消除效果(事件玩家.invincibleEffect);
		// 事件玩家.eventEffect = 空;
		事件玩家.eventMission = 0;
		消除HUD文本(事件玩家.hudTextId);
		事件玩家.hudTextId = 空;
		事件玩家.target = 空;
		事件玩家.possess = 空;
		调用子程序(updatePlayerStats);
		调用子程序(clearEventEffect);
		小字体信息(事件玩家, 自定义字符串("  {0} 事件已结束", 技能图标字符串(英雄(莫伊拉), 按钮(技能2))));
	}
}

规则("[VishkarEvent]: set player HP")
{
	事件
	{
		子程序;
		setPlayerHP;
	}

	动作
	{
		// 等待(服务器负载 / 100 * 0.032, 无视条件);
		设置最大生命值(事件玩家, 100 * 事件玩家.sizeHealth + 事件玩家.heart_steel);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		根据条件跳过(标准化生命值(事件玩家) == 1, 1);
		设置玩家生命值(事件玩家, 最大生命值(事件玩家));
	}
}

规则("[VishkarEvent]: set Event Duration")
{
	事件
	{
		子程序;
		setEventDuration;
	}

	动作
	{
		// 等待(服务器负载 / 100 * 0.032, 无视条件);
		停止追踪玩家变量(事件玩家, eventDurationHud);
		事件玩家.eventDurationHud = 事件玩家.eventDuration;
		追踪玩家变量频率(事件玩家, eventDurationHud, 0, 1, 全部禁用);
	}
}

规则("[VishkarEvent]: reset Player Ability CD")
{
	事件
	{
		子程序;
		resetPlayerCD;
	}

	动作
	{
		// 等待(服务器负载 / 100 * 0.032, 无视条件);
		设置技能冷却(事件玩家, 按钮(主要攻击模式), 0);
		设置技能冷却(事件玩家, 按钮(辅助攻击模式), 0);
		设置技能冷却(事件玩家, 按钮(技能1), 0);
		设置技能冷却(事件玩家, 按钮(技能2), 0);
		设置技能冷却(事件玩家, 按钮(跳跃), 0);
		设置技能冷却(事件玩家, 按钮(装填), 0);
		等待(服务器负载 / 100 * 0.032, 无视条件);
	}
}

规则("[VishkarEvent]: clear Player event effect")
{
	事件
	{
		子程序;
		clearEventEffect;
	}

	动作
	{
		IF(数量(事件玩家.eventEffect) > 0);
			While(数量(事件玩家.eventEffect) > 0);
				消除效果(首个(事件玩家.eventEffect));
				修改玩家变量(事件玩家, eventEffect, 根据值从数组中移除, 首个(事件玩家.eventEffect));
			End;
		Else;
			消除效果(事件玩家.eventEffect);
		END;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		事件玩家.eventEffect = 空;
	}
}

规则("[VishkarEvent]: update Player Stats")
{
	事件
	{
		子程序;
		updatePlayerStats;
	}

	动作
	{
		设置移动速度(事件玩家, 100 + 事件玩家.mod_speed_perma + 事件玩家.mod_speed_event);

		设置受到伤害(事件玩家, 100 + 事件玩家.mod_dmg_perma + 事件玩家.mod_dmg_taken);

		设置造成治疗(事件玩家, 100 + 事件玩家.mod_heal_event);

		设置受到治疗(事件玩家, 100 + 事件玩家.heal_recv);
		设置受到的击退(事件玩家, 100 + 事件玩家.knockback);
	}
}

规则("[VishkarEvent]: stop Combat Regen")
{
	事件
	{
		子程序;
		stopCombatRegen;
	}

	动作
	{
		根据条件跳过(事件玩家.combatRegen, 1);
		事件玩家.combatRegen = 真;
	}
}

规则("[VishkarEvent]: get player event")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		玩家数量(队伍2) == 数量(全局.bastionPosition);
		对全部为“真”(数组(
			全局.vishkarEventActivated,
			已重生(事件玩家),
			事件玩家.eventId == -1
		), 当前数组元素);
		// 事件玩家.heroNumber > 2;
		对任意为“真”(数组(首个(事件玩家.playerTitles)[1] == 矢量(149, 239, 66) && 事件玩家.heroNumber >= 1, 事件玩家.heroNumber > 2), 当前数组元素) == 真;
	}

	动作
	{
		等待(单次赋值(全局.debugMode) ? 10 : !事件玩家.isWinner ? 随机整数(25, 30) : 30, 当为“假”时中止);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		调用子程序(setPlayerEvent);
		等待直到(事件玩家.eventDuration == 0, 事件玩家.eventDuration);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		调用子程序(clearPlayerEvent);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		如条件为“真”则循环;
	}
}

规则("[VishkarEvent]: check player event lucky")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		全局.hashTag == 真;
		全局.vishkarEventActivated == 真;
		已重生(事件玩家) == 真;
		// 事件玩家.isWinner != 真;
		事件玩家.eventLucky >= 10;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 无视条件);
		创建HUD文本(事件玩家, 空, 自定义字符串("幸运星 {0} ", 图标字符串(星形)), 空, 左边, 70, 空, 自定义颜色(X方向分量(全局.heroColor[5]),Y方向分量(全局.heroColor[5]),Z方向分量(全局.heroColor[5]),255), 空, 可见和字符串, 始终不可见);
		等待直到(总计消耗时间 > 全局.rebootTime, 999999986991104.000);
	}
}

规则("[VishkarEvent]: check player event unlucky")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		全局.hashTag == 真;
		全局.vishkarEventActivated == 真;
		已重生(事件玩家) == 真;
		// 事件玩家.isWinner != 真;
		事件玩家.eventLucky == -10;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 无视条件);
		创建HUD文本(事件玩家, 空, 自定义字符串("What Can I Say {0} ", 图标字符串(晕眩)), 空, 左边, 71, 空, 自定义颜色(X方向分量(全局.heroColor[5]),Y方向分量(全局.heroColor[5]),Z方向分量(全局.heroColor[5]),255), 空, 可见和字符串, 始终不可见);
		等待直到(总计消耗时间 > 全局.rebootTime, 999999986991104.000);
	}
}

规则("set player title")
{
	事件
	{
		子程序;
		setPlayerTitle;
	}
	
	动作
	{
		// 1. 获取该玩家的基础称号索引列表
        // 假设 全局.playerTitleRelation[Index] 存储的是 [12, 13, 16...]
        事件玩家.tempIndices = 全局.playerTitleRelation[事件玩家.playerTitleRelationIndex];

        // 2. 处理地图专属称号 (一次性过滤，不要放在循环里)
        // 找出所有属于该玩家的地图关系：例如 [[玩家Index, 称号Index], ...]
        事件玩家.tempMapMatches = 已过滤的数组(全局.mapTitleRelation, 首个(当前数组元素) == 事件玩家.playerTitleRelationIndex);

		If(数量(事件玩家.tempMapMatches) > 0);
            // 提取地图称号的 ID (即当前数组元素的第 2 个值)
            事件玩家.tempMapIndices = 映射的数组(事件玩家.tempMapMatches, 当前数组元素[1]);
            // 合并索引数组
            事件玩家.tempIndices = 添加至数组(事件玩家.tempIndices, 事件玩家.tempMapIndices);
        End;

		// 3. 【核心优化】使用映射数组一次性生成称号数据
        // 直接将 ID 列表 [12, 13...] 转换为 称号数据列表 [[名称, 颜色], [名称, 颜色]...]
        // 这行代码在服务器内部是原子操作，执行速度比 While 快 100 倍以上
        事件玩家.playerTitles = 映射的数组(事件玩家.tempIndices, 全局.allTitle[当前数组元素]);

		事件玩家.tempIndices = 空;
        事件玩家.tempMapIndices = 空;
        事件玩家.tempMapMatches = 空;
        
		// 事件玩家.playerTitleAndColor = 数组(首个(最后(事件玩家.playerTitles)), 最后(最后(事件玩家.playerTitles)));
	}
}

规则("save player data if the player has pa﻿ssed round 2")
{
	事件
	{
		子程序;
		savePlayerData;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.500, 无视条件);
		If(事件玩家.heroNumber > 2);
			"We're saving data as a string, because although we can't hold entity id's, we can hold entity names as string."
			If(!数组包含(全局.savedIndex, 自定义字符串("{0}", 事件玩家)));
				修改全局变量(savedIndex, 添加至数组, 自定义字符串("{0}", 事件玩家));
			End;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			全局.savedHero[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.heroNumber;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			全局.savedDeaths[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.runDeathCount;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			全局.savedIsWinner[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.isWinner;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			全局.savedSkipCount[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.skipCount;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			根据条件跳过(事件玩家.winnerTime == 空, 1);
			全局.savedWinnerTime[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.winnerTime;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			全局.savedA36TGrenade[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.A36TGrenade;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			全局.savedA36TGrenadeHit[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.A36TGrenadeHit;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			全局.savedA36TGrenadeDmg[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.A36TGrenadeDmg;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			全局.savedA36TGrenadeAlive[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.A36TGrenadeAlive;
			全局.savedJoinTime[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.joinTime;
			小字体信息(事件玩家, 自定义字符串("  你的挑战进度已保存"));
			等待(2, 无视条件);
			根据条件跳过(事件玩家 != 主机玩家, 1);
			小字体信息(主机玩家, 自定义字符串("  如果当前游戏重开，所有人的进度数据将被清空"));
			等待(2, 无视条件);
			IF(随机整数(0, 2) == 0);
				小字体信息(事件玩家, 自定义字符串("  为了保证房间处于公开状态，请确保房主赞赏等级为 3 级或以上"));
			END;
		End;
	}
}

规则("add 1 to heroNumber, switch player to the newly unlocked hero, and set hero availability to that hero and all preceding")
{
	事件
	{
		子程序;
		progressHero;
	}

	动作
	{
		事件玩家.heroNumber += 1;
		事件玩家.controlJumpIndex = 0;
		事件玩家.controlPlayerRespawnPosition = 空;
		// 小字体信息(所有玩家(所有队伍), 自定义字符串("  {0} 已经解锁 {1}！", 事件玩家, 英雄图标字符串(全局.heroList[事件玩家.heroNumber])));
		播放效果(事件玩家, 状态爆炸声音, 颜色(白色), 所选位置(事件玩家), 200);
		事件玩家.progressionDeathCount = 0;
		等待(0.032, 无视条件);
		开始强制玩家选择英雄(事件玩家, 全局.heroList[事件玩家.heroNumber]);
		等待直到 (所用英雄(事件玩家) == 全局.heroList[事件玩家.heroNumber], 0.500);
		停止强制玩家选择英雄(事件玩家);
		等待(服务器负载 / 100 * 0.500, 无视条件);
		设置玩家可选的英雄(事件玩家, 数组分割(全局.heroList, 0, 事件玩家.heroNumber + 1));
		等待(服务器负载 / 100 * 0.500, 无视条件);
		预加载英雄(事件玩家, 数组(全局.heroList[事件玩家.heroNumber + 1], 全局.heroList[事件玩家.heroNumber + 1]));
		等待(服务器负载 / 100 * 0.500, 无视条件);
		等待(3, 无视条件);
		调用子程序(savePlayerData);
		等待(0.100, 无视条件);
	}
}

规则("initialize difficulty effects text")
{
	事件
	{
		子程序;
		setDifficulty;
	}

	动作
	{
		等待(服务器负载 / 100, 无视条件);
		If(真);
			跳过(数组(18, 0, 3, 6, 9, 12, 15)[1 + 数组值的索引(数组(0, 1, 2, 3, 4, 5), 全局.difficulty)]);
			全局.difficultyText[0] = 自定义字符串("简单");
			全局.difficultyText[1] = 颜色(绿色);
		Else;
			全局.difficultyText[0] = 自定义字符串("一般");
			全局.difficultyText[1] = 颜色(灰绿色);
		Else;
			全局.difficultyText[0] = 自定义字符串("困难");
			全局.difficultyText[1] = 颜色(黄色);
		Else;
			全局.difficultyText[0] = 自定义字符串("专家");
			全局.difficultyText[1] = 颜色(橙色);
		Else;
			全局.difficultyText[0] = 自定义字符串("传奇");
			全局.difficultyText[1] = 颜色(红色);
		Else;
			全局.difficultyText[0] = 自定义字符串("地狱");
			全局.difficultyText[1] = 颜色(紫色);
		Else;
		End;
	}
}

规则("3rd camera function")
{
	事件
	{
		子程序;
		setThirdPerson;
	}

	动作
	{
		事件玩家.third = !事件玩家.third;
		If(事件玩家.third);
			"by overclocking"
			开始镜头(事件玩家, 射线命中位置(事件玩家 + 上 * (相距距离(眼睛位置(事件玩家), 事件玩家) + 0.500), 射线命中位置(事件玩家 + 上 * (相距距离(眼睛位置(事件玩家), 事件玩家) + 0.500), 事件玩家 + 上 * (
				相距距离(眼睛位置(事件玩家), 事件玩家) + 0.500) + 面朝方向(事件玩家) * -3, 空, 事件玩家, 真), 空, 事件玩家, 真), 事件玩家 + 面朝方向(事件玩家) * 100, 100);
		Else;
			停止镜头(事件玩家);
		End;
	}
}

规则("map - b﻿lizzworld")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(暴雪世界) || 全局.__currentMap__ == 1228) == 真;
	}

	动作
	{
		全局.bastionPosition = 数组(矢量(-114.474, 4.902, 100.451), 矢量(-115.368, 4.750, 129.864), 矢量(-82.619, 1.750, 147.017), 矢量(-35.778,
		11.637, 106.066), 矢量(-38.722, -0.204, 66.024), 矢量(25.083, 6, 67.282), 矢量(3.062, -0.097, 20.980), 矢量(23.863, -4, 0.817));
		全局.endPosition = 矢量(26.53,-4.1,-7.83);
		全局.thirdPersonPosition = 矢量(-149.170, 0.830, 100.850);
		全局.resetPosition = 矢量(-150.250, 0.830, 104.510);
		全局.creditsPosition = 矢量(-170.800, 3.650, 96.450);
		开始强制重生室(队伍1, 2);
		全局.__currentMapText__ = 自定义字符串("暴雪世界");
		全局.__currentMapPioneerText__ = 全局.__currentMapText__;
		全局.mapTitleRelation = 数组(
            // 格式: [玩家索引, 称号索引]
            数组(7, 9), // 吾携秋水揽星河-征服者
            数组(7, 10), // 吾携秋水揽星河-主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰

			// 雨鸢 (索引24)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰

			// 糯米进脑子 (索引29)
			数组(29, 9),  // 征服者
			数组(29, 10), // 主宰

			// Augenstern (索引33)
			数组(33, 9),  // 征服者
			数组(33, 10), // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10) // 主宰
        );
	}
}

规则("map - dorado")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(多拉多);
	}

	动作
	{
		// 全局.bastionPosition = 矢量(170.288, 19.100, 45.051);
		全局.bastionPosition = 矢量(167.25, 10.85, 42.40);
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(126.713, 16.300, 17.517));
		修改全局变量(bastionPosition, 添加至数组, 矢量(113.04, 13.800, 24.63));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(118.262, 18.250, 1.209));
		修改全局变量(bastionPosition, 添加至数组, 矢量(112.06, 17.250, -2.91));
		修改全局变量(bastionPosition, 添加至数组, 矢量(102.79, 11.01, -23.56));
		修改全局变量(bastionPosition, 添加至数组, 矢量(78.973, 17.480, -6.843));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(34.074, 11.080, -17.958));
		修改全局变量(bastionPosition, 添加至数组, 矢量(34.78, 10.05, -6.80));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(26.361, 10.650, 20.115));
		修改全局变量(bastionPosition, 添加至数组, 矢量(32.21, 10.59, 20.55));
		修改全局变量(bastionPosition, 添加至数组, 矢量(8.83, 2.380, 25.76));
		// 全局.endPosition = 矢量(16.012, 空数组, 5.874);
		全局.endPosition = 矢量(15.47, 9.54, -1.000);
		全局.thirdPersonPosition = 矢量(182.470, 7.040, 42.270);
		全局.resetPosition = 矢量(183.300, 7.040, 37.960);
		全局.creditsPosition = 矢量(197.720, 10.010, 44.630);
		开始强制重生室(队伍1, 1);
		全局.mapTitleRelation = 数组(
			// 卖核弹的小女孩 - 征服者
			数组(13, 9),
			数组(13, 10),
			
			// 吾携秋水揽星河 - 征服者和主宰
			数组(7, 9),
			数组(7, 10),

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			
			// Cold - 征服者和主宰
			数组(9, 9),
			数组(9, 10),

			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰
			
			// 看啊情 - 征服者和主宰
			数组(17, 9),
			数组(17, 10),

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// EruIluvatar (索引28)
			数组(28, 9),  // 征服者
			数组(28, 10), // 主宰

			// 糯米进脑子 (索引29)
			数组(29, 9),  // 征服者
			数组(29, 10), // 主宰

			// 明月有时圆 (索引34)
			数组(34, 9),  // 征服者
			数组(34, 10), // 主宰
			
			// 尘风歌者 - 征服者和主宰
			数组(6, 9),
			数组(6, 10)
		);
	}
}

规则("map - eichenwalde")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(艾兴瓦尔德) || 全局.__currentMap__ == 565) == 真;
	}

	动作
	{
		全局.bastionPosition = 矢量(115.780, 14.732, -29.038);
		修改全局变量(bastionPosition, 添加至数组, 矢量(119.480, 18.855, -43.120));
		修改全局变量(bastionPosition, 添加至数组, 矢量(54.429, 23.320, -102.936));
		修改全局变量(bastionPosition, 添加至数组, 矢量(75.164, 12.660, -71.852));
		修改全局变量(bastionPosition, 添加至数组, 矢量(36.490, 8.938, -71.140));
		修改全局变量(bastionPosition, 添加至数组, 矢量(2.584, 8.026, -63.687));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-12.503, 3.514, -31.548));
		修改全局变量(bastionPosition, 添加至数组, 矢量(0.632, 6.073, -2.154));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-32.381, -1.334, 0.005));
		修改全局变量(bastionPosition, 添加至数组, 矢量(70.234, 18.381, -65.979));
		修改全局变量(bastionPosition, 添加至数组, 矢量(8.544, 10.396, -42.598));
		// 全局.bastionPosition[0] = 矢量(123.333, 8.971, -27.303);
		// 全局.bastionPosition[1] = 矢量(89.318, 21.095, -62.697);
		// 全局.bastionPosition[2] = 矢量(37.930, 12.620, -79.920);
		// 全局.bastionPosition[3] = 矢量(23.799, 7.417, -53.839);
		// 全局.bastionPosition[4] = 矢量(-4.858, 6.957, -31.559);
		// 全局.bastionPosition[5] = 矢量(25.587, 6.300, -14.531);
		// 全局.endPosition = 矢量(-10.354, -2.149, -12.399);
		全局.endPosition = 矢量(-26.72, 1.97, -34.09);
		全局.thirdPersonPosition = 矢量(131.335, 10.720, 1.098);
		全局.resetPosition = 矢量(128.060, 10.720, 1.840);
		全局.creditsPosition = 矢量(132.820, 13.720, 9.040);
		开始强制重生室(队伍1, 2);
		全局.__currentMapText__ = 全局.__currentMap__ == 565 ? 自定义字符串("阿德勒斯布鲁恩") : 当前地图;
		全局.__currentMapPioneerText__ = 全局.__currentMapText__;
		全局.mapTitleRelation = 数组(
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰
			数组(6, 0),   // 开拓者
			
			// 顾北酒笙 (索引4)
			数组(4, 9),   // 征服者
			数组(4, 10),  // 主宰
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			数组(7, 0),   // 开拓者
			
			// 挽风 (索引14)
			数组(14, 9),  // 征服者
			
			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10),  // 主宰
			
			// 看啊情 (索引17)
			数组(17, 9),  // 征服者
			
			// 她说话有股孩子气 (索引21)
			数组(21, 9),  // 征服者
			
			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰
			数组(12, 0),  // 开拓者
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			数组(9, 0),   // 开拓者

			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰
			数组(10, 0),   // 开拓者
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			数组(8, 0),   // 开拓者
			
			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰
			数组(18, 0),  // 开拓者
			
			// EruIluvatar (索引28)
			数组(28, 9),  // 征服者
			数组(28, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰
			数组(19, 0),  // 开拓者
			
			// 锦木千束 (索引20)
			数组(20, 9),  // 征服者
			数组(20, 10), // 主宰
			数组(20, 0)   // 开拓者
		);
	}
}

规则("map - havana")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(哈瓦那);
	}

	动作
	{
		全局.bastionPosition = 矢量(117.332, 14.433, -58.091);
		修改全局变量(bastionPosition, 添加至数组, 矢量(97.00, 9.01, -25.51));
		修改全局变量(bastionPosition, 添加至数组, 矢量(62.21, 12.06, -83.30));
		修改全局变量(bastionPosition, 添加至数组, 矢量(11.580, 7.960, -52.71));
		修改全局变量(bastionPosition, 添加至数组, 矢量(10.13, 6.000, -100.38));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-37.54, 8.230, -72.23));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-77.17, 10.13, -66.78));
		全局.endPosition = 矢量(-77.24, 7.22, -49.83);
		全局.thirdPersonPosition = 矢量(158.256, 11, -47.739);
		全局.resetPosition = 矢量(158.300, 11, -44.350);
		全局.creditsPosition = 矢量(193.450, 13.250, -46.490);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(
			数组(0, 9),   // 征服者
			数组(0, 10),  // 主宰
			数组(1, 9),   // 征服者
			数组(1, 10),  // 主宰
			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰

			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰

			// 尘风歌者 - 征服者和主宰
			数组(6, 9),
			数组(6, 10),

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰

			// 顾北酒笙 (索引4)
			数组(4, 9),   // 征服者
			数组(4, 10),  // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 雨鸢 (索引24)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10) // 主宰
		);
	}
}

规则("map - hollywood")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(好莱坞) || 全局.__currentMap__ == 1505) == 真;
	}

	动作
	{
		全局.bastionPosition = 数组(矢量(-20.813, 9.795, -128.879), 矢量(-6.517, 15.305, -105.981), 矢量(-14.730, 6.027, -67.670), 矢量(4.162, 11.155,
		-39.796), 矢量(-15.818, 5.751, -7.412), 矢量(-1.715, 2.332, 10.867), 矢量(-31.241, 4.840, 49.397), 矢量(25.884, 7.646, -68.660));
		全局.endPosition = 矢量(-48.89,-0.15,53.12);
		全局.thirdPersonPosition = 矢量(-27.291, 3.920, -156.654);
		全局.resetPosition = 矢量(-23.640, 3.920, -157.440);
		全局.creditsPosition = 矢量(-31.650, 8.960, -175.050);
		开始强制重生室(队伍1, 2);
		全局.__currentMapText__ = 自定义字符串("好莱坞");
		全局.__currentMapPioneerText__ = 全局.__currentMapText__;
		全局.mapTitleRelation = 数组(


			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 雨鸢 (索引19)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰

			// 糯米进脑子 (索引29)
			数组(29, 9),  // 征服者
			数组(29, 10), // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10) // 主宰
		);
	}
}

规则("map - horizon lunar colony")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(“地平线”月球基地);
	}

	动作
	{
		全局.bastionPosition[0] = 矢量(-15.287, 6, -127.244);
		全局.bastionPosition[1] = 矢量(16.250, 11.860, -106.756);
		// 全局.bastionPosition[2] = 矢量(64.269, 16, -74.726);
		全局.bastionPosition[2] = 矢量(62.52, 14, -77.970);
		"Fixed by 他又"
		全局.bastionPosition[3] = 矢量(33.140, 13.03, -43.680);
		全局.bastionPosition[4] = 矢量(19.496, 9, -1.439);
		全局.bastionPosition[5] = 矢量(66.687, 8.520, -37.241);
		全局.endPosition = 矢量(34.476, 12, -23.518);
		全局.thirdPersonPosition = 矢量(-41.390, 5, -159.030);
		全局.resetPosition = 矢量(-45.620, 5, -156.870);
		全局.creditsPosition = 矢量(-55.870, 7.680, -171.970);
		开始强制重生室(队伍1, 0);
		全局.__currentMapText__ = 自定义字符串("月球基地");
		全局.__currentMapPioneerText__ = 全局.__currentMapText__;
		全局.mapTitleRelation = 数组(
			// 烛台与南九 (索引3)
			数组(3, 9),   // 征服者
			数组(3, 10),  // 主宰

			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰

			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰

			// 顾北酒笙 (索引4)
			数组(4, 9),   // 征服者

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10), // 主宰

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 雨鸢 (索引24)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10)  // 主宰
		);
	}
}

规则("map - junkerto﻿wn")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(渣客镇);
	}

	动作
	{
		// 全局.bastionPosition = 矢量(-96.235, 13.672, -136.725);
		全局.bastionPosition = 矢量(-101.37, 12.72, -135.27);
		修改全局变量(bastionPosition, 添加至数组, 矢量(-72.634, 6.669, -145.321));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-27.431, 13.480, -100.155));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-57.67, 13.98, -92.45));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-27.85, 14.52, -97.33));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-25.34, 8.29, -36.47));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-2.080, 11.366, -61.807));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-5.660, 14.63, -74.46));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(30.116, 13.407, -59.880));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(29.97, 16.37, -91.860));
		修改全局变量(bastionPosition, 添加至数组, 矢量(32.15, 15.16, -89.130));
		全局.endPosition = 矢量(30.248, 5.515, -81.733);
		全局.thirdPersonPosition = 矢量(-88.030, 11.220, -88);
		全局.resetPosition = 矢量(-103.910, 11.690, -86.600);
		全局.creditsPosition = 矢量(-92.710, 14.040, -73.790);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(
			// WildRage (索引5)
			数组(5, 9),   // 征服者
			数组(5, 10),  // 主宰
			
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰

			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰
			
			// 看啊情 (索引17)
			数组(17, 9),  // 征服者
			数组(17, 10)  // 主宰
		);
	}
}

规则("map - king's row")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(国王大道) || 全局.__currentMap__ == 742) == 真;
	}

	动作
	{
		全局.bastionPosition = 矢量(-143.900, 7.130, 10.150);
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-120.990, 1.070, -12.080));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-116.440, 6.130, 5.72));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-103.120, 6.930, -4.02));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-91.380, 1.140, -27.900));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-91.990, 7.50, -28.630));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-55.460, -0.200, -29.830));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-66.62, 4.500, -35.930));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-29.170, 2.55, -31.430));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(5.980, 6.110, -30.350));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-21.560, 2.580, -8.160));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-10.67, 16.970, 5.65));
		全局.endPosition = 矢量(-1.900, 5, -0.290);
		全局.thirdPersonPosition = 矢量(-176.048, -0.070, 36.540);
		全局.resetPosition = 矢量(-175.230, -0.070, 43.030);
		全局.creditsPosition = 矢量(-185.560, 3.530, 38.320);
		全局.__currentMapText__ = 自定义字符串("国王大道");
		全局.__currentMapPioneerText__ = 全局.__currentMapText__;
		开始强制重生室(队伍1, 1);
		全局.mapTitleRelation = 数组(
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰

			// 吾携秋水揽星河 - 征服者和主宰
			数组(7, 9),
			数组(7, 10),
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10),  // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 雨鸢 (索引24)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰

			// EruIluvatar (索引28)
			数组(28, 9),  // 征服者
			数组(28, 10), // 主宰

			// 一痕沙 (索引32)
			数组(32, 9),  // 征服者

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10) // 主宰
		);
	}
}

规则("map - numbani")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(努巴尼);
	}

	动作
	{
		"Fixed by 他又"
		// 全局.bastionPosition[0] = 矢量(179.102, 4.250, 13.115);
		// 全局.bastionPosition[1] = 矢量(154.224, -4.180, 13.616);
		// 全局.bastionPosition[2] = 矢量(118.815, 4.250, 3.556);
		// 全局.bastionPosition[3] = 矢量(78.459, 6.250, -11.527);
		// 全局.bastionPosition[4] = 矢量(67.43, 6.25, 18.39);
		// 全局.bastionPosition[5] = 矢量(38.95, 5.50, 8.93);
		全局.bastionPosition = 数组(矢量(203.716, 0.209, -0.271), 矢量(151.942, 4.337, -5.450), 矢量(127.026, 2.250, 17.094), 矢量(123.932, -3.925,
		-10.396), 矢量(85.613, 6.250, 20.496), 矢量(87.894, 1.890, -3.300), 矢量(39.195, 5.496, 6.518), 矢量(32.850, 3.119, 34.634), 矢量(69.994,
		6.250, 15.541), 矢量(118.084, 4.250, 3.814));
		全局.endPosition = 矢量(23.00,3.12,39.72);
		全局.thirdPersonPosition = 矢量(225.74, 0.200, 4.550);
		全局.resetPosition = 矢量(224.54, 0.200, 0.390);
		全局.creditsPosition = 矢量(254.540, 3.200, 22.870);
		开始强制重生室(队伍1, 1);
		全局.mapTitleRelation = 数组(
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// EruIluvatar (索引28)
			数组(28, 9),  // 征服者
			数组(28, 10), // 主宰

			// 雨鸢 (索引24)
			数组(24, 9),  // 征服者
			数组(24, 10) // 主宰
		);
	}
}

规则("map - paraiso")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(帕拉伊苏);
	}

	动作
	{
		全局.bastionPosition = 矢量(-47.030, 6.860, -141.730);
		修改全局变量(bastionPosition, 添加至数组, 矢量(5.220, 12, -122));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-5.81, 10.000, -88.750));
		修改全局变量(bastionPosition, 添加至数组, 矢量(10.080, 3.900, -56.920));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(3.130, 11.160, -62.560));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-23.510, 10.110, -48.500));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-13.620, 8.220, -44.110));
		修改全局变量(bastionPosition, 添加至数组, 矢量(11.420, 5.100, -24.260));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-6.880, 0.500, 26.090));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(4.780, 0.97, 13.330));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-40.630, 3.000, 40.010));
		// 全局.endPosition = 矢量(-30.920, 3.300, 21.460);
		全局.endPosition = 矢量(-39.540, -2.000, 62.860);
		全局.thirdPersonPosition = 矢量(-78.250, 6.330, -167.960);
		全局.resetPosition = 矢量(-78.300, 5.030, -170.800);
		全局.creditsPosition = 矢量(-70.200, 7.750, -183.140);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			
			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10),  // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 雨鸢 (索引24)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰

			// EruIluvatar (索引28)
			数组(28, 9),  // 征服者
			数组(28, 10), // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10) // 主宰
		);
	}
}

规则("map - paris")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(巴黎);
	}

	动作
	{
		"made by 芋泥玛奇朵"
		全局.bastionPosition = 矢量(-95.984, 13.454, -83.535);
		修改全局变量(bastionPosition, 添加至数组, 矢量(-72.132, 11.976, -44.042));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-42.867, 18.510, -12.093));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-30.230, 10.020, 3.280));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-14.721, 14.250, -35.219));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-2.715, 10.080, -52.081));
		全局.endPosition = 矢量(9.563, 8.329, -59.980);
		全局.thirdPersonPosition = 矢量(-109.263, 15.300, -111.151);
		全局.resetPosition = 矢量(-115.030, 15.970, -122.820);
		全局.creditsPosition = 矢量(-119.740, 19, -132.450);
		开始强制重生室(队伍1, 1);
		全局.mapTitleRelation = 数组(
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10),

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰
			
			// 叽里咕噜说什么呢 (索引21)
			数组(21, 9),  // 征服者
			数组(21, 10)  // 主宰
		);
	}
}

规则("map - rialto")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(里阿尔托);
	}

	动作
	{
		开始强制重生室(队伍1, 2);
		"图外重生点"
		// 全局.controlRespawnPosition = 空数组;
		全局.controlRespawnPosition = 矢量(-52.36,3.83,-176.36);
		修改全局变量(controlRespawnPosition,  添加至数组, 矢量(53.17,1.25,22.99));
		全局.bastionPosition =  矢量(-64.421, 5.040, -125.927);
		修改全局变量(bastionPosition, 添加至数组, 矢量(-16.976, 1.660, -38.459));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-36.002, 4.750, -77.344));
		修改全局变量(bastionPosition, 添加至数组, 矢量(59.058, 0.070, -8.103));
		修改全局变量(bastionPosition, 添加至数组, 矢量(54.797, 1.740, -59.938));
		修改全局变量(bastionPosition, 添加至数组, 矢量(87.874, -0.370, 0.268));
		"高塔"
		修改全局变量(bastionPosition, 添加至数组, 矢量(60.53,50.43,61.63));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-13.12,4.75,47.31));
		修改全局变量(bastionPosition, 添加至数组, 矢量(27.18,4.75,36.89));
		修改全局变量(bastionPosition, 添加至数组, 矢量(20.90,0.75,54.61));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-19.85,10.75,8.80));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-19.85,10.75,11.92));
		全局.controlJumpPosition = 矢量(98.662, -1.500, -21.009);
		全局.endPosition = 矢量(-12.27, -1.250, -14.73);
		全局.thirdPersonPosition = 矢量(-54.920, 3.750, -158.320);
		全局.resetPosition = 矢量(-59.050, 3.750, -158.410);
		全局.creditsPosition = 矢量(-57.060, 5.250, -181.510);
		全局.mapTitleRelation = 数组(
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			
			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰
			
			// 草艮 (索引2)
			数组(2, 9),   // 征服者
			数组(2, 10),  // 主宰
			数组(2, 0),   // 开拓者
			
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰
			数组(10, 0),  // 开拓者

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 雨鸢 (索引24)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰

			// EruIluvatar (索引28)
			数组(28, 9),  // 征服者
			数组(28, 10), // 主宰

			// 糯米进脑子 (索引29)
			数组(29, 9),  // 征服者
			数组(29, 10), // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			数组(8, 0),   // 开拓者
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			数组(9, 0)    // 开拓者
		);
	}
}

规则("map - route 66")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(66号公路);
	}

	动作
	{
		全局.bastionPosition[0] = 矢量(-95.624, 12.660, -5.541);
		// 全局.bastionPosition[1] = 矢量(-38.680, 12.750, -22.136);
		全局.bastionPosition[1] = 矢量(-61.870, 10.87, 5.36);
		// 全局.bastionPosition[2] = 矢量(-15.784, 8.540, -12.685);
		// 全局.bastionPosition[2] = 矢量(-20.44, 12.170, -15.13);
		全局.bastionPosition[2] = 矢量(-38.680, 12.750, -22.136);
		// 全局.bastionPosition[3] = 矢量(36.467, 2.140, -4.003);
		全局.bastionPosition[3] = 矢量(-20.44, 12.170, -15.13);
		// 全局.bastionPosition[4] = 矢量(48.707, 10.110, 25.063);
		全局.bastionPosition[4] = 矢量(26.871, 7.010, 2.468);
		全局.bastionPosition[5] = 矢量(53.82, 12.860, 10.55);
		// 全局.bastionPosition[6] = 矢量(37.23, 12.470, 55.15);
		全局.bastionPosition[6] = 矢量(33.75, 5.540, 48.50);
		全局.endPosition = 矢量(47.956, 5.200, 47.318);
		全局.thirdPersonPosition = 矢量(-115.228, 5.799, -49.590);
		全局.resetPosition = 矢量(-115.010, 4.500, -46.010);
		全局.creditsPosition = 矢量(-113.270, 7.500, -63.140);
		开始强制重生室(队伍1, 1);
		全局.mapTitleRelation = 数组(
			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10),  // 主宰
			
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰
			
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰

			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰

			// 雨鸢 (索引24)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10)   // 主宰
		);
	}
}

规则("map - shambali monastery")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(香巴里寺院);
	}

	动作
	{
		全局.__currentMapText__ = 自定义字符串("香巴佬寺院");
		全局.__currentMapPioneerText__ = 全局.__currentMapText__;
		全局.bastionPosition = 数组(矢量(-16.139, 40.508, 181.288), 矢量(-44.290, 40.509, 203.816), 矢量(-13.976, 29.775, 143.323), 矢量(-50.623,27.354, 113.051), 矢量(-10.115, 37.040, 130.901), 矢量(-4.849, 14, 61.562), 矢量(-16.627, 9.917, 13.463), 矢量(16.270, 20.587, 99.534),矢量(-38.962, 16.615, 69.858), 矢量(26.033, 9.149, 19.823), 矢量(-9.824, 8.001, -21.875));
		全局.endPosition = 矢量(-19.43,8.00,-22.02);
		全局.thirdPersonPosition = 矢量(-7.690, 31.070, 226.970);
		全局.resetPosition = 矢量(-1.970, 31.070, 221.850);
		全局.creditsPosition = 矢量(1.750, 35, 232.500);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(
			数组(0, 0),
			数组(1, 0),

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 雨鸢 (索引24)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰

			// EruIluvatar (索引28)
			数组(28, 9),  // 征服者
			数组(28, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10) // 主宰
		);
	}
}

规则("map - temple of anubis")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(阿努比斯神殿);
	}

	动作
	{
		全局.bastionPosition = 矢量(-17.188, 11.237, 105.646);
		修改全局变量(bastionPosition, 添加至数组, 矢量(-3.470, 20.350, 97.610));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-4.690, 22.570, 79.470));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-37.620, 1.910, 47.850));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-25.200, 1.070, 25.160));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-37.500, 16.800, -4.790));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-0.350, 17.870, -24.210));
		全局.endPosition = 矢量(-7.020, -0.660, -36.430);
		全局.springBoardPosition = 矢量(-47.93, 1.50, 51.33);
		全局.thirdPersonPosition = 矢量(-7.969, 4.701, 137.390);
		全局.resetPosition = 矢量(-17.160, 4.460, 137.760);
		全局.creditsPosition = 矢量(-11.300, 7.350, 149.110);
		开始强制重生室(队伍1, 1);
		全局.mapTitleRelation = 数组(
			// 豆本豆豆奶 (索引10)
			数组(10, 0),  // 开拓者
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			
			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰
			数组(12, 0),  // 开拓者

			// 尘风歌者 - 征服者和主宰
			数组(6, 9),
			数组(6, 10),
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 0),   // 开拓者
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			
			// Cold (索引9)
			数组(9, 0),   // 开拓者
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			
			// 看啊情 (索引17)
			数组(17, 9),  // 征服者
			数组(17, 0),  // 开拓者

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 雨鸢 (索引24)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰

			// EruIluvatar (索引28)
			数组(28, 9),  // 征服者
			数组(28, 10), // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),   // 征服者
			数组(13, 10) // 主宰
		);
	}
}

规则("map - volskaya industries")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(沃斯卡娅工业区);
	}

	动作
	{
		// 全局.bastionPosition = 矢量(-87.972, 2.020, 38.919);
		// // 全局.bastionPosition = 矢量(-94.73, -0.730, 49.07);
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-67.835, 10.390, 49.479));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-63.809, -0.410, 77.730));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-11.250, 1.270, 76.356));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-16.279, 2.200, 41.017));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-6.364, 8.240, 35.514));
		全局.bastionPosition = 数组(矢量(-72.477, 16.869, 47.820), 矢量(-68.159, 2.020, 82.854), 矢量(-29.458, 2.097, 77.543), 矢量(-39.212, -2.064,
		80.626),  矢量(-82.963, -0.157, 22.991), 矢量(-13.924, -2.980, 117.617), 矢量(-28.688, 2.803, 35.540), 矢量(-38.633, -1.459, 38.463));
		// 全局.endPosition = 矢量(-11.477, -6, 19.868);
		全局.endPosition = 矢量(-40.94,2.95,38.35);
		全局.thirdPersonPosition = 矢量(-113.051, -1.980, 31.996);
		全局.resetPosition = 矢量(-115.180, -1.980, 35.240);
		全局.creditsPosition = 矢量(-128.250, 0.500, 24.750);
		开始强制重生室(队伍1, 0);
		全局.__currentMapText__ = 自定义字符串("沃斯卡娅");
		全局.__currentMapPioneerText__ = 全局.__currentMapText__;
		全局.mapTitleRelation = 数组(

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			数组(7, 0),   // 开拓者
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			数组(8, 0),   // 开拓者

			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10),  // 主宰
			数组(13, 0),   // 开拓者

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰
			数组(18, 0)   // 开拓者
		);
	}
}

规则("map - watchpoint gibraltar")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(监测站：直布罗陀);
	}

	动作
	{
		全局.__currentMapText__ = 自定义字符串("直布罗陀");
		全局.__currentMapPioneerText__ = 全局.__currentMapText__;
		全局.bastionPosition[0] = 矢量(70.099, 9, 26.803);
		全局.bastionPosition[1] = 矢量(81.759, 6, 3.200);
		全局.bastionPosition[2] = 矢量(64.465, 9.690, -32.138);
		全局.bastionPosition[3] = 矢量(32.373, 3, -50.866);
		全局.bastionPosition[4] = 矢量(31.113, 7.300, -89.871);
		// 全局.bastionPosition[5] = 矢量(41.383, 4, -124.788);
		全局.bastionPosition[5] = 矢量(56.88, 9.23, -118.92);
		全局.bastionPosition[6] = 矢量(19.43, 6, -131.05);
		// 全局.endPosition = 矢量(46.558, 1, -146.808);
		全局.endPosition = 矢量(15.70, -2.00, -134.65);
		全局.thirdPersonPosition = 矢量(93.88, 1.060, 63.17);
		全局.resetPosition = 矢量(97.55, 1.060, 60.380);
		全局.creditsPosition = 矢量(112.23, 0, 73.590);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			
			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰
			
			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10) // 主宰
		);
	}
}

规则("map - 中城")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(中城);
	}

	动作
	{
		"Made by 他又 芋泥玛奇朵\n"
		全局.bastionPosition = 数组(矢量(59.170, 9.847, -6.159), 矢量(118.361, 5.867, -78.645), 矢量(133.892, 5.637, -53.775), 矢量(92.256, 8.438,
		-22.921), 矢量(77.010, 13.219, -20.601), 矢量(43.662, 8.805, 12.811), 矢量(59.729, 9.199, 38.820), 矢量(7.768, 9.061, 44.804), 矢量(
		11.395, 9.676, 91.561), 矢量(-13.854, 9.931, 73.748));
		全局.endPosition = 矢量(12.91,3.75,127.69);
		全局.thirdPersonPosition = 矢量(133.91, 1.84, -104.94);
		全局.resetPosition = 矢量(119.51, 1.84, -104.94);
		全局.creditsPosition = 矢量(126.500, 3, -125.37);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(
			数组(7, 9), // 吾携秋水揽星河-征服者
            数组(7, 10), // 吾携秋水揽星河-主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10), // 主宰

			// 雨鸢 (索引24)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰

			// EruIluvatar (索引28)
			数组(28, 9),  // 征服者
			数组(28, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10) // 主宰

		);
	}
}

规则("map - 埃斯佩兰萨")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(埃斯佩兰萨) || 全局.__currentMap__ == 276) == 真;
	}

	动作
	{
		"Made by 他又 芋泥玛奇朵"
		全局.bastionPosition = 数组(矢量(86.815, -0.268, -54.406), 矢量(63.789, 1, -57.796), 矢量(14.121, 3.261, -42.146), 矢量(1.238, 7.966, 13.923),
			矢量(0.025, -0.002, -33.787), 矢量(-15.80, 3.08, -39.10), 矢量(-45.384, -1.583, -60.618), 矢量(60.250, -6, -93.538), 矢量(-26.245, 0,
			-80.277), 矢量(-108.094, -1.002, -60.285), 矢量(-71.269, 1.050, -49.368), 矢量(0.047, -2, -69.042));
		全局.endPosition = 矢量(-117.370, -3, -45.650);
		全局.springBoardPosition = 矢量(-73.720, -3, -34.190);
		全局.thirdPersonPosition = 矢量(126.70, -1.64, -90.03);
		全局.resetPosition = 矢量(126.70, -1.640, -81.42);
		全局.creditsPosition = 矢量(116.67, -0.29, -82.29);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			数组(8, 0),   // 开拓者
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			数组(9, 0),   // 开拓者

			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰
			数组(10, 0),   // 开拓者

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰
			数组(18, 0),   // 开拓者

			// WildRage (索引5)
			数组(5, 9),   // 征服者
			数组(5, 10),  // 主宰
			数组(5, 0),   // 开拓者

			// 尘风歌者 - 征服者和主宰
			数组(6, 9),
			数组(6, 10),
			数组(6, 0),   // 开拓者

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 雨鸢 (索引24)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰
			数组(12, 0)   // 开拓者
		);
	}
}

规则("map - 斗兽场")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(斗兽场) || 全局.__currentMap__ == 2147) == 真;
	}

	动作
	{
		"Made by 他又 芋泥玛奇朵"
		全局.bastionPosition = 矢量(60.94, 12.50, -13.78);
		// 全局.bastionPosition[1] = 矢量(-3.42, 20, -2.19);
		修改全局变量(bastionPosition, 添加至数组, 矢量(30.54, 5.09, 6.64));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-3.42, 20, -2.19));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-7.85, 20, -29.95));
		// 全局.bastionPosition[3] = 矢量(5.43, 0.99, 19.65);
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-54.52, 12.46, -10.10));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-21.18, 5.10, 1.35));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-21.88, 7.49, -3.00));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-54.52, 12.46, -10.10));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-9.98, 5.00, -39.50));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-55.02, 9.77, -22.14));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-60.93, 12.21, -11.91));
		"终点"
		修改全局变量(bastionPosition, 添加至数组, 矢量(-88.63, 13.77, -23.49));
		// "终点右侧出生点门口"
		// 全局.bastionPosition[5] = 矢量(-107.57, -1.00, -62.15);
		全局.endPosition = 矢量(-90.31, 9.00, -33.55);
		全局.thirdPersonPosition = 矢量(117.38, 9.00, -38.98);
		全局.resetPosition = 矢量(111.17, 9.00, -50.91);
		全局.creditsPosition = 矢量(117.64, 13.00, -48.66);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(
			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10),  // 主宰
			
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			数组(9, 0),   // 开拓者

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 雨鸢 (索引19)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰
			
			// 豆本豆豆奶 (索引10)
			数组(10, 10), // 主宰
			数组(10, 0)   // 开拓者
		);
	}
}

规则("map - 鲁纳塞彼")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(鲁纳塞彼) || 全局.__currentMap__ == 8048) == 真;
	}

	动作
	{
		"made by 他又"
		// 全局.bastionPosition = 矢量(70.22, 14.62, 36.56);
		全局.bastionPosition = 矢量(70.39, 7.86, 24.73);
		修改全局变量(bastionPosition, 添加至数组, 矢量(40.80, 4.01, 5.96));
		修改全局变量(bastionPosition, 添加至数组, 矢量(61.26, 5.99, -16.04));
		修改全局变量(bastionPosition, 添加至数组, 矢量(0.08, 8.340, 83.49));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-25.99, 1.21, 15.51));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-43.32, 4.00, 36.50));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-71.28, 14.62, 38.58));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-93.05, 7.06, 18.11));
		全局.endPosition = 矢量(-106.93, 7.99, 22.24);
		全局.thirdPersonPosition = 矢量(113.31, 7.09, -3.50);
		全局.resetPosition = 矢量(111.34, 7.09, -5.60);
		全局.creditsPosition = 矢量(124.60, 8.77, -15.99);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),   // 主宰

			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10) // 主宰
		);
	}
}

规则("map - 新皇后街")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(新皇后街);
	}

	动作
	{
		"made by 他又"
		全局.bastionPosition = 数组(矢量(-74.922, 14.194, -16.661), 矢量(-25.688, 4, -22.819), 矢量(-29.72, 7.12, -6.68), 矢量(-7.696, 4.850,
		35.246), 矢量(-0.035, 2.376, -11.505), 矢量(19.183, 1.477, -27.407), 矢量(15.862, 5.063, -12.591), 矢量(39.340, 8.100, -12.938), 矢量(
		51.915, 10, -17.308));
		// 全局.bastionPosition[0] = 矢量(-67.05, 11.20, -24.36);
		// // 全局.bastionPosition[1] = 矢量(-28.02, 3.27, -56.15);
		// 全局.bastionPosition[1] = 矢量(-30.62, 3.30, -39.39);
		// 全局.bastionPosition[2] = 矢量(-16.30, 4.06, 14.83);
		// 全局.bastionPosition[3] = 矢量(16.15, 4.06, 15.19);
		// 全局.bastionPosition[4] = 矢量(43.48, 10.00, -20.22);
		// // 全局.bastionPosition[5] = 矢量(86.84, 11.00, -6.84);
		// 全局.bastionPosition[5] = 矢量(74.74, 10.13, -39.00);
		全局.endPosition = 矢量(90.00, 11.00, -45.90);
		全局.thirdPersonPosition = 矢量(-111.26, 11.00, -32.03);
		全局.resetPosition = 矢量(-111.170, 11.00, -17.00);
		全局.creditsPosition = 矢量(-102.08, 17.29, -24.46);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(		
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			数组(8, 0),   // 开拓者

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰
			数组(12, 0),   // 开拓者

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10),  // 主宰

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),   // 主宰
			数组(7, 0),   // 开拓者

			// // 白银之鹰 (索引22)
			// 数组(22, 9),  // 征服者
			// 数组(22, 10)  // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 雨鸢 (索引24)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰
			数组(18, 0)   // 开拓者
		);
	}
}

规则("map - 皇家赛道")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(皇家赛道);
	}

	动作
	{
		"Made by 他又 芋泥玛奇朵"
		全局.bastionPosition = 数组(矢量(97.763, 15.967,29.045), 矢量(64.607, 19.071, 23.437), 矢量(61.918, 17.956, 15.709), 矢量(88.977, 14.931, -25.352), 矢量(59.133, 29.301, -30.146), 矢量(13.16,16.52,-44.31), 矢量(10.33,6,5.54), 矢量(-23.15,7.58,19.14),  矢量(-15.61, 13, -45.26), 矢量(-40.60, 4.25, -35.79),矢量(-67.822, 6.067, -43.245));
		全局.endPosition = 矢量(-45.08,10,-13.37);
		全局.thirdPersonPosition = 矢量(135.08, 10.00, -3.31);
		全局.resetPosition = 矢量(129.68, 10.00, 0.04);
		全局.creditsPosition = 矢量(147.52, 11.50, -10.90);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(
			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			数组(0, 0),
			数组(1, 0)
		);
	}
}

规则("map - 花村")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(花村) || 全局.__currentMap__ == 1848 || 全局.__currentMap__ == 地图(圣诞节花村)) == 真;
	}

	动作
	{
		"Made by 他又 芋泥玛奇朵"
		// 全局.bastionPosition[0] = 矢量(-15.46, 9.68, -89.300);
		// 全局.bastionPosition[1] = 矢量(1.87, 5.00, -41.04);
		// 全局.bastionPosition[2] = 矢量(-6.95, 8.01, -10.86);
		// // 全局.bastionPosition[3] = 矢量(29.19, 10.49, -5.70);
		// 全局.bastionPosition[3] = 矢量(27.00, 0.00, -7.87);
		// // 全局.bastionPosition[4] = 矢量(28.79, 6.52, 9.47);
		// 全局.bastionPosition[4] = 矢量(34.66, 6.00, 16.47);
		// 全局.bastionPosition[5] = 矢量(63.63, 6.00, -11.98);
		// 全局.endPosition = 矢量(72.38, -1.96, -0.16);
		全局.bastionPosition = 矢量(-20.750, 9.210, -78.140);
		修改全局变量(bastionPosition, 添加至数组, 矢量(11.870, 7.210, -47.220));
		修改全局变量(bastionPosition, 添加至数组, 矢量(28.310, 10.470, 6.600));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-6.950, 8.010, -10.860));
		修改全局变量(bastionPosition, 添加至数组, 矢量(49.130, 14.560, 17.960));
		修改全局变量(bastionPosition, 添加至数组, 矢量(52.200, -1, -0.580));
		修改全局变量(bastionPosition, 添加至数组, 矢量(15.610, 11.980, 17.470));
		修改全局变量(bastionPosition, 添加至数组, 矢量(46.870, -0.160, -15.600));
		修改全局变量(bastionPosition, 添加至数组, 矢量(60.130, -1.040, -15.610));
		全局.endPosition = 矢量(51.700, -1.870, 25.910);
		全局.thirdPersonPosition = 矢量(-33.20, 1.00, -115.04);
		全局.resetPosition = 矢量(-46.98, 1.00, -101.54);
		全局.creditsPosition = 矢量(-48.10, 2.50, -116.08);
		全局.__currentMapText__ = 自定义字符串("花村");
		全局.__currentMapPioneerText__ = 全局.__currentMapText__;
		// 开始强制重生室(队伍1, 0);
		全局.mapTitleRelation = 数组(
			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10),

			// 吾携秋水揽星河 - 征服者和主宰
			数组(7, 9),
			数组(7, 10),
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			数组(9, 0),   // 开拓者
			
			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 0),  // 开拓者
			
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰
			数组(10, 0),  // 开拓者
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			数组(8, 0),   // 开拓者
			
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰
			数组(6, 0),   // 开拓者

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 雨鸢 (索引19)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰

			// 雨鸢 (索引19)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰
			
			// 看啊情 (索引17)
			数组(17, 9),  // 征服者
			数组(17, 10), // 主宰
			数组(17, 0)   // 开拓者
		);
	}
}

规则("map - 伊利奥斯")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(伊利奥斯);
	}

	动作
	{
		开始强制重生室(队伍1, 2);
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		"made by 他又\n深井"
		If(数量(范围内玩家(矢量(-152.014, -1.104, -93.120), 30, 队伍1, 关闭)) != 0);
			全局.bastionPosition[0] = 矢量(-173.701, -0.460, -71.552);
			全局.bastionPosition[1] = 矢量(-207.983, 5.460, -31.971);
			全局.bastionPosition[2] = 矢量(-222.539, 0.100, -30.825);
			全局.bastionPosition[3] = 矢量(-223.926, 5.560, -16.079);
			全局.bastionPosition[4] = 矢量(-245.721, 5.560, 5.190);
			全局.bastionPosition[6] = 矢量(-257.450, 2.850, 35.113);
			全局.endPosition = 矢量(-271.140, -3.585, 33.279) - 矢量(0, 2, 0);
			全局.resetPosition = 矢量(-160.308, -1.355, -91.403);
			全局.thirdPersonPosition = 矢量(-148.168, -1.504, -88.932);
			全局.creditsPosition = 矢量(-150.880, 0.200, -97.020);
		"废墟"
		Else If(数量(范围内玩家(矢量(131.609, 64.254, -159.135), 30, 队伍1, 关闭)) != 0);
			全局.bastionPosition[0] = 矢量(111.310, 68.780, -183.068);
			全局.bastionPosition[1] = 矢量(83.250, 67.650, -179.529);
			全局.bastionPosition[2] = 矢量(28.394, 61.390, -148.333);
			全局.bastionPosition[3] = 矢量(5.918, 60.370, -170.376);
			全局.bastionPosition[4] = 矢量(-26.800, 67.620, -178.826);
			全局.bastionPosition[5] = 矢量(-52.040, 65.390, -179.058);
			"Tower goal position"
			全局.endPosition = 矢量(-47.306, 60.370, -184.722) - 矢量(0, 2, 0);
			"Base coordinates for world game settings HUD"
			全局.resetPosition = 矢量(128.072, 63.254, -165.528);
			全局.thirdPersonPosition = 矢量(129.560, 62.450, -153.472);
			全局.creditsPosition = 矢量(137.540, 63.920, -158.900);
		"灯塔"
		Else If(数量(范围内玩家(矢量(322.692, -21.520, 42.832), 30, 队伍1, 关闭)) != 0);
			全局.bastionPosition[0] = 矢量(321.799, -17.290, 26.126);
			全局.bastionPosition[1] = 矢量(314.215, -16.350, -18.283);
			全局.bastionPosition[2] = 矢量(358.768, -6.597, -47.480);
			全局.bastionPosition[3] = 矢量(353.915, -10.860, -53.746);
			全局.bastionPosition[4] = 矢量(364.601, -25.620, -54.434);
			全局.bastionPosition[5] = 矢量(304.692, -15.910, -42.049);
			全局.bastionPosition[6] = 矢量(319.744, -24.110, -69.502);
			"Town goal position"
			全局.endPosition = 矢量(321.229, -23.291, -88.556) - 矢量(0, 3, 0);
			全局.thirdPersonPosition = 矢量(318.997, -21.520, 37.660);
			全局.resetPosition = 矢量(331.080, -21.520, 41.121);
			"Base coordinates for world game settings HUD"
			全局.creditsPosition = 矢量(321.800, -20, 46);
		End;
		全局.mapTitleRelation = 数组(
			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10), // 主宰

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰

			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰

			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰
			
			// 别打老顾我啊 (索引16)
			数组(16, 9),   // 征服者

			// 雨鸢 (索引19)
			数组(24, 9),  // 征服者
			数组(24, 10),

			// 蝎子莱莱 (索引23)
			数组(23, 9),  // 征服者
			数组(23, 10) // 主宰
		);
	}
}

规则("map - 漓江塔")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(漓江塔) || 全局.__currentMap__ == 3676) == 真;
	}

	动作
	{
		全局.__currentMapText__ = 自定义字符串("漓江塔");
		全局.__currentMapPioneerText__ = 全局.__currentMapText__;
		"0 = X轴 1 = Y轴 2 = Z轴"
		全局.controlRespawnAxis = 1;
		"距离阈值"
		全局.controlRespawnAxisThreshold = 40;
		开始强制重生室(队伍1, 2);
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);

		"夜市"
		全局.bastionPosition = 矢量(34.550, 33.850, -36.640); // 1
		修改全局变量(bastionPosition, 添加至数组, 矢量(21.250, 10, -23.950)); // 2
		修改全局变量(bastionPosition, 添加至数组, 矢量(0.93,0.00, -9.84)); // 3
		修改全局变量(bastionPosition, 添加至数组, 矢量(3.650, 8.010, -52.480)); // 4
		修改全局变量(bastionPosition, 添加至数组, 矢量(-30.810, 25.990, -14.770)); // 5

		"夜市重生点"
		全局.controlRespawnPosition = 矢量(84.410, 4.520, -31.57);

		"夜市-庭院 传送点"
		全局.controlJumpPosition = 矢量(-58.26, 6.00, -5.24);
		全局.resetPosition = 矢量(81.11, 4.580, -35.44);
		全局.thirdPersonPosition = 矢量(74.43, 4.46, -26.34);
		全局.creditsPosition = 矢量(84.29, 6.200, -29.44);

		"庭院"
		修改全局变量(bastionPosition, 添加至数组, 矢量(41.480, 95.870, 140.620)); // 6
		修改全局变量(bastionPosition, 添加至数组, 矢量(-0.080, 94, 184.970)); // 7
		修改全局变量(bastionPosition, 添加至数组, 矢量(-16.66,96.50,120.91)); // 8
		修改全局变量(bastionPosition, 添加至数组, 矢量(-66.07,94,150.20)); // 9
		"庭院重生点"
		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(86.21, 96.620, 147.70)); // 10
		"庭院-控制中心 传送点"
		修改全局变量(controlJumpPosition, 添加至数组, 矢量(-51.89, 95.00, 133.97));
		"控制中心"
		修改全局变量(bastionPosition, 添加至数组, 矢量(46.340, 267, 300.860)); // 
		修改全局变量(bastionPosition, 添加至数组, 矢量(-10.14, 270.12, 321.40)); // 11
		修改全局变量(bastionPosition, 添加至数组, 矢量(-0.200, 278.010, 290.980)); // 13
		修改全局变量(bastionPosition, 添加至数组, 矢量(2.790, 274.190, 301.820)); // 14
		修改全局变量(bastionPosition, 添加至数组, 矢量(-46.630, 267.110, 300.970)); // 15
		"控制中心重生点"
		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(62.930, 267.64, 349.53));
		全局.endPosition = 矢量(-44.02, 271.64, 349.77);
		全局.mapTitleRelation = 数组(
			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10), // 主宰

			数组(15, 9),  // 征服者
			数组(15, 10), // 主宰

			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰
			
			// 草艮 (索引2)
			数组(2, 9),   // 征服者
			数组(2, 10),  // 主宰
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰
			
			// 烛台与南九 (索引3)
			数组(3, 9),   // 征服者
			数组(3, 10),  // 主宰
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// 看啊情 (索引17)
			数组(17, 9),  // 征服者
			数组(17, 10),  // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// EruIluvatar (索引28)
			数组(28, 9),  // 征服者
			数组(28, 10), // 主宰


			// 我心飞扬 (索引26)
			数组(26, 9),  // 征服者
			数组(26, 10) // 主宰
		);
	}
}

规则("map - 萨摩亚")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(萨摩亚) || 全局.__currentMap__ == 13628) == 真;
	}

	动作
	{
		"0 = X轴 1 = Y轴 2 = Z轴"
		全局.controlRespawnAxis = 0; // 重生点轴向 0 = X轴 1 = Y轴 2 = Z轴
		"距离阈值"
		全局.controlRespawnAxisThreshold = 40;
		开始强制重生室(队伍1, 2);
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		"海滩海滩重生点"
		全局.controlRespawnPosition = 矢量(-428, 10.500, -109);
		"海滩-城区 传送点"
		全局.controlJumpPosition = 矢量(-256.820, 14.850, -94.900);
		全局.resetPosition = 矢量(-430.710, 10.300, -105.960);
		全局.thirdPersonPosition = 矢量(-425.320, 10.230, -116.480);
		全局.creditsPosition = 矢量(-436.160, 12.200, -111.370);
		"城区城区重生点"
		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(330.120, 14.640, -216.310));
		"城区-控制中心 传送点"
		修改全局变量(controlJumpPosition, 添加至数组, 矢量(177.520, 12.300, -239.300));
		"火山火山重生点"
		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(107.830, 343, 415.600));
		全局.endPosition = 矢量(-29.300, 340.560, 410.760);
		"堡垒点位  沙滩"
		全局.bastionPosition = 矢量(-408.950, 14.400, -84.760);
		修改全局变量(bastionPosition, 添加至数组, 矢量(-384.050, 12.050, -86.880));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-330.080, 10.010, -98.040));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-276.430, 11.020, -89.160));
		"堡垒点位 城区"
		修改全局变量(bastionPosition, 添加至数组, 矢量(307.130, 18.610, -206.170));
		修改全局变量(bastionPosition, 添加至数组, 矢量(231.600, 16.280, -270.760));
		修改全局变量(bastionPosition, 添加至数组, 矢量(233.690, 9, -229.700));
		修改全局变量(bastionPosition, 添加至数组, 矢量(170.960, 12.560, -242.330));
		"堡垒点位 火山"
		修改全局变量(bastionPosition, 添加至数组, 矢量(97.680, 340.630, 397.230));
		修改全局变量(bastionPosition, 添加至数组, 矢量(46.640, 345.490, 387.040));
		修改全局变量(bastionPosition, 添加至数组, 矢量(26.690, 341.630, 376.430));
		修改全局变量(bastionPosition, 添加至数组, 矢量(27.740, 360.500, 356.070));
		修改全局变量(bastionPosition, 添加至数组, 矢量(0.960, 346.650, 390.110));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-4.400, 353.050, 407.420));
		全局.mapTitleRelation = 数组(

			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰
			
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰
			
			// 草艮 (索引2)
			数组(2, 9),   // 征服者
			数组(2, 10),  // 主宰
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10) // 主宰
		);
	}
}

// 规则("map - 南极半岛")
// {
// 	事件
// 	{
// 		持续 - 全局;
// 	}

// 	条件
// 	{
// 		全局.__currentMap__ == 地图(南极半岛);
// 	}

// 	动作
// 	{
// 		"0 = X轴 1 = Y轴 2 = Z轴"
// 		全局.controlRespawnAxis = 1;
// 		"距离阈值"
// 		全局.controlRespawnAxisThreshold = 40;
// 		开始强制重生室(队伍1, 2);
// 		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
// 		"冰下层重生点"
// 		全局.controlRespawnPosition = 矢量(-76.020, -151.440, 153.130);
// 		"冰下层-破冰船 传送点"
// 		全局.controlJumpPosition = 矢量(-59.560, -151.500, -17.690);
// 		全局.resetPosition = 矢量(-75.850, -151.440, 147.300);
// 		全局.thirdPersonPosition = 矢量(-79.930, -151.440, 147.280);
// 		全局.creditsPosition = 矢量(-78.770, -148.440, 160.860);
// 		"破冰船重生点"
// 		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(182.660, -9.700, -234.070));
// 		"破冰船-研究中心  传送点"
// 		修改全局变量(controlJumpPosition, 添加至数组, 矢量(343.060, -9.100, -209.650));
// 		"研究中心重生点"
// 		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(369.700, 45.730, 169.340));
// 		全局.endPosition = 矢量(205.410, 48.090, 165.140);
// 		"堡垒点位  冰下层"
// 		全局.bastionPosition = 矢量(-72.040, -151.410, 119.550);
// 		修改全局变量(bastionPosition, 添加至数组, 矢量(-92.090, -151.170, 80.660));
// 		修改全局变量(bastionPosition, 添加至数组, 矢量(-58.390, -147.630, 42.630));
// 		修改全局变量(bastionPosition, 添加至数组, 矢量(-88.010, -143.330, -19.630));
// 		"堡垒点位 破冰船"
// 		修改全局变量(bastionPosition, 添加至数组, 矢量(231.060, -7.680, -232.480));
// 		修改全局变量(bastionPosition, 添加至数组, 矢量(281.410, -10.010, -196.390));
// 		修改全局变量(bastionPosition, 添加至数组, 矢量(282.200, -8.310, -247.910));
// 		修改全局变量(bastionPosition, 添加至数组, 矢量(314.780, -14, -262.470));
// 		修改全局变量(bastionPosition, 添加至数组, 矢量(320.920, -8.930, -216.010));
// 		修改全局变量(bastionPosition, 添加至数组, 矢量(330.850, -10.940, -249.670));
// 		"堡垒点位  研究中心"
// 		修改全局变量(bastionPosition, 添加至数组, 矢量(326.200, 51.510, 165.800));
// 		修改全局变量(bastionPosition, 添加至数组, 矢量(269.850, 44.150, 156.600));
// 		修改全局变量(bastionPosition, 添加至数组, 矢量(209.610, 52.190, 181.940));
// 		修改全局变量(bastionPosition, 添加至数组, 矢量(269.900, 47.010, 187.600));
// 		全局.controlCenterPosition = 数组(矢量(-77.850, -154.430, 59.980), 矢量(283.400, -12.750, -223.320), 矢量(270.290, 39.780, 160.080));
// 		全局.mapTitleRelation = 数组(
// 			
// 		);
// 	}
// }

规则("map - 釜山")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(釜山);
	}

	动作
	{
		"0 = X轴 1 = Y轴 2 = Z轴"
		全局.controlRespawnAxis = 0;
		"距离阈值"
		全局.controlRespawnAxisThreshold = 40;
		开始强制重生室(队伍1, 2);
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		"寺庙重生点"
		全局.controlRespawnPosition = 矢量(-426.040, 11.110, 165.810);
		"寺庙-城区 传送点"
		全局.controlJumpPosition = 矢量(-248.550, 10.350, 152.770);
		全局.resetPosition = 矢量(-409.710, 10.110, 165.610);
		全局.thirdPersonPosition = 矢量(-410.400, 10.110, 162.370);
		全局.creditsPosition = 矢量(-426.040, 13.110, 165.810);
		"城区城区重生点"
		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(-30.950, 17, -125.550));
		"城区-meka基地 传送点"
		修改全局变量(controlJumpPosition, 添加至数组, 矢量(104.770, 17.740, -137.210));
		"meka基地重生点"
		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(291.620, 11.090, 208.250));
		全局.endPosition = 矢量(158.670, 10.810, 260.910);
		"堡垒点位  寺院"
		全局.bastionPosition = 矢量(-327.440, 17.730, 166.800);
		修改全局变量(bastionPosition, 添加至数组, 矢量(-328.510, 15.080, 140.810));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-277.400, 11.130, 144.400));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-379.430, 11.130, 144.410));
		"堡垒点位 城区"
		修改全局变量(bastionPosition, 添加至数组, 矢量(22.020, 13.860, -121.160));
		修改全局变量(bastionPosition, 添加至数组, 矢量(51.840, 13.480, -97.400));
		修改全局变量(bastionPosition, 添加至数组, 矢量(80.670, 20, -106.930));
		修改全局变量(bastionPosition, 添加至数组, 矢量(111.430, 18.540, -169.790));
		"堡垒点位  meka基地"
		修改全局变量(bastionPosition, 添加至数组, 矢量(268.370, 15.090, 205.620));
		修改全局变量(bastionPosition, 添加至数组, 矢量(249.270, 14.290, 236.100));
		修改全局变量(bastionPosition, 添加至数组, 矢量(228.220, 10.090, 231.080));
		修改全局变量(bastionPosition, 添加至数组, 矢量(200.310, 19.430, 223.760));
		修改全局变量(bastionPosition, 添加至数组, 矢量(177.100, 9.690, 253.190));
		修改全局变量(bastionPosition, 添加至数组, 矢量(173.930, 12.870, 267.780));
		全局.controlCenterPosition = 数组(矢量(-328.530, 8.170, 153.320), 矢量(51.890, 14.500, -114.700), 矢量(222.720, 9.240, 241.770));
		全局.mapTitleRelation = 数组(
			// 草艮 (索引2)
			数组(2, 0),   // 开拓者
			数组(2, 9),   // 征服者
			
			// 顾北酒笙 (索引4)
			数组(4, 0),   // 开拓者
			数组(4, 9),   // 征服者
			
			// WildRage (索引5)
			数组(5, 0),   // 开拓者
			数组(5, 9),   // 征服者
			
			// 尘风歌者 (索引6)
			数组(6, 0),   // 开拓者
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 0),   // 开拓者
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			
			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰
			
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10),  // 主宰

			// EruIluvatar (索引28)
			数组(28, 9),  // 征服者
			数组(28, 10), // 主宰

			// 糯米进脑子 (索引29)
			数组(29, 9),  // 征服者
			数组(29, 10), // 主宰

			// 半夜汽笛 (索引30)
			数组(30, 9),  // 征服者
			数组(30, 10), // 主宰

			// 雷个大憨憨 (索引31)
			数组(31, 9),  // 征服者
			数组(31, 10), // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10) // 主宰
		);
	}
}

规则("map - 绿洲城")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(绿洲城);
	}

	动作
	{
		"0 = X轴 1 = Y轴 2 = Z轴"
		全局.controlRespawnAxis = 2;
		"距离阈值"
		全局.controlRespawnAxisThreshold = 40;
		// "覆盖全局自动重开时间"
		// 全局.rebootTime = 15900;
		开始强制重生室(队伍1, 2);
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		"花园重生点"
		全局.controlRespawnPosition = 矢量(200.460, 6.420, -188.280);
		"花园-大学 传送点"
		全局.controlJumpPosition = 矢量(82.130, 5.490, -273.200);
		全局.resetPosition = 矢量(193.610, 8.420, -197.030);
		全局.thirdPersonPosition = 矢量(191.330, 8.420, -194.730);
		全局.creditsPosition = 矢量(204.410, 8.420, -184.710);
		"大学重生点"
		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(-195.030, 20, 89.710));
		"大学-中心  传送点"
		修改全局变量(controlJumpPosition, 添加至数组, 矢量(-175.400, 16, -61.350));
		"中心重生点"
		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(69.730, 1, 321.160));
		全局.endPosition = 矢量(195.130, 0.850, 172.870);
		"堡垒点位  花园"
		全局.bastionPosition = 矢量(170.700, 13.570, -216.170);
		修改全局变量(bastionPosition, 添加至数组, 矢量(123.600, 12, -229.920));
		修改全局变量(bastionPosition, 添加至数组, 矢量(78.920, 10, -253.170));
		修改全局变量(bastionPosition, 添加至数组, 矢量(111.340, 13.570, -278.410));
		"堡垒点位 大学"
		修改全局变量(bastionPosition, 添加至数组, 矢量(-196.790, 21.650, 56.690));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-202.910, 9.120, -0.100));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-177.500, 20.250, 0.190));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-183.170, 20.060, -61.790));
		"堡垒点位  中心"
		修改全局变量(bastionPosition, 添加至数组, 矢量(110.540, 2, 283.010));
		修改全局变量(bastionPosition, 添加至数组, 矢量(140.160, 10, 250.390));
		修改全局变量(bastionPosition, 添加至数组, 矢量(171.910, 4.120, 277));
		修改全局变量(bastionPosition, 添加至数组, 矢量(150.980, 3.850, 223.890));
		修改全局变量(bastionPosition, 添加至数组, 矢量(173.510, 2, 217.630));
		全局.controlCenterPosition = 数组(矢量(129.500, 15.280, -235.740), 矢量(-192.080, 15, 0.260), 矢量(143.440, 2.150, 247.950));
		全局.mapTitleRelation = 数组(
			// WildRage (索引5)
			数组(5, 9),   // 征服者
			数组(5, 10),  // 主宰

			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰
			数组(6, 0),   // 开拓者

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10),  // 主宰
			数组(10, 0),  // 开拓者

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 雨鸢 (索引24)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10) // 主宰
		);
	}
}

规则("map - 新渣客城")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(新渣客城) || 全局.__currentMap__ == 3099) == 真;
	}

	动作
	{
		全局.portalPosition = 数组(矢量(-91.45, 2, -5.21), 矢量(-118.06,30.58,-2.12));
		"0 = X轴 1 = Y轴 2 = Z轴"
		全局.controlRespawnAxis = 2;
		"距离阈值"
		全局.controlRespawnAxisThreshold = 30;
		开始强制重生室(队伍1, 1);
		全局.controlRespawnPosition = 矢量(-0.7, 8.02, 113.02);
		"大学重生点"
		修改全局变量(controlRespawnPosition, 添加至数组, 最后(全局.portalPosition));
		全局.resetPosition = 矢量(5.33,8.14,109.05);
		全局.thirdPersonPosition = 矢量(2.08,8.02,109.16);
		全局.creditsPosition = 矢量(0.68, 11.77, 120.02);
		全局.endPosition = 矢量(-43, 28.65, -39.96);
		全局.controlJumpPosition = 首个(全局.portalPosition);
		
		全局.bastionPosition = 数组(矢量(-45.678, 8.298, 88.433), 矢量(-74.958, 6.937, 72.937), 矢量(-76.296, 7.756, 40.010), 矢量(-74.877, 6.937,
		7.044), 矢量(-78.144, -0.941, -19.954), 矢量(-55.165, 8.251, -0.152), 矢量(-25.305, 9.706, 32.074), 矢量(13.116, 4.058, 87.188), 矢量(
		-15.766, 7.025, 0.028), 矢量(-31.324, 8.111, -39.913), 矢量(-85.606, 0.947, 44.387), 矢量(-74.415, 4.499, -63.359));

		全局.mapTitleRelation = 数组(
			// 吾携秋水揽星河 - 征服者和主宰
			数组(7, 9),
			数组(7, 10),
			数组(7, 0),  // 开拓者

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			数组(8, 0),  // 开拓者

			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰

			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10),  // 主宰

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰
			数组(12, 0),   // 开拓者

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 雨鸢 (索引24)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰

			// EruIluvatar (索引28)
			数组(28, 9),  // 征服者
			数组(28, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰
			数组(18, 0)   // 开拓者
		);
	}
}

规则("map - 尼泊尔")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(尼泊尔);
	}

	动作
	{
		全局.controlRespawnAxis = 1;
		"距离阈值"
		全局.controlRespawnAxisThreshold = 30;
		开始强制重生室(队伍1, 1);
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		全局.controlRespawnPosition = 矢量(-161.00,-95.97,-84.17);
		"大学重生点"
		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(-39.04,17.84,-99.75));
		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(85.52,132.49,-96.2));
		全局.resetPosition = 矢量(-165.40,-95.85,-88.15);
		全局.thirdPersonPosition = 矢量(-158.45,-95.97,-78.36);
		全局.creditsPosition = 矢量(-157.98, -90.95, -89.77);
		全局.endPosition = 矢量(103.15,132.00,52.57);
		全局.controlJumpPosition = 矢量(-148.56,-92.25,64.75);
		修改全局变量(controlJumpPosition, 添加至数组, 矢量(-21.67,21.00,81.47));
		
		全局.bastionPosition = 数组(矢量(-152.680, -92.115, -64.862), 矢量(-193.849, -89.578, -32.592), 矢量(-199.313, -94.457, 41.386), 矢量(
		-146.246, -88.751, 48.509), 矢量(-26.436, 22, -69.808), 矢量(-25.182, 13, 0.688), 矢量(-73.662, 19.545, 0.132), 矢量(-42.208, 20.025,
		51.770), 矢量(-187.057, -87.686, 7.868), 矢量(73.112, 129.717, -67.245), 矢量(94.679, 140.260, -17.696), 矢量(92.445, 141.370,
		49.176));

		全局.mapTitleRelation = 数组(
			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			数组(7, 0),   // 开拓者

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			数组(8, 0),   // 开拓者

			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰
			数组(10, 0),   // 开拓者

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰
			数组(12, 0),   // 开拓者

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10), // 主宰
			数组(13, 0)   // 开拓者
		);
	}
}

规则("map - 阿努比斯王座")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(阿努比斯王座) || 全局.__currentMap__ == 886) == 真;
	}

	动作
	{
		全局.__currentMapText__ = 自定义字符串("王座");
		全局.__currentMapPioneerText__ = 全局.__currentMapText__;

		全局.controlRespawnAxis = 2;
		"距离阈值"
		全局.controlRespawnAxisThreshold = 30;
		开始强制重生室(队伍1, 1);

		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		全局.controlRespawnPosition = 矢量(11.4,9.25,134.12);

		全局.resetPosition = 矢量(6.28,9.28,130.05);
		全局.thirdPersonPosition = 矢量(3.18,9.28,130.71);
		全局.creditsPosition = 矢量(-157.98, -90.95, -89.77);
		全局.endPosition = 矢量(-10.49,8.92,-125.57);

		全局.bastionPosition = 数组(矢量(-28.955, 6.079, 65.912), 矢量(23.873, 21.939, 104.507), 矢量(0.457, 10.482, 97.234), 矢量(-7.399, 7.583, 50.502), 矢量(-1.101, 1.051, 19.039), 矢量(11.358, 8.052, -15.668), 矢量(-25.866, 9.142, -44.072), 矢量(11.875, 7.904, -24.293), 矢量(-27.944, 5.780, -83.352), 矢量(-16.021, 5.815, -98.212));

		// 等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 20);
		// IF(Y方向分量(所选位置(重生点(队伍1))) < 0);
		// 	重新开始比赛;
		// END;

		全局.mapTitleRelation = 数组(
			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			数组(7, 0),   // 开拓者

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			数组(8, 0),   // 开拓者

			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰
			数组(10, 0),   // 开拓者

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰
			数组(19, 0),   // 开拓者

			// 雨鸢 (索引24)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰

			// Jargon (索引25)
			数组(25, 9),  // 征服者
			数组(25, 10), // 主宰
			数组(25, 0),   // 开拓者

			// EruIluvatar (索引28)
			数组(28, 9),  // 征服者
			数组(28, 10), // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10), // 主宰
			数组(13, 0)   // 开拓者
		);
	}
}

规则("map - 花冈")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 2601;
	}

	动作
	{
		全局.__currentMapText__ = 自定义字符串("花冈");
		全局.__currentMapPioneerText__ = 全局.__currentMapText__;

		全局.controlRespawnAxis = 2;
		"距离阈值"
		全局.controlRespawnAxisThreshold = 30;
		开始强制重生室(队伍1, 2);

		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		全局.controlRespawnPosition = 矢量(-7.69,44.25,-140.5);

		全局.resetPosition = 矢量(-9.08,44.05,-133.26);
		全局.thirdPersonPosition = 矢量(-0.64,44.05,-133.89);
		全局.creditsPosition = 矢量(-5.02, 50.05, -142.63);
		全局.endPosition = 矢量(20.36,39.83,112.51);

		全局.bastionPosition = 数组(矢量(-22.263, 46.024, -89.586), 矢量(-5.326, 42.977, -59.814), 矢量(6.729, 45.550, -48.776), 矢量(29.532,44.500, 7.090), 矢量(-2.847, 42.510, 7.305), 矢量(-17.813, 45.889, 63.611), 矢量(-21.392, 45.952, 103.426), 矢量(14.139, 41.045,99.842), 矢量(-12.338, 40.538, 39.810), 矢量(-17.161, 40.545, -19.673));

		// 等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 20);
		// IF(Y方向分量(所选位置(重生点(队伍1))) < 0);
		// 	重新开始比赛;
		// END;

		全局.mapTitleRelation = 数组(
			// 吾携秋水揽星河 - 征服者和主宰
			数组(7, 9),
			数组(7, 10),

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰
			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10), // 主宰
			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 雨鸢 (索引24)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰

			// EruIluvatar (索引28)
			数组(28, 9),  // 征服者
			数组(28, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10) // 主宰
		);
	}
}

规则("map - 苏拉瓦萨")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(苏拉瓦萨);
	}

	动作
	{
		// 全局.__currentMapText__ = 自定义字符串("瓦拉纳西");
		全局.__currentMapPioneerText__ = 自定义字符串("瓦拉纳西");
		全局.__currentPioneerText__ = 自定义字符串("守护者");
		// 全局.portalPosition = 数组(矢量(-2.43,4.13,0.75), 矢量(84.24,27.87,91.7));

		"0 = X轴 1 = Y轴 2 = Z轴"
		全局.controlRespawnAxis = 2;
		"距离阈值"
		全局.controlRespawnAxisThreshold = 50;

		开始强制重生室(队伍1, 1);
		全局.controlRespawnPosition = 矢量(-0.36,4,136.68);

		全局.bastionPosition = 数组(矢量(16.734, 10.500, 72.110), 矢量(-33.040, 4.174, 73.197), 矢量(-0.913, 5.250, 62.388), 矢量(24.538, 9.284,
		4.699), 矢量(23.629, 7.986, 36.324), 矢量(-63.158, 8.431, 13.990), 矢量(-20.737, 4.005, 18.929), 矢量(-2.818, 3.976, -36.071), 矢量(
		-20.587, 4.008, -19.155));

		全局.resetPosition = 矢量(-4.55,4,124.39);
		全局.thirdPersonPosition = 矢量(5.54,4,124.39);
		全局.creditsPosition = 矢量(0.68, 11.77, 120.02);
		全局.endPosition = 矢量(-2.43,4.13,0.75);

		全局.mapTitleRelation = 数组(
			数组(0, 0),
			数组(1, 0),

			// 吾携秋水揽星河 - 征服者和主宰
			数组(7, 0),
			数组(7, 9),
			数组(7, 10),

			// 寒霜冰湮 (索引8)
			数组(8, 0),
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰

			// 卖核弹的小女孩 - 征服者
			数组(13, 0),
			数组(13, 9),
			数组(13, 10),

			// 眼镜小宅 (索引18)
			数组(18, 0),
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 雨鸢 (索引24)
			数组(24, 0),
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰

			// Augenstern (索引33)
			数组(33, 9),  // 征服者
			数组(33, 10), // 主宰

			// 绿里奇迹 (索引27)
			数组(27, 0),
			数组(27, 9),  // 征服者
			数组(27, 10) // 主宰
		);
	}
}

规则("map - 阿育陀耶")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(阿育陀耶) || 全局.__currentMap__ == 1826) == 真;
	}

	动作
	{
		全局.rebootTime = 5400;
		全局.__currentMapPioneerText__ = 自定义字符串("大城");
		全局.__currentPioneerText__ = 自定义字符串("守护者");
		全局.bastionPosition = 数组(矢量(18.158, 1.217, -56.711), 矢量(17.999, 6.029, -30.873), 矢量(14.010, 3.189, -9.077), 矢量(34.905, 5.090,
		4.157), 矢量(4.540, 6.004, 26.420), 矢量(10.071, 1.931, 38.699));

		开始强制重生室(队伍1, 1);

		全局.resetPosition = 矢量(20.46,1,-104.03);
		全局.thirdPersonPosition = 矢量(15.45,1,-103.8);
		全局.creditsPosition = 矢量(17.69,9.22,-111.87);
		全局.endPosition = 矢量(16.12,1,66.52);

		全局.mapTitleRelation = 数组(
			数组(0, 0),
			数组(1, 0),

			// 吾携秋水揽星河 - 征服者和主宰
			数组(7, 9),
			数组(7, 10),

			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰

			// 卖核弹的小女孩 - 征服者
			数组(13, 9),
			数组(13, 10),

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// EruIluvatar (索引28)
			数组(28, 9),  // 征服者
			数组(28, 10), // 主宰

			// 寒霜冰湮 (索引8)
			// 数组(8, 0),
			数组(8, 9),   // 征服者
			数组(8, 10)  // 主宰
		);
	}
}

规则("map - 阿特利斯")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(阿特利斯) || 全局.__currentMap__ == 1826) == 真;
	}

	动作
	{
		全局.__currentMapPioneerText__ = 自定义字符串("织金");
		全局.__currentPioneerText__ = 自定义字符串("门徒");

		"0 = X轴 1 = Y轴 2 = Z轴"
		全局.controlRespawnAxis = 2;
		"距离阈值"
		全局.controlRespawnAxisThreshold = 60;

		开始强制重生室(队伍1, 1);
		全局.controlRespawnPosition = 矢量(4.85,15.5,104.6);

		// 全局.bastionPosition = 数组(矢量(-27.310, 30.462, 99.799), 矢量(-45.351, 15.454, 79.671), 矢量(-23.956, 16.004, 43.016), 矢量(-29.999, 17.009,17.751), 矢量(-87.158, 14.004, -21.012), 矢量(-70.585, 13.295, 39.948), 矢量(-21.061, 13.813, -64.931), 矢量(-45.813, 14.934, -79.517),矢量(4.542, 17.737, 61.038), 矢量(-4.835, 12.464, -0.137), 矢量(4.440, 17.737, -60.620), 矢量(-90.802, 14.002, -60.156));

		全局.resetPosition = 矢量(16.37,15,104.47);
		全局.thirdPersonPosition = 矢量(-6.21,15,104.33);
		全局.creditsPosition = 矢量(5.10, 19.5,105.79);
		全局.endPosition = 矢量(-78.02,9.19,-39.93);

		全局.mapTitleRelation = 数组(
			数组(0, 0),
			数组(1, 0)
		);
	}
}

规则("bastion init position, unkillable status, and damage dealt scaling with difficulty setting")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		存活(事件玩家) == 真;
		已重生(事件玩家) == 真;
	}

	动作
	{
		等待(0.250, 无视条件);
		设置造成伤害(事件玩家, 100 + 50 * 全局.difficulty);
		传送(事件玩家, 全局.bastionPosition[栏位(事件玩家)]);
		If(!具有状态(事件玩家, 无法杀死));
			设置状态(事件玩家, 空, 无法杀死, 99999);
			设置受到的击退(事件玩家, 1);
	}
}

规则("set hero list")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"make default hero list, which includes all 36 heroes available in Season 2"
		全局.heroList = 数组(英雄(黑影), 英雄(死神), 英雄(莫伊拉), 英雄(雾子), 英雄(西格玛), 英雄(无漾), 英雄(源氏), 英雄(奥丽莎), 英雄(秩序之光), 英雄(温斯顿), 英雄(D.Va), 英雄(猎空), 英雄(黑百合), 英雄(索杰恩),
			英雄(巴蒂斯特), 英雄(美), 英雄(回声), 英雄(布丽吉塔), 英雄(士兵：76), 英雄(朱诺), 英雄(破坏球), 英雄(卡西迪), 英雄(查莉娅), 英雄(卢西奥), 英雄(法老之鹰), 英雄(天使), 英雄(莱因哈特), 英雄(半藏),
			英雄(末日铁拳), 英雄(路霸), 英雄(渣客女王), 英雄(艾什), 英雄(托比昂), 英雄(安娜), 英雄(禅雅塔), 英雄(狂鼠), 英雄(堡垒));
		"remove all heroes that are not for some reason in Overwatch's list of all the heroes (at the time of making this, Mei is an example because she was removed to be patched)"
		修改全局变量(heroList, 根据值从数组中移除, 已过滤的数组(全局.heroList, !数组包含(全部英雄, 当前数组元素)));
		"add any heroes that for some reason are on Overwatch's list but not the game's (eg if I don't update the mode after a hero release). they are added as the second hero in the list"
		If(对任意为“真”(全部英雄, !数组包含(全局.heroList, 当前数组元素)));
			全局.missingHeroes = 已过滤的数组(全部英雄, !数组包含(全局.heroList, 当前数组元素));
			For 全局变量(I, 0, 数量(全局.missingHeroes), 1);
				全局.heroList = 已排序的数组(添加至数组(全局.heroList, 全局.missingHeroes[全局.I]), 当前数组元素 != 全局.missingHeroes[全局.I] ? 当前数组索引 : 0.500);
				等待(0.016, 无视条件);
			End;
		End;
		"move Bastion to the end of the hero list, and keep the rest of the list how it is"
		全局.heroList = 已排序的数组(全局.heroList, 当前数组索引 + 数量(全局.heroList) * (当前数组元素 == 英雄(堡垒)));
		// "remove Wuyang"
	}
}

规则("infinite match time")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		正在设置 == 假;
	}

	动作
	{
		IF(!单次赋值(全局.debugMode));
			禁用查看器录制;
		END;
		关闭游戏预设完成条件;
		关闭游戏预设通告模式;
		关闭游戏预设音乐模式;
		关闭游戏预设计分模式;
		等待(1, 无视条件);
		比赛时间暂停;
		设置慢动作(90);
	}
}

规则("if someone starts the game mode, restart the match")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前游戏模式 != 游戏模式(突击模式);
		(正在设置 || 正在集结英雄 || 游戏正在进行中) == 真;
	}

	动作
	{
		关闭游戏预设通告模式;
		等待(0.016, 无视条件);
		移除所有机器人;
		消除所有效果;
		消除所有HUD文本;
		消除所有图标;
		消除所有地图文本;
		消除所有进度条HUD文本;
		等待(0.016, 无视条件);
		隐藏信息(所有玩家(队伍1));
		隐藏游戏模式HUD(所有玩家(队伍1));
		隐藏游戏模式地图UI(所有玩家(队伍1));
		关闭游戏预设复生模式(所有玩家(队伍1));
		比赛时间继续;
		While(!游戏正在进行中);
			设置比赛时间(0);
			等待(0.016, 无视条件);
		End;
		创建图标(所有玩家(队伍1), 矢量(0, 101, -0.250), 警告, 颜色, 自定义颜色(220 + 弧度的正弦值(总计消耗时间 * 3.141) * 35, 0, 0, 255), 假);
		创建地图文本(所有玩家(队伍1), 自定义字符串("主机开始了游戏模式.\n这将导致智械危机.\n\n                      正在重开..."), 矢量(0,
			101, 0), 3, 不要截取, 颜色, 自定义颜色(220 + 弧度的正弦值(总计消耗时间 * 3.141) * 35, 0, 0, 255), 始终可见);
		For 全局变量(I, 0, 5, 1);
			创建效果(所有玩家(队伍1), 球, 颜色(黑色), 矢量(0, 100 + 0.500 * (全局.I + 1) / 5, 0), 2 + 2 * (全局.I + 5), 无);
			创建效果(所有玩家(队伍1), 球体, 颜色(黑色), 矢量(0, 100, 0), 2 + 2 * (全局.I + 5), 无);
			创建效果(所有玩家(队伍1), 有害光环, 颜色(黑色), 矢量(0, 100 + 3 * (全局.I + 1) / 5, 0), 2 + 2 * (全局.I + 5), 无);
			等待(0.016, 无视条件);
		End;
		开始强制玩家选择英雄(所有玩家(队伍1), 英雄(黑影));
		等待(0.016, 无视条件);
		击杀(所有玩家(队伍1), 主机玩家);
		隐藏英雄HUD(所有玩家(队伍1));
		开始镜头(所有玩家(队伍1), 矢量(0, 100, 0), 矢量(0, 101, 0.010), 0);
		等待(5, 无视条件);
		开启游戏预设音乐模式;
		宣告队伍胜利(队伍2);
		消除所有地图文本;
		消除所有图标;
		等待(2, 无视条件);
		等待直到 (总计消耗时间 > 30, 30);
		重新开始比赛;
	}
}

规则("create bastion bots")
{
	事件
	{
		子程序;
		createBastionBot;
	}

	动作
    {
        // 只补充缺少的机器人，不删除现有的
        While(玩家数量(队伍2) < 数量(全局.bastionPosition));
            生成机器人(英雄(堡垒), 队伍2, -1, 数组随机取值(重生点(队伍2)), 矢量(0, 0, 0));
            等待(0.250, 无视条件);
            
            // 安全措施：防止无限循环（最多尝试20次）
            If(玩家数量(队伍2) >= 数量(全局.bastionPosition) || 总计消耗时间 > 120);
                中止;
            End;
        End;
        
        // 初始化kills数组（只在首次调用时）
        If(全局.kills == 0 || 数量(全局.kills) == 0);
            全局.kills = 数组(0, 0, 0, 0, 0, 0);
        End;
    }
}

规则("create bastion bots when the game starts and there are not enough")
{
    事件
    {
        持续 - 全局;
    }

    条件
    {
        // 只有当机器人数量明显不足时才触发（避免频繁调用）
        玩家数量(队伍2) < 数量(全局.bastionPosition) - 1;
        
        // 游戏已开始一段时间（避免初始化阶段干扰）
        总计消耗时间 > 10;
    }

    动作
    {
        // 等待一小段时间，看是否是暂时性波动
        等待(1, 无视条件);
        
        // 再次检查（避免误触发）
        If(玩家数量(队伍2) < 数量(全局.bastionPosition));
            调用子程序(createBastionBot);
        End;
        
        // 冷却时间，避免频繁触发
        等待(5, 无视条件);
        如条件为“真”则循环;
    }
}

规则("SAFE create bastion bots when the game start and there are no bastion bots - emergency backup")
{
	事件
	{
		持续 - 全局;
	}

	条件
    {
        // 所有机器人都消失了（严重情况）
        玩家数量(队伍2) == 0;
        
        // 游戏已开始（排除初始化阶段）
        总计消耗时间 > 15;
        
        // 有玩家在线（确认不是游戏结束）
        玩家数量(队伍1) > 0;
    }

	动作
    {
        // 等待2秒确认不是临时状态
        等待(2, 无视条件);
        
        // 再次检查
        If(玩家数量(队伍2) == 0);
            // 紧急情况：清空并重建所有机器人
            移除所有机器人;
            等待(0.5, 无视条件);
            调用子程序(createBastionBot);
        End;
        
        // 长冷却时间，避免反复触发
        等待(10, 无视条件);
        如条件为“真”则循环;
    }
}

规则("bastions are numbered and list their kills (by changing their names when they spawn)")
{
	事件
	{
		玩家加入比赛;
		队伍2;
		全部;
	}

	动作
	{
		开始为机器人强制设置名称(事件玩家, 自定义字符串("看守{0} {1}", 栏位(事件玩家) + 1, 全局.kills[栏位(事件玩家)]));
	}
}

规则("damage modifier: players can't hurt bastions")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.difficulty != 5;
		单次赋值(全局.dmgReduction) == 假;
	}

	动作
	{
		开始伤害调整(所有玩家(队伍2), 已过滤的数组(所有玩家(队伍1), !数组包含(全局.devList, 自定义字符串("{0}", 当前数组元素))), 0.100, 受伤害者和伤害者);
		// 开始伤害调整(所有玩家(队伍2), 所有玩家(队伍1), 0.001, 受伤害者和伤害者);
	}
}

规则("anti crash")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.antiCrashActivated == 假;
		服务器负载 > 235;
	}

	动作
	{
		等待(1, 当为“假”时中止);
		小字体信息(所有玩家(所有队伍), 自定义字符串("  防炸房系统工作中..."));
		设置慢动作(20);
		全局.antiCrashActivated = 真;
	}
}

规则("disable anti crash")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.antiCrashActivated != 假;
		服务器负载 < 200;
	}

	动作
	{
		设置慢动作(90);
		全局.antiCrashActivated = 假;
	}
}

规则("disable gamemode hud and player collision for all players")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		隐藏游戏模式HUD(事件玩家);
		隐藏游戏模式地图UI(事件玩家);
		取消与玩家的移动碰撞(事件玩家);
	}
}

规则("enemy bastions must stay in configuration: assault (AKA machine gun/sentry/alternate form)")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		处于非初始状态(事件玩家) == 假;
		总计消耗时间 > 10;
	}

	动作
	{
		"this cancels bastion's \"standing up\" animation so he can sit back down faster"
		取消主要动作(事件玩家);
		设置技能冷却(事件玩家, 按钮(技能1), 0);
		按下按键(事件玩家, 按钮(技能1));
		等待(0.032, 无视条件);
		如条件为“真”则循环;
	}
}

规则("bastions periodically refresh their configuration when there are enemies nearby but out of sight")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		总计消耗时间 > 10;
		事件玩家.target == 假;
		首个(范围内玩家(所选位置(事件玩家), 110, 队伍1, 关闭)) != 假;
	}

	动作
	{
		等待(随机实数(0.200, 1), 当为“假”时中止);
		按下按键(事件玩家, 按钮(技能1));
		等待(随机实数(1, 3), 无视条件);
		如条件为“真”则循环;
	}
}

规则("bastion constantly searches for targets in line of sight")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		首个(范围内玩家(眼睛位置(事件玩家), 105, 队伍1, 表面)) != 假;
	}

	动作
	{
		事件玩家.temp = 已过滤的数组(所有存活玩家(队伍1), 在视线内(眼睛位置(事件玩家), 眼睛位置(当前数组元素), 屏障不会阻挡视线) || 在视线内(眼睛位置(事件玩家), 所选位置(当前数组元素), 屏障不会阻挡视线));
		等待(0.016, 无视条件);
		If(!事件玩家.temp);
			事件玩家.target = 空;
			跳过(8);
		End;
		禁用 修改玩家变量(事件玩家, temp, 根据值从数组中移除, 已过滤的数组(事件玩家.temp, !已重生(当前数组元素) || 当前数组元素.isWinner || 具有状态(当前数组元素, 相移) || (所用英雄(当前数组元素) == 英雄(黑影)
			&& 正在使用技能 1(当前数组元素))));
		修改玩家变量(事件玩家, temp, 根据值从数组中移除, 已过滤的数组(事件玩家.temp, !已重生(当前数组元素) || 当前数组元素.isWinner || 具有状态(当前数组元素, 相移) || 当前数组元素.targetSilence || 相距距离(事件玩家, 当前数组元素) >= 100));
		等待(0.016, 无视条件);
		If(数量(事件玩家.temp) > 1);
			事件玩家.temp = 已排序的数组(事件玩家.temp, 全局.bastionBotTargetPrefer == 0 ? 生命值(当前数组元素) * 相距距离(事件玩家, 当前数组元素) : (
				全局.bastionBotTargetPrefer == 1 ? 相距距离(事件玩家, 当前数组元素) : 生命值(当前数组元素)));
			等待(0.016, 无视条件);
		End;
		IF(!单次赋值(全局.dlcVishkarEvent));
			事件玩家.target = 首个(事件玩家.temp);
		ELSE;
			事件玩家.target = 首个(已排序的数组(事件玩家.temp, 当前数组元素.targetWeight * -1));
		END;
		等待(随机实数(0.256, 0.512), 无视条件);
		如条件为“真”则循环;
		事件玩家.target = 空;
	}
}

规则("bastion fires if he has a target")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		存活(事件玩家) == 真;
		事件玩家.hasNano != 真;
		正在使用主要武器(事件玩家) == 假;
		事件玩家.target != 假;
	}

	动作
	{
		开始按下按钮(事件玩家, 按钮(主要攻击模式));
		等待(0.500, 无视条件);
		如条件为“真”则循环;
	}
}

规则("bastion stops firing when there aren't targets")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		事件玩家.target == 假;
		存活(事件玩家) == 真;
	}

	动作
	{
		停止按下按钮(事件玩家, 按钮(主要攻击模式));
		等待(1, 当为“假”时中止);
		根据条件循环(正在使用主要武器(事件玩家));
	}
}

规则("bastion secondary fires if he has a target")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		// (全局.difficulty == 5 || 全局.bastionBotSeconFire) == 真;
		对任意为“真”(数组(全局.difficulty == 5, 全局.bastionBotSeconFire), 当前数组元素) == 真;
		事件玩家.hasNano == 假;
		单次赋值(是否是机器人(事件玩家)) != 假;
		存活(事件玩家) == 真;
		正在使用主要武器(事件玩家) == 真;
		技能冷却时间(事件玩家, 按钮(辅助攻击模式)) == 0;
		事件玩家.target != 假;
	}

	动作
	{
		等待(随机实数(0.032, 0.160), 当为“假”时中止);
		按下按键(事件玩家, 按钮(辅助攻击模式));
		事件玩家.target.A36TGrenade += 1;
		等待(1.488, 无视条件);
		如条件为“真”则循环;
	}
}

规则("bastion secondary fires if he has nano")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		事件玩家.hasNano == 真;
		首个(范围内玩家(眼睛位置(事件玩家), 150, 队伍1, 关闭)) != 假;
		存活(事件玩家) == 真;
		技能冷却时间(事件玩家, 按钮(辅助攻击模式)) == 0;
	}

	动作
	{
		等待(随机实数(0.016, 0.032), 当为“假”时中止);
		开始按下按钮(事件玩家, 按钮(辅助攻击模式));
		根据条件跳过(事件玩家.target == 空, 1);
		事件玩家.target.A36TGrenade += 1;
		// 等待直到(!事件玩家.hasNano, 10);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		如条件为“真”则循环;
		停止按下按钮(事件玩家, 按钮(辅助攻击模式));
	}
}

规则("bastion aims at whichever part of his target is most exposed")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		存活(事件玩家) == 真;
		事件玩家.target != 空;
	}

	动作
	{
		事件玩家.tempAimPosition = (所选位置(事件玩家.target) + 眼睛位置(事件玩家.target)) / 2;
		If(在视线内(眼睛位置(事件玩家), 事件玩家.tempAimPosition, 屏障不会阻挡视线));
			事件玩家.aimPosition = 事件玩家.tempAimPosition;
		Else If(在视线内(眼睛位置(事件玩家), 眼睛位置(事件玩家.target), 屏障不会阻挡视线));
			事件玩家.aimPosition = 眼睛位置(事件玩家.target);
		Else;
			事件玩家.aimPosition = 所选位置(事件玩家.target);
		End;
		等待(0.064, 无视条件);
		如条件为“真”则循环;
	}
}

规则("bastion places his crosshair near the closest potential target if he doesn't currently have one")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		存活(事件玩家) == 真;
		事件玩家.target == 假;
	}

	动作
	{
		等待(服务器负载 / 100, 当为“假”时中止);
		禁用 事件玩家.nearestTargetOutOfLoS = 首个(已排序的数组(已过滤的数组(所有存活玩家(队伍1), 已重生(当前数组元素) && !事件玩家.isWinner && !(所用英雄(当前数组元素) == 英雄(黑影) && 正在使用技能 1(
			当前数组元素))), 相距距离(眼睛位置(事件玩家), 眼睛位置(当前数组元素))));
		事件玩家.nearestTargetOutOfLoS = 首个(已排序的数组(已过滤的数组(所有存活玩家(队伍1), 已重生(当前数组元素) && !事件玩家.isWinner), 相距距离(眼睛位置(事件玩家), 眼睛位置(当前数组元素))));
		根据条件跳过(事件玩家.nearestTargetOutOfLoS == 空, 1);
		事件玩家.aimPosition = 眼睛位置(事件玩家.nearestTargetOutOfLoS) + 矢量(随机实数(-1, 1), 随机实数(-1, 1), 随机实数(-1, 1));
		等待(随机实数(1, 4), 无视条件);
		如条件为“真”则循环;
	}
}

规则("determine bastion's aim speed, to improve smooth tracking")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		存活(事件玩家) == 真;
		事件玩家.target != 假;
	}

	动作
	{
		事件玩家.turnSpeed = 矢量间夹角(面朝方向(事件玩家), 方向(眼睛位置(事件玩家), 眼睛位置(事件玩家.target))) * 全局.turnSpeedMultiplier;
		事件玩家.turnSpeed += 速度(事件玩家.target) * 全局.turnSpeedMultiplier;
		等待(服务器负载平均值 / 1000, 无视条件);
		如条件为“真”则循环;
	}
}

规则("increase bastion's aim speed to prep for flicking to a target entering range")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		存活(事件玩家) == 真;
		事件玩家.target == 假;
		矢量间夹角(面朝方向(事件玩家), 方向(眼睛位置(事件玩家), 所选位置(事件玩家.aimPosition))) >= 1;
	}

	动作
	{
		事件玩家.turnSpeed = 矢量间夹角(面朝方向(事件玩家), 方向(眼睛位置(事件玩家), 所选位置(事件玩家.aimPosition)) * 全局.turnSpeedMultiplier);
		等待(服务器负载峰值 / 1000, 无视条件);
		如条件为“真”则循环;
	}
}

规则("start facing bastion bots")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		存活(事件玩家) == 真;
		已重生(事件玩家) == 真;
		总计消耗时间 > 10;
	}

	动作
	{
		开始朝向(事件玩家, 方向(眼睛位置(事件玩家), 事件玩家.aimPosition), 具有状态(事件玩家, 沉睡) ? 0 : 事件玩家.turnSpeed, 至地图, 方向及角速率);
	}
}

规则("set bastion's target to null once he kills them")
{
	事件
	{
		玩家造成最后一击;
		队伍2;
		全部;
	}

	动作
	{
		事件玩家.target = 空;
		事件玩家.nearestTargetOutOfLoS = 空;
		// 根据条件跳过(全局.difficulty != 5, 3);
		// IF(事件技能 == 按钮(辅助攻击模式) && 全局.A36TGrenadeFB == 空);
		// 	全局.A36TGrenadeFB = 被攻击方;
		// END;
	}
}

规则("bastion punches the ground a few times at first to destroy railings")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		总计消耗时间 < 10;
		总计消耗时间 > 5;
	}

	动作
	{
		设置朝向(事件玩家, 下, 至地图);
		For 玩家变量(事件玩家, I, 0, 3, 1);
			按下按键(事件玩家, 按钮(近身攻击));
			等待(1.200, 无视条件);
		End;
	}
}

规则("bastion fully heals periodically")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		存活(事件玩家) == 真;
		标准化生命值(事件玩家) < 1;
	}

	动作
	{
		等待(60, 无视条件);
		开始持续治疗(事件玩家, 空, 59.500, 9999);
		如条件为“真”则循环;
	}
}

规则("bastion immediately respawns upon death")
{
	事件
	{
		玩家阵亡;
		队伍2;
		堡垒;
	}

	动作
	{
		等待(0.016, 无视条件);
		复生(事件玩家);
	}
}

规则("teleport bastions back and reset velocity when they are displaced")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		相距距离(所选位置(事件玩家), 全局.bastionPosition[栏位(事件玩家)]) > 2;
	}

	动作
	{
		等待(0.500, 当为“假”时中止);
		事件玩家.isInPosition = 假;
		开启与环境的移动碰撞(事件玩家);
		设置状态(事件玩家, 空, 相移, 7);
		传送(事件玩家, 全局.bastionPosition[栏位(事件玩家)]);
		等待(0.016, 无视条件);
		开始强制设置玩家位置(事件玩家, 全局.bastionPosition[栏位(事件玩家)], 假);
		等待(0.016, 无视条件);
		等待直到 (速度(事件玩家) < 1, 2);
		停止强制设置玩家位置(事件玩家);
		如条件为“真”则循环;
	}
}

规则("bastions stay where they initially land")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		总计消耗时间 > 10;
		事件玩家.isInPosition == 假;
		正在移动(事件玩家) == 假;
	}

	动作
	{
		等待(5, 当为“假”时中止);
		等待直到 (正在使用技能 1(事件玩家), 2);
		等待(0.500, 当为“假”时中止);
		开始强制设置玩家位置(事件玩家, 所选位置(事件玩家), 假);
		取消与环境的移动碰撞(事件玩家, 真);
		事件玩家.isInPosition = 真;
	}
}

规则("bastions whose position is far above the ground instead stay at that position")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		事件玩家.isInPosition == 假;
		已重生(事件玩家) == 真;
		存活(事件玩家) == 真;
		相距距离(射线命中位置(全局.bastionPosition[栏位(事件玩家)] + 上, 全局.bastionPosition[栏位(事件玩家)] + 下 * 5, 空, 空, 假), 全局.bastionPosition[栏位(事件玩家)] + 下 * 5)
			== 0;
	}

	动作
	{
		传送(事件玩家, 全局.bastionPosition[栏位(事件玩家)]);
		等待(0.016, 无视条件);
		开始强制设置玩家位置(事件玩家, 全局.bastionPosition[栏位(事件玩家)], 假);
	}
}

规则("bastion A-36 Tactical Grenade hit player")
{
	事件
	{
		玩家受到击退;
		队伍1;
		全部;
	}

	条件
	{
		全局.difficulty == 5;
		所用英雄(攻击方) == 英雄(堡垒);
		攻击方 != 事件玩家;
		事件技能 == 按钮(辅助攻击模式);
	}

	动作
	{
		被攻击方.A36TGrenadeHit += 1;
		等待(0.032, 无视条件);
	}
}

规则("bastion A-36 Tactical Grenade hit player")
{
	事件
	{
		玩家受到伤害;
		队伍1;
		全部;
	}

	条件
	{
		对任意为“真”(数组(全局.difficulty == 5, 全局.bastionBotSeconFire, 单次赋值(全局.dlcVishkarEvent)), 当前数组元素) == 真;
		所用英雄(攻击方) == 英雄(堡垒);
		攻击方 != 事件玩家;
		事件技能 == 按钮(辅助攻击模式);
	}

	动作
	{
		根据条件跳过(!攻击方.hasNano, 2);
		设置状态(事件玩家, 攻击方, 燃烧, 3.000);
		开始持续伤害(事件玩家, 攻击方, 3, 取整(取整((最大生命值(被攻击方) * 0.25) / 3, 上) / 4, 上));
		IF(全局.eventId == 2); // 超算进化
			IF(随机整数(0, 100) < 50);
				设置状态(事件玩家, 攻击方, 击倒, 3.000);
			Else;
				设置状态(事件玩家, 攻击方, 冰冻, 1.500);
			END;
		END;
		被攻击方.A36TGrenadeDmg += 事件伤害 + 取整(取整((最大生命值(被攻击方) * 0.25) / 3, 上) / 4, 上);
		等待(0.016, 无视条件);
	}
}

规则("push players away from bastions")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.debugInfo != 真;
		首个(范围内玩家(事件玩家, 2, 队伍2, 关闭)) != 假;
	}

	动作
	{
		施加推力(事件玩家, 与此角度的相对方向(与此方向的水平角度(所选位置(事件玩家) - 所选位置(距离最近的玩家(事件玩家, 队伍2))), -20), 15, 至地图, 取消相反运动);
		等待(0.500, 当为“真”时重新开始);
	}
}

规则("SYSTEM: Core Regen Logic (Signal Based)")
{
    事件
    {
        持续 - 每名玩家;
        队伍1;
        全部;
    }

    条件
    {
        // 只要这个信号变成“真”，规则就会激活（或重启）
        事件玩家.combatRegen == 真;
    }

    动作
    {
        // 1. 立即“灭灯”，准备接收下一次信号
        // 这一步非常关键：把它设为假，规则才能在 Wait 期间再次检测到它变回“真”从而触发重启
        事件玩家.combatRegen = 假;

        // 2. 停止当前治疗
        停止持续治疗(事件玩家.healID);
        事件玩家.healID = 0;

        // 3. 核心等待逻辑 (保留你的原汁原味)
        // 如果在等待期间 combatRegen 再次变回 真，这里会立即中断并从动作第一行重新开始！
        等待(3.000, 当为“真”时重新开始);

        // 4. 下面的逻辑只有在3秒内信号没有变回“真”才会执行 (即真正的脱战)
        // 根据条件中止(死亡(事件玩家) || 标准化生命值(事件玩家) == 1);
        根据条件中止(对任意为“真”(数组(
			死亡(事件玩家),
			标准化生命值(事件玩家) == 1,
			事件玩家.heal_recv <= -100
		), 当前数组元素));

        // 5. 开始治疗
		小字体信息(事件玩家, 自定义字符串("  {0}  脱战自动回复启动 ", 技能图标字符串(英雄(巴蒂斯特), 按钮(技能1))));
        开始持续治疗(事件玩家, 事件玩家, 9999, 50 + 最大生命值(事件玩家) * 0.080);
        事件玩家.healID = 上一个持续治疗效果ID;
    }
}

规则("Trigger: Normal Damage")
{
    事件
    {
        玩家受到伤害;
        队伍1;
        全部;
    }

    动作
    {
        // 发送信号，告诉核心规则“重置倒计时！”
        事件玩家.combatRegen = 真;
		等待(0.016, 无视条件);
    }
}

规则("Trigger: Grenade Alive")
{
    事件
    {
        玩家受到伤害;
        队伍1;
        全部;
    }

	条件
	{
		事件玩家.A36TGrenadeAlive != 真;
		对全部为“真”(数组(
			事件技能 == 按钮(辅助攻击模式), 
			所用英雄(攻击方) == 英雄(堡垒),
			攻击方 != 事件玩家,
			生命值(事件玩家) <= 5
		), 当前数组元素) == 真;
	}

    动作
    {
        事件玩家.A36TGrenadeAlive = 真;
		中止;
    }
}

规则("players pick up speed while not targeted for 3 seconds")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(
			单次赋值(全局.dlcVishkarEvent) == 假,
			首个(范围内玩家(事件玩家, 60, 队伍2, 表面)) == 假,
			正在移动(事件玩家)
		), 当前数组元素) == 真;
	}

	动作
	{
		等待(3, 当为“假”时中止);
		设置移动速度(事件玩家, 160);
		等待直到 (首个(范围内玩家(事件玩家, 60, 队伍2, 表面)) || !正在移动(事件玩家), 9999);
		设置移动速度(事件玩家, 100);
	}
}

规则("player deaths are counted manually rather than relying on in-game statistics")
{
	事件
	{
		玩家阵亡;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.isWinner == 假;
	}

	动作
	{
		等待(0.500 * 服务器负载 / 100, 无视条件);
		事件玩家.runDeathCount += 1;
		If(数组包含(全局.savedIndex, 事件玩家));
			等待(0.032, 无视条件);
			全局.savedDeaths[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.runDeathCount;
		END;
		设置朝向(事件玩家, 方向(眼睛位置(事件玩家), 单次赋值(全局.controlRespawnPosition) == 空 ? 所选位置(全局.endPosition) : 所选位置(首个(全局.controlJumpPosition))), 至地图);
	}
}

规则("when a mercy might rez, respawn time is increased")
{
	事件
	{
		玩家阵亡;
		队伍1;
		全部;
	}

	条件
	{
		// 单次赋值(全局.controlRespawnPosition) == 空;
		正在使用英雄(英雄(天使), 队伍1) == 真;
		事件玩家.controlPlayerRespawnPosition == 空;
	}

	动作
	{
		根据条件中止(单次赋值(全局.dlcVishkarEvent) && 事件玩家.eventType == 0 && 事件玩家.eventId == 8);
		If(对任意为“真”(选择英雄的玩家(英雄(天使), 队伍1), 相距距离(所选位置(事件玩家), 所选位置(当前数组元素)) < 40 && 存活(当前数组元素) && 技能冷却时间(当前数组元素, 按钮(技能2)) < 8));
			大字体信息(事件玩家, 自定义字符串("附近有 天使 等待复活..."));
			关闭游戏预设复生模式(事件玩家);
			等待(4, 无视条件);
			开启游戏预设复生模式(事件玩家);
	}
}

规则("symmetra auto-breaks tp after going through")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		秩序之光;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		技能冷却时间(事件玩家, 按钮(技能2)) > 0;
	}

	动作
	{
		等待(0.500, 无视条件);
		While(对全部为“真”(数组(正在使用技能 2(事件玩家), 技能冷却时间(事件玩家, 按钮(技能2)) > 0), 当前数组元素));
			// 根据条件中止(在重生室中(事件玩家));
			按下按键(事件玩家, 按钮(技能2));
			等待(0.250, 无视条件);
		End;
	}
}

规则("symmetra auto-breaks tp after time limit")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		秩序之光;
	}

	条件
	{
		技能冷却时间(事件玩家, 按钮(技能2)) > 0;
	}

	动作
	{
		等待(1.250, 当为“假”时中止);
		While(对全部为“真”(数组(正在使用技能 2(事件玩家), 技能冷却时间(事件玩家, 按钮(技能2)) > 0), 当前数组元素));
			// 根据条件中止(在重生室中(事件玩家));
			按下按键(事件玩家, 按钮(技能2));
			等待(0.250, 无视条件);
		End;
	}
}

规则("when d.va demechs, set starting point (for goal) and enable remech")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(D.Va);
		处于非初始状态(事件玩家) == 真;
		正在使用终极技能(事件玩家) == 假;
	}

	动作
	{
		设置状态(事件玩家, 空, 无敌, 1.500);
		设置启用终极技能(事件玩家, 假);
		等待(0.050, 无视条件);
		事件玩家.dvaStart = 所选位置(事件玩家) * 矢量(1, 0, 1);
		等待(1, 无视条件);
		设置启用终极技能(事件玩家, 真);
	}
}

规则("while d.va is out of mech and alive, update ult charge to reflect goal distance")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		D.Va;
	}

	条件
	{
		处于非初始状态(事件玩家) == 真;
		存活(事件玩家) == 真;
		事件玩家.dvaStart != 0;
		终极技能充能百分比(事件玩家) != 100;
	}

	动作
	{
		设置终极技能充能(事件玩家, 3.333 * 相距距离(所选位置(事件玩家) * 矢量(1, 0, 1), 事件玩家.dvaStart));
		等待(0.500 * 服务器负载平均值 / 100, 无视条件);
		如条件为“真”则循环;
	}
}

规则("once baby d.va is far enough from where she lost mech, she can remech")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		D.Va;
	}

	条件
	{
		处于非初始状态(事件玩家) == 真;
		事件玩家.dvaStart != 0;
	}

	动作
	{
		等待直到 (相距距离(所选位置(事件玩家) * 矢量(1, 0, 1), 事件玩家.dvaStart) >= 30 || 死亡(事件玩家), 9999);
		事件玩家.dvaStart = 0;
		根据条件中止(死亡(事件玩家));
		设置终极技能充能(事件玩家, 100);
	}
}

规则("reinhardt cannot charge bastions")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		莱因哈特;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		等待直到 (首个(范围内玩家(事件玩家, 2, 队伍2, 关闭)) || !正在使用技能 1(事件玩家), 5);
		根据条件中止(!正在使用技能 1(事件玩家) || 正在使用辅助武器(事件玩家));
		等待(0.016, 无视条件);
		取消主要动作(事件玩家);
	}
}

规则("ana can only sleep each bastion once per limited amount of time")
{
	事件
	{
		玩家造成伤害;
		队伍1;
		安娜;
	}

	条件
	{
		事件技能 == 按钮(技能1);
		被攻击方.hasNano != 真;
	}

	动作
	{
		If(总计消耗时间 - 事件玩家.anaSleepLimit[栏位(被攻击方)] > 30);
			"taking damage won't wake bastion"
			设置状态(被攻击方, 空, 无敌, 5);
			事件玩家.anaSleepLimit[栏位(被攻击方)] = 总计消耗时间;
		Else;
			大字体信息(事件玩家, 自定义字符串("{0} 我起了！ {0}时间到了！", 图标字符串(警告)));
			等待(0.100, 无视条件);
			While(具有状态(被攻击方, 沉睡));
				清除状态(被攻击方, 沉睡);
				等待(0.100, 无视条件);
			End;
	}
}

规则("ana's sleep limit refreshes when she spawns")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		安娜;
	}

	条件
	{
		存活(事件玩家) == 真;
	}

	动作
	{
		等待(服务器负载平均值 / 100, 无视条件);
		事件玩家.anaSleepLimit = 映射的数组(全局.bastionPosition, -30);
	}
}

规则("[Zenyatta] Snap Kick (Self Ground)  - created by 他又 from 77QS1")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		禅雅塔;
	}

	条件
	{
		正在近战攻击(事件玩家) == 真;
		垂直朝向角度(事件玩家) >= 45;
	}

	动作
	{
		// 等待直到 (相距距离(眼睛位置(事件玩家), 射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 3, 空, 空, 假)) <= 2, 0.200);
		// If(相距距离(眼睛位置(事件玩家), 射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 3, 空, 空, 假)) <= 2);
		// 	施加推力(事件玩家, 面朝方向(事件玩家) * 矢量(-1, -0.750, -1) + 上 * 0.200, 12 * (Y方向分量(面朝方向(事件玩家)) > -0.750 ? 1 : 2 * (1.250 + Y方向分量(面朝方向(事件玩家)))),
		// 		至地图, 取消相反运动);
		If(相距距离(射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 2.510, 所有玩家(所有队伍), 事件玩家, 真), 眼睛位置(事件玩家)) <= 2.500);
			// 事件玩家.KnockbackDirection = ;
			等待(0.016, 无视条件);
			施加推力(事件玩家, 面朝方向(事件玩家) * -1, 15.500, 至地图, 取消相反运动);
			施加推力(事件玩家, 上, 15.500 * 0.300, 至地图, 取消相反运动);
		End;
	}
}

规则("[Zenyatta] Snap Kick (Self Wall)  - created by 他又 from 77QS1")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		禅雅塔;
	}

	条件
	{
		正在近战攻击(事件玩家) == 按钮(近身攻击);
		垂直朝向角度(事件玩家) < 45;
	}

	动作
	{
		If(相距距离(射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 2.510, 所有玩家(所有队伍), 事件玩家, 真), 眼睛位置(事件玩家)) <= 2.500);
			If(射线命中玩家(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 5, 所有玩家(所有队伍), 事件玩家, 真) == 空);
				施加推力(事件玩家, 面朝方向(事件玩家) * -1, 15.500, 至地图, 取消相反运动);
			施加推力(事件玩家, 上, 15.500 * 0.300, 至地图, 取消相反运动);
			End;
		End;
	}
}

禁用 规则("zenyatta's melee knocks him back")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		禅雅塔;
	}

	条件
	{
		正在近战攻击(事件玩家) == 真;
		垂直朝向角度(事件玩家) >= 45;
	}

	动作
	{
		// 等待直到 (相距距离(眼睛位置(事件玩家), 射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 3, 空, 空, 假)) <= 2, 0.200);
		// If(相距距离(眼睛位置(事件玩家), 射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 3, 空, 空, 假)) <= 2);
		// 	施加推力(事件玩家, 面朝方向(事件玩家) * 矢量(-1, -0.750, -1) + 上 * 0.200, 12 * (Y方向分量(面朝方向(事件玩家)) > -0.750 ? 1 : 2 * (1.250 + Y方向分量(面朝方向(事件玩家)))),
		// 		至地图, 取消相反运动);
		If(相距距离(射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 2.510, 所有玩家(所有队伍), 事件玩家, 真), 眼睛位置(事件玩家)) <= 2.500);
			// 事件玩家.KnockbackDirection = ;
			等待(0.016, 无视条件);
			施加推力(事件玩家, 面朝方向(事件玩家) * -1, 15.500, 至地图, 取消相反运动);
			施加推力(事件玩家, 上, 15.500 * 0.300, 至地图, 取消相反运动);
		End;
	}
}

规则("zenyatta's jump can levitate if held")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		// 单次赋值(全局.dlcVishkarEvent) != 真;
		所用英雄(事件玩家) == 英雄(禅雅塔);
		正在跳跃(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
	}

	动作
	{
		"don't activate the rule if the player is just jumping normally and not holding jump"
		等待(0.120, 当为“假”时中止);
		设置引力(事件玩家, 0);
		开始加速(事件玩家, Y方向分量(速率(事件玩家)) < 2 ? 上 : 下, Y方向分量(速率(事件玩家)) < 2.050 ? 5 : (Y方向分量(速率(事件玩家)) > 1.950 ? 17.500 : 0), 100, 至地图,
			方向，速率，及最大速度);
		等待直到 (!按钮被按下(事件玩家, 按钮(跳跃)), 1.500);
		设置引力(事件玩家, 100);
		停止加速(事件玩家);
		"ability is only available again once you touch the ground"
		等待直到 (在地面上(事件玩家), 10);
	}
}

规则("Lifeweaver disable Life Grip if no winners")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(生命之梭);
		事件玩家.isWinner != 真;
	}

	动作
	{
		禁用按钮(事件玩家, 按钮(技能2));
		设置启用技能 2(事件玩家, 假);
		等待直到 (事件玩家.isWinner == 真 || 所用英雄(事件玩家) != 英雄(生命之梭), 999999986991104.000);
		可用按钮(事件玩家, 按钮(技能2));
		设置启用技能 2(事件玩家, 真);
	}
}

规则("Hashtag")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		弗蕾娅;
	}

	条件
	{
		数量(已过滤的数组(所有玩家(队伍1), 当前数组元素.isWinner && !当前数组元素.isDev)) == 0;
		正在使用英雄(英雄(雾子), 队伍1) != 真;
		具有状态(事件玩家, 相移) != 真;
		具有状态(事件玩家, 无敌) != 真;
		正在使用技能 2(事件玩家) == 真;
		全局.hashTag == 真;
	}

	动作
	{
		等待直到 (!正在使用技能 2(事件玩家), 0.160);
		全局.hashTag = 单次赋值(技能冷却时间(事件玩家, 按钮(技能2)) < 3 ? 假 : 真);
		等待(60, 无视条件);
	}
}

规则("Hashtag")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.hashTag == 真;
		全局.vishkarEventActivated == 真;
		总计消耗时间 > 125;
	}

	动作
	{
		等待直到 (对任意为“真”(数组(数量(全局.buffEventId) != 24, 数量(全局.debuffEventId) != 16, 数量(全局.mechEventId != 14)), 当前数组元素), 999999986991104.000);
		全局.hashTag = 假;
		等待(60, 无视条件);
	}
}

禁用 规则("Hashtag")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		死神;
	}

	条件
	{
		正在使用英雄(英雄(雾子), 队伍1) != 真;
		// 具有状态(事件玩家, 相移) != 真;
		// 具有状态(事件玩家, 无敌) != 真;
		正在使用技能 2(事件玩家) == 真;
		全局.hashTag == 真;
	}

	动作
	{
		等待直到 (!正在使用技能 2(事件玩家), 0.160);
		全局.hashTag = 单次赋值(技能冷却时间(事件玩家, 按钮(技能2)) < 30 ? 假 : 真);
		等待(60, 无视条件);
	}
}

规则("Hashtag")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		朱诺;
	}

	条件
	{
		正在使用英雄(英雄(雾子), 队伍1) != 真;
		// 具有状态(事件玩家, 相移) != 真;
		// 具有状态(事件玩家, 无敌) != 真;
		正在使用技能 1(事件玩家) == 真;
		全局.hashTag == 真;
	}

	动作
	{
		等待直到 (!正在使用技能 1(事件玩家), 3);
		全局.hashTag = 单次赋值(技能冷却时间(事件玩家, 按钮(技能1)) < 3.8 ? 假 : 真);
		等待(60, 无视条件);
	}
}

规则("Hashtag")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		毛加;
	}

	条件
	{
		全局.hashTag == 真;
		对全部为“真”(数组(
			正在使用英雄(英雄(雾子), 队伍1) != 真,
			正在使用技能 1(事件玩家)
		), 当前数组元素) == 真;
	}

	动作
	{
		等待直到 (!正在使用技能 1(事件玩家), 4);
		全局.hashTag = 单次赋值(技能冷却时间(事件玩家, 按钮(技能1)) < 3.8 ? 假 : 真);
		等待(60, 无视条件);
	}
}

规则("Juno disable Ability 1 if possess")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 所用英雄(事件玩家) == 英雄(朱诺), 事件玩家.eventType == 0, 事件玩家.eventId == 12, 首个(事件玩家.possess).possessed == 真), 当前数组元素) == 真;
	}

	动作
	{
		禁用按钮(事件玩家, 按钮(技能1));
		设置启用技能 1(事件玩家, 假);
		等待直到 (事件玩家.eventId != 12 || 首个(事件玩家.possess).possessed != 真 || 所用英雄(事件玩家) != 英雄(朱诺), 999999986991104.000);
		可用按钮(事件玩家, 按钮(技能1));
		设置启用技能 1(事件玩家, 真);
	}
}

规则("Lifeweaver auto-breaks Petal Platform after time limit")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		生命之梭;
	}

	条件
	{
		对任意为“真”(数组(正在使用技能1(事件玩家), 技能冷却时间(事件玩家, 按钮(技能1)) > 0), 当前数组元素) == 真;
	}

	动作
	{
		等待(3, 当为“假”时中止);
		While(正在使用技能 1(事件玩家));
			禁用 根据条件中止(在重生室中(事件玩家));
			按下按键(事件玩家, 按钮(技能1));
			等待(0.250, 无视条件);
		End;
	}
}

规则("when players reaches the end and not respawn at first respawn point, they move to the first respawn point.")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.controlRespawnPosition) != 空;
		已重生(事件玩家) == 真;
		在重生室中(事件玩家) == 真;
		// 相距距离(矢量(0, 全局.controlRespawnAxis == 0 ? X方向分量(所选位置(事件玩家)) : Y方向分量(所选位置(事件玩家)), 全局.controlRespawnAxis == 2 ? Z方向分量(所选位置(事件玩家)) : 0), 矢量(0, 全局.controlRespawnAxis == 0 ? X方向分量(首个(全局.controlRespawnPosition)) : Y方向分量(首个(全局.controlRespawnPosition)), 全局.controlRespawnAxis == 2 ? Z方向分量(首个(全局.controlRespawnPosition)) : 0)) >= 全局.controlRespawnAxisThreshold;
		对任意为“真”(
			数组(
				全局.controlRespawnAxis == 0 && 相距距离(矢量(X方向分量(所选位置(事件玩家)), 0, 0), 矢量(X方向分量(全局.controlRespawnPosition[事件玩家.controlJumpIndex]), 0, 0)) >= 全局.controlRespawnAxisThreshold,
				全局.controlRespawnAxis == 1 && 相距距离(矢量(0, Y方向分量(所选位置(事件玩家)), 0), 矢量(0, Y方向分量(全局.controlRespawnPosition[事件玩家.controlJumpIndex]), 0)) >= 全局.controlRespawnAxisThreshold,
				全局.controlRespawnAxis == 2 && 相距距离(矢量(0, 0, Z方向分量(所选位置(事件玩家))), 矢量(0, 0, Z方向分量(全局.controlRespawnPosition[事件玩家.controlJumpIndex]))) >= 全局.controlRespawnAxisThreshold
			), 当前数组元素) == 真;
		// 事件玩家.controlJumpIndex == 0;
	}

	动作
	{
		传送(事件玩家, 全局.controlRespawnPosition[事件玩家.controlJumpIndex]);
		设置朝向(事件玩家, 方向(眼睛位置(事件玩家), 所选位置(全局.controlJumpPosition[事件玩家.controlJumpIndex])), 至地图);
		等待(0.032, 无视条件);
	}
}

规则("when a player reaches the control jump point, they move on to the next map")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.controlRespawnPosition) != 空;
		已重生(事件玩家) == 真;
		在重生室中(事件玩家) != 真;
		正在移动(事件玩家) == 真;
		禁用 Y方向分量(所选位置(事件玩家)) >= Y方向分量(全局.controlJumpPosition[事件玩家.controlJumpIndex]);
		禁用 相距距离(所选位置(事件玩家) * 矢量(1, 0, 1), 全局.controlJumpPosition[事件玩家.controlJumpIndex] * 矢量(1, 0, 1)) <= 4;
	}

	动作
	{
		等待(0.032, 当为“假”时中止);
		等待(0.2, 无视条件);
		IF(对全部为“真”(
			数组(
				Y方向分量(所选位置(事件玩家)) >= Y方向分量(全局.controlJumpPosition[事件玩家.controlJumpIndex]), 
				相距距离(所选位置(事件玩家) * 矢量(1, 0, 1), 全局.controlJumpPosition[事件玩家.controlJumpIndex] * 矢量(1, 0, 1)) <= 4
			), 当前数组元素));
			根据条件跳过(全局.controlJumpPosition[事件玩家.controlJumpIndex] == 空, 9);
			事件玩家.controlJumpIndex += 1;
			等待(0.016, 无视条件);
			根据条件跳过(对任意为“真”(数组(具有状态(事件玩家, 相移), 具有状态(事件玩家, 无敌)), 当前数组元素), 2);
			设置状态(事件玩家, 空, 相移, 0.5);
			设置状态(事件玩家, 空, 无敌, 0.5);
			传送(事件玩家, 全局.controlRespawnPosition[事件玩家.controlJumpIndex]);
			设置朝向(事件玩家, 方向(眼睛位置(事件玩家), 所选位置(全局.controlJumpPosition[事件玩家.controlJumpIndex])), 至地图);
			等待(2.160, 无视条件);
		End;
		循环;
	}
}

规则("when a player reaches the end, they move on to the next hero or win if they're bastion")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		Y方向分量(所选位置(事件玩家)) >= Y方向分量(全局.endPosition);
		相距距离(所选位置(事件玩家) * 矢量(1, 0, 1), 全局.endPosition * 矢量(1, 0, 1)) <= 4;
	}

	动作
	{
		复生(事件玩家);
		等待(0.032, 无视条件);
		根据条件跳过(全局.controlRespawnPosition == 空, 4);
		事件玩家.controlJumpIndex = 0;
		传送(事件玩家, 首个(全局.controlRespawnPosition));
		等待(0.032, 无视条件);
		设置朝向(事件玩家, 方向(眼睛位置(事件玩家), 所选位置(首个(全局.controlJumpPosition))), 至地图);
		If(事件玩家.heroNumber + 1 < 数量(全局.heroList) && 所用英雄(事件玩家) == 全局.heroList[事件玩家.heroNumber]);
			调用子程序(progressHero);
		Else If(所用英雄(事件玩家) == 最后(全局.heroList) && !事件玩家.isWinner);
			事件玩家.isWinner = 真;
			事件玩家.winnerTime = 单次赋值(总计消耗时间) - 事件玩家.joinTime;
			// 大字体信息(所有玩家(队伍1), 自定义字符串("恭喜 {0} 以 {1} 耗时 {2} 通关!", 事件玩家, 自定义字符串("{0} 次阵亡 & {1} 次跳过", 事件玩家.runDeathCount, 事件玩家.skipCount), 自定义字符串("{0}{1}{2}", 总计消耗时间 - 事件玩家.joinTime > 3599 ? 自定义字符串("{0}小时{1} ", 取整(取整(总计消耗时间 - 事件玩家.joinTime, 上) / 3600, 下),
			// 总计消耗时间 - 事件玩家.joinTime / 3600 >= 2 ? 自定义字符串("") : 自定义字符串("")) : 自定义字符串(""), 总计消耗时间 - 事件玩家.joinTime > 59 ? 自定义字符串("{0}分{1} ", 取整(取整(总计消耗时间 - 事件玩家.joinTime, 上) % 3600 / 60,
			// 下), 取整(取整(总计消耗时间 - 事件玩家.joinTime, 上) % 3600 / 60, 下) != 1 ? 自定义字符串("") : 自定义字符串("")) : 自定义字符串(""), 自定义字符串("{0}秒{1}", 取整(总计消耗时间 - 事件玩家.joinTime, 上) % 60, 取整(
			// 总计消耗时间 - 事件玩家.joinTime, 上) % 60 != 1 ? 自定义字符串("") : 自定义字符串("")))));
			根据条件跳过(对任意为“真”(数组(事件玩家.dmgReduc, 事件玩家.invincible, 事件玩家.isPortalEnabled, 事件玩家.isAirWalkEnabled), 当前数组元素), 1);
			大字体信息(
				所有玩家(队伍1), 
				自定义字符串("祝贺 {0} 以 {1} 耗时 {2} 通关!", 
					事件玩家, 
					自定义字符串("{0} 次阵亡 & {1} 次跳过", 事件玩家.runDeathCount, 事件玩家.skipCount), 
					自定义字符串("{0}{1}{2}", 
						// 小时部分
						事件玩家.winnerTime != 空 && 事件玩家.winnerTime >= 3600 ? 
							自定义字符串("{0}小时", 取整(事件玩家.winnerTime / 3600, 下)) : 
							自定义字符串(""),
						
						// 分钟部分
						事件玩家.winnerTime != 空 && 事件玩家.winnerTime >= 60 ? 
							自定义字符串("{0}分", 取整((事件玩家.winnerTime % 3600) / 60, 下)) : 
							自定义字符串(""),
						
						// 秒部分
						事件玩家.winnerTime != 空 ? 
							自定义字符串("{0}秒", 取整(事件玩家.winnerTime % 60, 下)) : 
							自定义字符串("0秒")
					)
				)
			);
			小字体信息(事件玩家, 自定义字符串("  {0} 你已通关，可以加入聊天群 发送截图 获取通关称号", 图标字符串(对号)));
			调用子程序(savePlayerData);
	}
}

规则("winners earn their ult once per minute")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.isWinner != 假;
		终极技能充能百分比(事件玩家) < 100;
		正在使用终极技能(事件玩家) == 假;
	}

	动作
	{
		设置终极技能充能(事件玩家, 终极技能充能百分比(事件玩家) + 5);
		等待(3, 无视条件);
		如条件为“真”则循环;
	}
}

规则("initialize effects")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.hashTag = 真;
		全局.eventId = -1;
		等待(随机实数(1, 2), 无视条件);
		调用子程序(setDifficulty);
		"player HUD"
		禁用 创建HUD文本(所有玩家(所有队伍), 空, 空, 自定义字符串(
			" \n\n                                                                                                                        "),
			左边, 0, 空, 空, 空, 可见和字符串, 始终可见);
		创建HUD文本(本地玩家.heroNumber + 1 < 数量(全局.heroList) && 所用英雄(本地玩家) == 全局.heroList[本地玩家.heroNumber] ? 本地玩家 : 空, 自定义字符串("{0}: {1}", 自定义字符串(
			"阵亡"), 自定义字符串("{0} / {1}", 本地玩家.progressionDeathCount, 全局.difficulty != 5 ? 全局.maxDeath : 自定义字符串("∞"))), 自定义字符串(""), 空, 左边, 2, 颜色(白色), 空, 空, 可见和字符串, 默认可见度);
		创建HUD文本(本地玩家, 自定义字符串("{0}: {1}", 自定义字符串("英雄"), 自定义字符串("{0} / {1}", 数组值的索引(全局.heroList, 所用英雄(本地玩家)) + 1, 数量(全局.heroList))),
			自定义字符串(""), 空, 左边, 3, 颜色(白色), 空, 空, 可见和字符串, 默认可见度);
		根据条件跳过(全局.controlJumpPosition == 空 || 全局.portalPosition != 空, 1);
		创建HUD文本(本地玩家.isWinner || 所用英雄(本地玩家) != 全局.heroList[本地玩家.heroNumber] ? 空数组 : 本地玩家, 本地玩家.heroNumber + 1 < 数量(全局.heroList) ? 英雄图标字符串(
			全局.heroList[本地玩家.heroNumber + 1]) : 图标字符串(旗帜), 自定义字符串("下一个英雄"), 本地玩家.heroNumber + 1 < 数量(全局.heroList)
			? 全局.heroList[本地玩家.heroNumber + 1] : 自定义字符串("逃脱成功"), 左边, 4, 自定义颜色(36, 205, 244, 255), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(本地玩家.isWinner || 所用英雄(本地玩家) == 全局.heroList[本地玩家.heroNumber] ? 空数组 : 本地玩家, 图标字符串(拒绝), 自定义字符串("下一个英雄"), 自定义字符串(
			"{0} 已解锁！", 英雄图标字符串(全局.heroList[本地玩家.heroNumber])), 左边, 4, 自定义颜色(235, 45, 79, 255), 自定义颜色(235, 45, 79, 255), 自定义颜色(235,
			45, 79, 255), 可见和字符串, 默认可见度);
		创建HUD文本(本地玩家.isWinner ? 本地玩家 : 空, 图标字符串(对号), 自定义字符串("下一个英雄"), 自定义字符串("挑战完成"), 左边, 4, 颜色(绿色), 颜色(绿色), 颜色(绿色), 可见和字符串, 默认可见度);
		创建HUD文本(全局.hashTag ? 空 : 本地玩家, 空, 自定义字符串("成就挑战已禁用 {0}", 图标字符串(警告)), 空, 左边, 4, 空, 自定义颜色(160, 169, 186, 255), 空, 可见和字符串, 始终不可见);
		创建HUD文本(全局.difficulty != 5 ? 本地玩家 : 空, 空, 自定义字符串("本轮共计 {0} 次阵亡", 本地玩家.runDeathCount), 空, 左边, 5, 空, 自定义颜色(160,169,186,255), 空, 可见和字符串, 始终不可见);
		创建HUD文本(本地玩家, 空, 自定义字符串("本轮共计 {0} 次跳过", 本地玩家.skipCount), 空, 左边, 5, 空, 自定义颜色(160,169,186,255), 空, 可见和字符串, 始终不可见);
		// 根据条件跳过(全局.difficulty != 5, 3);
		创建HUD文本(全局.difficulty != 5 ? 空 : 本地玩家, 空, 自定义字符串("榴弹共计 {0} 点伤害", 取整(本地玩家.A36TGrenadeDmg, 上)), 空, 左边, 5, 空, 自定义颜色(160,169,186,255), 空, 可见和字符串, 始终不可见);
		创建HUD文本(全局.difficulty != 5 ? 空 : 本地玩家, 空, 自定义字符串("榴弹共计 {0}/{1} 命中/锁定", 本地玩家.A36TGrenadeHit, 本地玩家.A36TGrenade), 空, 左边, 5, 空, 自定义颜色(160,169,186,255), 空, 可见和字符串, 始终不可见);
		创建HUD文本(本地玩家.A36TGrenadeAlive == 真 ? 本地玩家 : 空, 空, 自定义字符串("大难不死 {0} ", 本地玩家.A36TGrenadeAlive == 真 ? 图标字符串(对号) : 空), 空, 左边, 100, 空, 自定义颜色(160,169,186,255), 空, 可见和字符串, 始终不可见);
		创建HUD文本(本地玩家.dlcTimeChallenge == 5 ? 本地玩家 : 空, 空, 自定义字符串("赌王 {0} ", 本地玩家.dlcTimeChallenge == 5 ? 图标字符串(对号) : 空), 空, 左边, 101, 空, 全局.heroColor[2], 空, 可见和字符串, 始终不可见);
		
		
		创建HUD文本(
			本地玩家.isWinner ? 本地玩家 : 空, 
			空, 
			自定义字符串("通关总计耗时 {0}", 
				自定义字符串("{0}{1}{2}", 
					// 小时部分
					本地玩家.winnerTime != 空 && 本地玩家.winnerTime >= 3600 ? 
						自定义字符串("{0} 小时", 取整(本地玩家.winnerTime / 3600, 下)) : 
						自定义字符串(""),
					
					// 分钟部分
					本地玩家.winnerTime != 空 && 本地玩家.winnerTime >= 60 ? 
						自定义字符串("{0} 分", 取整((本地玩家.winnerTime % 3600) / 60, 下)) : 
						自定义字符串(""),
					
					// 秒部分
					本地玩家.winnerTime != 空 ? 
						自定义字符串("{0} 秒", 取整(本地玩家.winnerTime % 60, 下)) : 
						自定义字符串("0 秒")
				)
			), 
			空, 
			左边, 
			51, 
			空, 
			自定义颜色(160,169,186,255), 
			空, 
			可见和字符串, 
			始终不可见
		);
		创建HUD文本(全局.difficulty != 5 && 本地玩家.progressionDeathCount == 全局.maxDeath ? 本地玩家 : 空, 空, 自定义字符串("[秘籍] 使用终极技能跳过({0}) ", 输入绑定字符串(按钮(终极技能))), 空, 左边, 6,
			空, 颜色(蓝色), 空, 可见和字符串, 默认可见度);
		"goal effects"
		等待(0.500, 无视条件);
		创建效果(所有玩家(队伍1), 环, 颜色(队伍1), 全局.endPosition, 4, 可见，位置和半径);
		创建效果(所有玩家(队伍1), 光柱, 颜色(队伍1), 全局.endPosition, 4, 可见，位置和半径);
		创建图标(全局.controlJumpPosition == 空 ? 所有玩家(队伍1) : 已过滤的数组(所有玩家(队伍1), 当前数组元素.controlJumpIndex == 单次赋值(数量(全局.controlRespawnPosition)) - 1), 全局.endPosition + 矢量(0, 5, 0), 旗帜, 可见和位置, 颜色(蓝色), 真);
		IF(全局.controlJumpPosition != 空);
			创建效果(所有玩家(队伍1), 环, 颜色(黄色), 首个(全局.controlJumpPosition), 4, 可见，位置和半径);
			创建效果(所有玩家(队伍1), 光柱, 颜色(黄色), 首个(全局.controlJumpPosition), 4, 可见，位置和半径);
			// 创建图标(所有玩家(所有队伍), 首个(全局.controlJumpPosition) + 矢量(0, 5, 0), 旗帜, 可见和位置, 颜色(蓝色), 真);
			创建图标(已过滤的数组(所有玩家(队伍1), 当前数组元素.controlJumpIndex == 0), 首个(全局.controlJumpPosition) + 矢量(0, 5, 0), 旗帜, 可见和位置, 颜色(黄色), 真);
			根据条件跳过(全局.controlJumpPosition[1] == 空, 3);
			创建效果(所有玩家(队伍1), 环, 颜色(绿色), 全局.controlJumpPosition[1], 4, 可见，位置和半径);
			创建效果(所有玩家(队伍1), 光柱, 颜色(绿色), 全局.controlJumpPosition[1], 4, 可见，位置和半径);
			创建图标(已过滤的数组(所有玩家(队伍1), 当前数组元素.controlJumpIndex == 1), 全局.controlJumpPosition[1] + 矢量(0, 5, 0), 旗帜, 可见和位置, 颜色(绿色), 真);
		END;
		"mode info"
		等待(0.500, 无视条件);
		IF(全局.controlJumpPosition != 空 && 单次赋值(全局.portalPosition) == 空);
			创建HUD文本(所有玩家(所有队伍), 空, 空, 全局.difficulty != 5 ? 自定义字符串("欢迎来到三合一大地图！你需要挑战所有小地图并到达终点！阵亡 {0} 次之后可跳过英雄", 全局.maxDeath) : 自定义字符串("欢迎来到三合一大地图！你需要挑战所有小地图并到达终点！当前难度无法跳过英雄，加油吧！"), 顶部, 0, 空, 空, 自定义颜色(255, 255, 255,
				125), 可见和字符串, 默认可见度);
		ELSE;
			创建HUD文本(所有玩家(所有队伍), 空, 空, 全局.difficulty != 5 ? 自定义字符串("使用全部英雄通关，一旦你解锁了一个英雄就可以在后续的游戏中随时使用！当阵亡 {0} 次之后可跳过英雄", 全局.maxDeath) : 自定义字符串("使用全部英雄通关！当前难度无法跳过英雄，加油吧！"), 顶部, 0, 空, 空, 自定义颜色(255, 255, 255,
				125), 可见和字符串, 默认可见度);
		END;
		创建HUD文本(所有玩家(所有队伍), 空, 自定义字符串("{0}代码：SVMQK | 500强交流群：445152554 | 加群给你喜欢的事件点赞 \n", 自定义字符串("")), 空, 顶部, 1, 空, 自定义颜色(255, 255, 255, 125), 空, 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 空, 空, 自定义字符串("{0}：{1}", 全局.__currentMapText__ == 空 ? 当前地图 : 全局.__currentMapText__, 首个(全局.difficultyText)), 右边, -6, 空, 空, 全局.difficultyText[1], 可见，字符串和颜色, 默认可见度);
		// 创建HUD文本(所有玩家(所有队伍), 空, 自定义字符串("{0}", 全局.__currentMapText__ == 空 ? 当前地图 : 全局.__currentMapText__), 空, 右边, -4, 空, 全局.difficultyText[1], 空, 可见，字符串和颜色, 默认可见度);
		IF(单次赋值(全局.dlcVishkarEvent));
			创建HUD文本(全局.eventId == -1 ? 空 : 本地玩家, 空, 自定义字符串("全局事件：{0} {1}（{2}）", 全局.eventType == 1 ? 技能图标字符串(英雄(黑影), 按钮(终极技能)) : 技能图标字符串(英雄(禅雅塔), 按钮(技能1)), 全局.eventName, 自定义字符串("{0}秒", 取整(全局.eventDurationHud, 上))), 空, 左边, 68, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
			创建HUD文本(全局.eventId == -1 ? 空 : 本地玩家, 空, 自定义字符串("{0} {1}", 全局.eventType == 1 ? 技能图标字符串(英雄(黑影), 按钮(终极技能)) : 技能图标字符串(英雄(禅雅塔), 按钮(技能1)), 全局.eventDesc), 空, 左边, 69, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
			创建HUD文本(本地玩家, 空, 自定义字符串("{0}/{1}/{2} 增益/减益/总计", 首个(本地玩家.eventCount), 本地玩家.eventCount[1], 本地玩家.eventCount[0] + 本地玩家.eventCount[1] + 本地玩家.eventCount[2]), 空, 左边, 5, 空, 自定义颜色(X方向分量(全局.heroColor[5]),Y方向分量(全局.heroColor[5]),Z方向分量(全局.heroColor[5]),255), 空, 可见和字符串, 始终不可见);

			创建HUD文本(所有玩家(所有队伍), 空, 自定义字符串("［随机事件］"), 空, 右边, -5, 空, 全局.difficultyText[1], 空, 可见，字符串和颜色, 默认可见度);
			创建HUD文本(本地玩家, 空, 自定义字符串(" \r\n\n"), 空, 左边, 69, 空, 空, 空, 字符串, 始终不可见);
			创建HUD文本(本地玩家.eventId == -1 ? 空 : 本地玩家, 空, 自定义字符串("{0} {1}（{2}）", 本地玩家.eventType == 1 ? 技能图标字符串(英雄(黑影), 按钮(终极技能)) : 技能图标字符串(英雄(禅雅塔), 按钮(技能1)), 本地玩家.eventName, 本地玩家.eventDuration > 0 ? 自定义字符串("{0}秒", 取整(本地玩家.eventDurationHud, 上)) : 自定义字符串("一次性")), 空, 左边, 70, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
			创建HUD文本(本地玩家.eventId == -1 ? 空 : 本地玩家, 空, 自定义字符串("{0} {1}", 本地玩家.eventType == 1 ? 技能图标字符串(英雄(黑影), 按钮(终极技能)) : 技能图标字符串(英雄(禅雅塔), 按钮(技能1)), 本地玩家.eventDesc), 空, 左边, 71, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		End;
		创建HUD文本(
			所有玩家(所有队伍), 
			空, 
			自定义字符串("距自动重开 {0}", 
				自定义字符串("{0}{1}{2}", 
					(全局.rebootTime - 总计消耗时间) > 3599 ? 
						自定义字符串("{0} 小时 ", 取整((全局.rebootTime - 总计消耗时间) / 3600, 下)) : 
						自定义字符串(""),
					(全局.rebootTime - 总计消耗时间) > 59 ? 
						自定义字符串("{0} 分 ", 取整(((全局.rebootTime - 总计消耗时间) % 3600) / 60, 下)) : 
						自定义字符串(""),
					自定义字符串("{0} 秒", 取整((全局.rebootTime - 总计消耗时间) % 60, 下))
				)
			), 
			空, 
			右边, 
			-4, 
			空, 
			// 颜色条件判断：剩余时间小于10分钟(600秒)显示黄色，否则灰色
			(全局.rebootTime - 总计消耗时间) <= 600 ? 颜色(黄色) : 颜色(灰色), 
			空, 
			可见，字符串和颜色, 
			默认可见度
		);
		创建HUD文本(
			全局.devPlayer, 
			空, 
			自定义字符串("已运行 {0}", 
				自定义字符串("{0}{1}{2}", 
					// 小时部分
					总计消耗时间 >= 3600 ? 
						自定义字符串("{0} 小时 ", 取整(总计消耗时间 / 3600, 下)) : 
						自定义字符串(""),
					
					// 分钟部分
					总计消耗时间 >= 60 ? 
						自定义字符串("{0} 分 ", 取整((总计消耗时间 % 3600) / 60, 下)) : 
						自定义字符串(""),
					
					// 秒部分
					自定义字符串("{0} 秒", 取整(总计消耗时间 % 60, 下))
				)
			), 
			空, 
			右边, 
			-4, 
			空, 
			颜色(灰色), 
			空, 
			可见和字符串, 
			默认可见度
		);
		创建HUD文本(全局.devPlayer, 空, 自定义字符串("  服务器负载 {0}", 服务器负载平均值), 空, 右边, -2, 空, 颜色(灰色), 空, 可见和字符串,
			始终不可见);
		创建HUD文本(所有玩家(所有队伍), 空, 自定义字符串("版本 26.0108.1"), 空, 右边, -3, 空, 颜色(灰色), 空, 可见和字符串, 始终不可见);
		创建效果(所有玩家(所有队伍), 有害光环, 颜色(水绿色), 全局.creditsPosition, 随机实数(1, 2), 可见);
		创建效果(所有玩家(所有队伍), 有害光环, 颜色(天蓝色), 全局.creditsPosition, 随机实数(1, 2), 可见);
		创建效果(所有玩家(所有队伍), 有害光环, 颜色(白色), 全局.creditsPosition, 随机实数(1, 2), 可见);
		
		等待(0.500, 无视条件);
		// 创建效果(本地玩家, 环, 颜色(亮紫色), 全局.heroRingPosition, 1.200, 可见);
		// 创建地图文本(本地玩家, 自定义字符串("      按{0}切换第三人称视角\n                    {1}", 输入绑定字符串(按钮(跳跃)), 图标字符串(箭头：向下)),
		// 	全局.heroRingPosition + 上 * 1.300, 1.200, 根据表面截取, 可见，位置和字符串, 颜色(白色), 默认可见度);
		"3rd person camera"
		创建效果(本地玩家, 环, 颜色(亮紫色), 全局.thirdPersonPosition, 1.200, 可见);
		创建地图文本(本地玩家, 自定义字符串("      按{0}切换第三人称视角\n                    {1}", 输入绑定字符串(按钮(跳跃)), 图标字符串(箭头：向下)),
			全局.thirdPersonPosition + 上 * 1.300, 1.200, 根据表面截取, 可见，位置和字符串, 颜色(白色), 默认可见度);
		"reset progress ring"
		等待(0.500, 无视条件);
		创建效果(本地玩家.heroNumber > 0 || 本地玩家.runDeathCount > 0 ? 本地玩家 : 空, 环, 颜色(红色), 全局.resetPosition, 1.200, 可见);
		创建地图文本(本地玩家.heroNumber > 0 || 本地玩家.runDeathCount > 0 ? 本地玩家 : 空, 自定义字符串("重置进度\n                {0}", 图标字符串(箭头：向下)),
			全局.resetPosition + 上 * 1.300, 1.200, 根据表面截取, 可见，位置和字符串, 颜色(白色), 默认可见度);
		IF(全局.springBoardPosition != 空);
			创建效果(本地玩家, 环, 颜色(绿色), 全局.springBoardPosition, 1.200, 可见);
			创建地图文本(本地玩家, 自定义字符串("      按{0}向上弹射\n                    {1}", 输入绑定字符串(按钮(跳跃)), 图标字符串(箭头：向下)),
			全局.springBoardPosition + 上 * 1.300, 1.200, 根据表面截取, 可见，位置和字符串, 颜色(白色), 默认可见度);
		END;
		// "3rd person camera"
		// 等待(0.500, 无视条件);
		// 创建效果(本地玩家.heroNumber > 0 || 本地玩家.runDeathCount > 0 ? 本地玩家 : 空, 环, 颜色(红色), 全局.thirdPersonPosition, 1.200, 可见);
		// 创建地图文本(本地玩家.heroNumber > 0 || 本地玩家.runDeathCount > 0 ? 本地玩家 : 空, 自定义字符串("按{0}第三人称视角\n                {1}", 图标字符串(箭头：向下)),
		// 	全局.thirdPersonPosition + 上 * 1.300, 1.200, 根据表面截取, 可见，位置和字符串, 颜色(白色), 默认可见度);
	}
}

规则("initialize player nano effects")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.hasNano == 真;
	}

	动作
	{
		根据条件跳过(事件玩家.nanoEffect != 空, 2);
		创建效果(所有玩家(所有队伍), 安娜纳米激素强化效果, 颜色(队伍2), 事件玩家, 200, 可见，位置和半径);
		事件玩家.nanoEffect = 最后创建的实体;
		// 全局.berserkerPosition = 所选位置(事件玩家);
		设置状态(事件玩家, 空, 燃烧, 60);
		等待直到 (全局.berserkerTime == 0 || !事件玩家.hasNano, 60);
		事件玩家.hasNano = 假;
		// 全局.berserkerPosition = 空;
		清除状态(事件玩家, 燃烧);
		消除效果(事件玩家.nanoEffect);
		事件玩家.nanoEffect = 空;
	}
}

规则("bastion counts kills and marks himself after killing you")
{
	事件
	{
		玩家造成最后一击;
		队伍2;
		全部;
	}

	动作
	{
		全局.kills[栏位(事件玩家)] += 1;
		开始为机器人强制设置名称(事件玩家, 自定义字符串("看守{0} 击杀{1}", 栏位(事件玩家) + 1, 全局.kills[栏位(事件玩家)]));
		停止强制设置玩家轮廓(被攻击方.attacker, 被攻击方);
		等待(0.032, 无视条件);
		被攻击方.attacker = 攻击方;
		开始强制设置玩家轮廓(被攻击方.attacker, 被攻击方, 真, 颜色(红色), 总是);
	}
}

规则("create baby d.va goal header")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		正在使用英雄(英雄(D.Va), 队伍1) == 真;
	}

	动作
	{
		等待(2, 当为“假”时中止);
		创建HUD文本(所用英雄(本地玩家) == 英雄(D.Va) && 处于非初始状态(本地玩家) && 存活(本地玩家) && 本地玩家.dvaStart != 0 ? 本地玩家 : 空, 自定义字符串("目标距离:{0} m", 较大(0,
			30 - 相距距离(所选位置(本地玩家) * 矢量(1, 0, 1), 本地玩家.dvaStart * 矢量(1, 0, 1)))), 空, 空, 顶部, 5, 颜色(白色), 空, 空, 可见和字符串, 默认可见度);
		全局.textIDs[1] = 上一个文本ID;
		等待直到 (!正在使用英雄(英雄(D.Va), 队伍1), 9999);
		消除HUD文本(全局.textIDs[1]);
	}
}

规则("create ana sleep timer and instructions")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		正在使用英雄(英雄(安娜), 队伍1) == 真;
	}

	动作
	{
		创建HUD文本(所用英雄(本地玩家) == 英雄(安娜) && 在重生室中(本地玩家) ? 本地玩家 : 空, 自定义字符串(
			"{0} 麻醉镖限制: \n 每个堡垒每 {1} 秒只能被麻醉一次", 技能图标字符串(英雄(安娜), 按钮(技能1)), 30), 空, 空, 顶部, 5,
			颜色(白色), 空, 空, 可见, 默认可见度);
		等待(0.016, 无视条件);
		全局.textIDs[4] = 上一个文本ID;
		全局.textIDs[3] = 映射的数组(全局.bastionPosition, 0);
		For 全局变量(I, 0, 数量(全局.bastionPosition), 1);
			创建进度条地图文本(所用英雄(本地玩家) == 英雄(安娜) && 总计消耗时间 - 本地玩家.anaSleepLimit[单次赋值(全局.I)] < 30 && 相距距离(相距距离(眼睛位置(本地玩家), 全局.bastionPosition[单次赋值(
				全局.I)]) * 面朝方向(本地玩家) + 眼睛位置(本地玩家), 全局.bastionPosition[单次赋值(全局.I)]) <= 4 ? 本地玩家 : 空, (30 - (总计消耗时间 - 本地玩家.anaSleepLimit[单次赋值(
				全局.I)])) / 30 * 100, 自定义字符串("麻醉限制: 剩余 {0} 秒 ", 较小(30, 30 - 取整(总计消耗时间 - 本地玩家.anaSleepLimit[单次赋值(全局.I)], 下))),
				全局.bastionPosition[单次赋值(全局.I)], 1, 不要截取, 颜色(蓝色), 颜色(白色), 可见和值, 默认可见度);
			全局.textIDs[3] = 映射的数组(全局.textIDs[3], 当前数组索引 == 全局.I ? 上一个文本ID : 当前数组元素);
		End;
		等待直到 (!正在使用英雄(英雄(安娜), 队伍1), 9999);
		For 全局变量(I, 0, 数量(全局.textIDs[3]), 1);
			消除进度条地图文本(全局.textIDs[3][全局.I]);
		End;
		消除HUD文本(全局.textIDs[4]);
	}
}

禁用 规则("create zen instructions")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		正在使用英雄(英雄(禅雅塔), 队伍1) == 真;
	}

	动作
	{
		创建HUD文本(所用英雄(本地玩家) == 英雄(禅雅塔) && 在重生室中(本地玩家) ? 本地玩家 : 空, 自定义字符串(
			"踹击地面可以向后击退 {0}\n按住跳跃可以悬浮 {1}", 技能图标字符串(英雄(禅雅塔), 按钮(近身攻击)), 图标字符串(箭头：向上)), 空, 空, 顶部,
			5, 颜色(白色), 空, 空, 可见, 默认可见度);
		全局.textIDs[2] = 上一个文本ID;
		等待直到 (!正在使用英雄(英雄(禅雅塔), 队伍1), 9999);
		消除HUD文本(全局.textIDs[2]);
	}
}

禁用 规则("[JunkerQueen]: Fix Commanding Shout cd")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		渣客女王;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		等待直到(!正在使用技能 1(事件玩家), 12.16);
		设置技能冷却(事件玩家, 按钮(技能1), 4);
	}
}

禁用 规则("update scoreboard every few seconds")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		首个(所有玩家(队伍1)) != 假;
	}

	动作
	{
		全局.scoreboardArray = 已排序的数组(已过滤的数组(所有玩家(队伍1), !当前数组元素.isWinner), 0 - 当前数组元素.heroNumber);
		全局.firstPlace = 首个(全局.scoreboardArray);
		全局.secondPlace = 全局.scoreboardArray[1];
		全局.thirdPlace = 全局.scoreboardArray[2];
		等待(服务器负载平均值 / 50, 无视条件);
		如条件为“真”则循环;
	}
}

// 禁用 规则("outline devs who made or edited this mode, using random colors")
// {
// 	事件
// 	{
// 		持续 - 每名玩家;
// 		队伍1;
// 		全部;
// 	}

// 	条件
// 	{
// 		事件玩家.isDev == 真;
// 		事件玩家.rainbowOff == 假;
// 	}

// 	动作
// 	{
// 		开始强制设置玩家轮廓(事件玩家, 所有玩家(所有队伍), 真, 自定义颜色(随机实数(0, 255), 随机实数(0, 255), 随机实数(0, 255), 255), 总是);
// 		等待(0.128, 无视条件);
// 		如条件为“真”则循环;
// 	}
// }

禁用 规则("devs can toggle rainbow effect")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
	}

	动作
	{
		事件玩家.rainbowOff = 事件玩家.rainbowOff ? 假 : 真;
		停止强制设置玩家轮廓(事件玩家, 所有玩家(所有队伍));
		小字体信息(事件玩家, 自定义字符串("DEV 特效{0}", 事件玩家.rainbowOff ? 自定义字符串("关闭") : 自定义字符串("开启")));
	}
}

规则("outline winners in green periodically")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.isWinner != 假;
		存活(事件玩家) == 真;
	}

	动作
	{
		等待(服务器负载平均值 / 100, 无视条件);
		开始强制设置玩家轮廓(事件玩家, 所有玩家(队伍1), 真, 颜色(绿色), 总是);
		等待(30, 当为“真”时重新开始);
		如条件为“真”则循环;
	}
}

规则("outline winners for new players as soon as they join")
{
	事件
	{
		玩家加入比赛;
		队伍1;
		全部;
	}

	条件
	{
		对任意为“真”(所有玩家(队伍1), 当前数组元素.isWinner) == 真;
	}

	动作
	{
		等待(服务器负载平均值 / 100, 无视条件);
		开始强制设置玩家轮廓(已过滤的数组(所有玩家(队伍1), 当前数组元素.isWinner), 事件玩家, 真, 颜色(绿色), 总是);
	}
}

规则("stop outline for non-winners")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.isWinner == 假;
	}

	动作
	{
		等待(服务器负载平均值 / 100, 无视条件);
		停止强制设置玩家轮廓(事件玩家, 所有玩家(队伍1));
	}
}

规则("increment death counter (progressionDeathCount) on death")
{
	事件
	{
		玩家阵亡;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(
			所用英雄(事件玩家) == 全局.heroList[事件玩家.heroNumber], 
			事件玩家.progressionDeathCount < 全局.maxDeath, 
			事件玩家.heroNumber + 1 < 数量(全局.heroList),
			攻击方 != 空,
			攻击方 != 事件玩家
		), 当前数组元素) == 真;
	}

	动作
	{
		事件玩家.progressionDeathCount += 1;
	}
}

规则("display death progress as ult charge")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.difficulty != 5; // 地狱难度不使用此规则
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 事件玩家.eventType == 0, 事件玩家.eventId == 23), 当前数组元素) == 假;
		事件玩家.progressionDeathCount < 全局.maxDeath;
		事件玩家.isWinner == 假;
		(所用英雄(事件玩家) == 英雄(D.Va) && 处于非初始状态(事件玩家)) == 假;
		取整(终极技能充能百分比(事件玩家) / (100 / 全局.maxDeath), 至最近) != 事件玩家.progressionDeathCount;
		
	}

	动作
	{
		等待(随机实数(0.100, 0.500) * 服务器负载平均值 / 100, 当为“假”时中止);
		设置终极技能充能(事件玩家, 100 * 事件玩家.progressionDeathCount / 全局.maxDeath);
		如条件为“真”则循环;
	}
}

规则("display message if hero available")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.difficulty != 5; // 地狱难度不使用此规则
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 事件玩家.eventType == 0, 事件玩家.eventId == 23), 当前数组元素) != 真;
		事件玩家.progressionDeathCount == 全局.maxDeath;
		事件玩家.heroNumber + 1 < 数量(全局.heroList);
		(所用英雄(事件玩家) == 英雄(D.Va) && 处于非初始状态(事件玩家)) == 假;
		存活(事件玩家) == 真;
	}

	动作
	{
		等待(服务器负载 / 100, 无视条件);
		If(终极技能充能百分比(事件玩家) == 100);
			设置终极技能充能(事件玩家, 0);
			等待(0.200, 无视条件);
		End;
		大字体信息(事件玩家, 自定义字符串("可跳过当前英雄"));
		事件玩家.I = 0;
		While(终极技能充能百分比(事件玩家) != 100);
			设置终极技能充能(事件玩家, 100);
			等待(0.050, 无视条件);
			事件玩家.I += 1;
			根据条件中止(全局.I == 5);
		End;
	}
}

规则("players can use ultimate to progress to the next hero after dying a number of times (maxDeath)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.difficulty != 5; // 地狱难度不使用此规则
		事件玩家.progressionDeathCount >= 全局.maxDeath;
		(正在使用终极技能(事件玩家) || 正在人格复制(事件玩家)) == 真;
		事件玩家.heroNumber + 1 < 数量(全局.heroList);
		所用英雄(事件玩家) != 英雄(堡垒);
	}

	动作
	{
		等待(1, 无视条件);
		复生(事件玩家);
		事件玩家.progressionDeathCount = 0;
		事件玩家.skipCount += 1;
		调用子程序(progressHero);
	}
}

// 禁用 规则("display instructions when a player enters the hero change ring")
// {
// 	事件
// 	{
// 		持续 - 每名玩家;
// 		队伍1;
// 		全部;
// 	}

// 	条件
// 	{
// 		事件玩家.heroNumber > 0;
// 		相距距离(所选位置(事件玩家) * 矢量(1, 0, 1), 全局.heroRingPosition * 矢量(1, 0, 1)) <= 1.200;
// 		数组包含(范围内玩家(全局.heroRingPosition, 20, 队伍1, 关闭), 事件玩家) == 真;
// 	}

// 	动作
// 	{
// 		大字体信息(事件玩家, 自定义字符串("   跳跃:下一个英雄 下蹲:上一个英雄"));
// 	}
// }

// 禁用 规则("pressing jump while in the hero change ring makes you the next available hero")
// {
// 	事件
// 	{
// 		持续 - 每名玩家;
// 		队伍1;
// 		全部;
// 	}

// 	条件
// 	{
// 		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
// 		事件玩家.heroNumber > 0;
// 		相距距离(事件玩家 * 矢量(1, 0, 1), 全局.heroRingPosition * 矢量(1, 0, 1)) <= 1.200;
// 	}

// 	动作
// 	{
// 		禁用按钮(事件玩家, 按钮(跳跃));
// 		While(按钮被按下(事件玩家, 按钮(跳跃)) && 相距距离(事件玩家 * 矢量(1, 0, 1), 全局.heroRingPosition * 矢量(1, 0, 1)) <= 1.200 && 事件玩家.heroNumber > 0);
// 			If(所用英雄(事件玩家) == 全局.heroList[事件玩家.heroNumber]);
// 				小字体信息(事件玩家, 自定义字符串("  英雄不可用"));
// 			Else;
// 				开始强制玩家选择英雄(事件玩家, 全局.heroList[数组值的索引(全局.heroList, 所用英雄(事件玩家)) + 1]);
// 				停止强制玩家选择英雄(事件玩家);
// 			End;
// 			等待(0.800, 无视条件);
// 		End;
// 		可用按钮(事件玩家, 按钮(跳跃));
// 	}
// }

规则("display instructions when a player enters the reset ring")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		(事件玩家.heroNumber > 0 || 事件玩家.runDeathCount > 0) == 真;
		数组包含(范围内玩家(全局.resetPosition, 20, 队伍1, 关闭), 事件玩家) == 真;
		相距距离(所选位置(事件玩家) * 矢量(1, 0, 1), 全局.resetPosition * 矢量(1, 0, 1)) <= 1.200;
	}

	动作
	{
		大字体信息(事件玩家, 自定义字符串("长按装填键重置"));
	}
}

规则("holding rel﻿oad while in the reset ring resets your progress")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		(事件玩家.runDeathCount > 0 || 事件玩家.heroNumber > 0) == 真;
		相距距离(事件玩家 * 矢量(1, 0, 1), 全局.resetPosition * 矢量(1, 0, 1)) <= 1.200;
	}

	动作
	{
		预加载英雄(事件玩家, 首个(全局.heroList));
		小字体信息(事件玩家, 自定义字符串("  正在重置进度..."));
		等待(2, 当为“假”时中止);
		播放效果(事件玩家, 负面状态施加声音, 空, 所选位置(事件玩家), 100);
		事件玩家.runDeathCount = 0;
		事件玩家.progressionDeathCount = 0;
		事件玩家.isWinner = 假;
		事件玩家.winnerTime = 0;
		事件玩家.heroNumber = 0;
		事件玩家.skipCount = 0;
		小字体信息(所有玩家(所有队伍), 自定义字符串("  {0} 重置了进度", 事件玩家));
		等待(0.016, 无视条件);
		开始强制玩家选择英雄(事件玩家, 首个(全局.heroList));
		等待(0.016, 无视条件);
		停止强制玩家选择英雄(事件玩家);
		等待(服务器负载 / 100 * 0.500, 无视条件);
		设置玩家可选的英雄(事件玩家, 数组分割(全局.heroList, 0, 事件玩家.heroNumber + 1));
		调用子程序(savePlayerData);
	}
}

// 禁用 规则("pressing crouch while in the hero change ring makes you the previous available hero")
// {
// 	事件
// 	{
// 		持续 - 每名玩家;
// 		队伍1;
// 		全部;
// 	}

// 	条件
// 	{
// 		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
// 		事件玩家.heroNumber > 0;
// 		相距距离(事件玩家 * 矢量(1, 0, 1), 全局.heroRingPosition * 矢量(1, 0, 1)) <= 1.200;
// 	}

// 	动作
// 	{
// 		If(数组值的索引(全局.heroList, 所用英雄(事件玩家)) < 1);
// 			小字体信息(事件玩家, 自定义字符串("英雄不可用"));
// 		Else;
// 			开始强制玩家选择英雄(事件玩家, 全局.heroList[数组值的索引(全局.heroList, 所用英雄(事件玩家)) - 1]);
// 			停止强制玩家选择英雄(事件玩家);
// 		End;
// 		等待(0.800, 无视条件);
// 		如条件为“真”则循环;
// 	}
// }

规则("3rd person")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		相距距离(事件玩家 * 矢量(1, 0, 1), 全局.thirdPersonPosition * 矢量(1, 0, 1)) <= 1.200;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		存活(事件玩家) == 真;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 无视条件);
		调用子程序(setThirdPerson);
	}
}

规则("springboard")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		单次赋值(全局.springBoardPosition) != 空;
		相距距离(事件玩家 * 矢量(1, 0, 1), 全局.springBoardPosition * 矢量(1, 0, 1)) <= 1.200;
		Y方向分量(所选位置(事件玩家)) >= Y方向分量(全局.springBoardPosition);
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		存活(事件玩家) == 真;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 当为“假”时中止);
		播放效果(所有玩家(所有队伍), 环状爆炸声音, 颜色(白色), 事件玩家, 200);
		施加推力(事件玩家, 上, 14, 至玩家, 取消相反运动XYZ);
		等待(0.032, 无视条件);
		施加推力(事件玩家, 地图矢量(前, 事件玩家, 旋转), 3.500, 至地图, 取消相反运动XYZ);
		等待(5, 无视条件);
	}
}

规则("portalPosition")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		单次赋值(全局.portalPosition) != 空;
		相距距离(事件玩家 * 矢量(1, 0, 1), 首个(全局.portalPosition) * 矢量(1, 0, 1)) <= 1.200;
		Y方向分量(所选位置(事件玩家)) >= Y方向分量(首个(全局.portalPosition));
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		存活(事件玩家) == 真;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 当为“假”时中止);
		播放效果(所有玩家(所有队伍), 环状爆炸声音, 颜色(白色), 事件玩家, 200);
		传送(事件玩家, 最近的可行走位置(最后(全局.portalPosition)));
		等待(5, 无视条件);
	}
}

规则("dev menu in game")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		禁用 (单次赋值(数组包含(全局.devList, 自定义字符串("{0}", 事件玩家))) != 假 || 主机玩家 == 事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		禁用 (所用英雄(事件玩家) == 英雄(生命之梭) || 所用英雄(事件玩家) == 英雄(秩序之光)) == 假;
	}

	动作
	{
		根据条件中止((按钮被按下(事件玩家, 按钮(互动)) && 按钮被按下(事件玩家, 按钮(蹲下))) == 真);
		根据条件跳过(事件玩家.menu != 0, 11);
		禁用按钮(事件玩家, 按钮(主要攻击模式));
		禁用按钮(事件玩家, 按钮(辅助攻击模式));
		禁用按钮(事件玩家, 按钮(技能1));
		禁用按钮(事件玩家, 按钮(技能2));
		禁用按钮(事件玩家, 按钮(终极技能));
		禁用按钮(事件玩家, 按钮(跳跃));
		禁用按钮(事件玩家, 按钮(蹲下));
		禁用按钮(事件玩家, 按钮(近身攻击));
		禁用按钮(事件玩家, 按钮(装填));
		事件玩家.menu = 1;
		中止;
		事件玩家.menu = 0;
		消除HUD文本(事件玩家.menuTextID[0]);
		消除HUD文本(事件玩家.menuTextID[1]);
		消除HUD文本(事件玩家.menuTextID[2]);
		可用按钮(事件玩家, 按钮(主要攻击模式));
		// 根据条件跳过(所用英雄(事件玩家) == 英雄(生命之梭), 1);
		可用按钮(事件玩家, 按钮(辅助攻击模式));
		// 根据条件跳过(所用英雄(事件玩家) == 英雄(美), 4);
		可用按钮(事件玩家, 按钮(技能1));
		// 根据条件跳过(所用英雄(事件玩家) == 英雄(伊拉锐) || 所用英雄(事件玩家) == 英雄(骇灾), 1);
		可用按钮(事件玩家, 按钮(技能2));
		可用按钮(事件玩家, 按钮(终极技能));
		可用按钮(事件玩家, 按钮(跳跃));
		可用按钮(事件玩家, 按钮(近身攻击));
		可用按钮(事件玩家, 按钮(装填));
		// 根据条件中止(所用英雄(事件玩家) == 英雄(破坏球) == 真);
		可用按钮(事件玩家, 按钮(蹲下));
	}
}


规则("dev menu disable")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		禁用 (单次赋值(数组包含(全局.devList, 自定义字符串("{0}", 事件玩家))) != 假 || 主机玩家 == 事件玩家) == 真;
		事件玩家.menu == 0;
	}

	动作
	{
		消除HUD文本(事件玩家.menuTextID[0]);
		消除HUD文本(事件玩家.menuTextID[1]);
		消除HUD文本(事件玩家.menuTextID[2]);
		可用按钮(事件玩家, 按钮(主要攻击模式));
		// 根据条件跳过(所用英雄(事件玩家) == 英雄(生命之梭), 1);
		可用按钮(事件玩家, 按钮(辅助攻击模式));
		// 根据条件跳过(所用英雄(事件玩家) == 英雄(美), 4);
		可用按钮(事件玩家, 按钮(技能1));
		// 根据条件跳过(所用英雄(事件玩家) == 英雄(伊拉锐) || 所用英雄(事件玩家) == 英雄(骇灾), 1);
		可用按钮(事件玩家, 按钮(技能2));
		可用按钮(事件玩家, 按钮(终极技能));
		可用按钮(事件玩家, 按钮(跳跃));
		可用按钮(事件玩家, 按钮(近身攻击));
		可用按钮(事件玩家, 按钮(装填));
		// 根据条件中止(所用英雄(事件玩家) == 英雄(破坏球) == 真);
		可用按钮(事件玩家, 按钮(蹲下));
	}
}

// 禁用 规则("page up in dev menu")
// {
// 	事件
// 	{
// 		持续 - 每名玩家;
// 		双方;
// 		全部;
// 	}

// 	条件
// 	{
// 		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
// 		事件玩家.isDev == 真;
// 		事件玩家.menu != 0;
// 	}

// 	动作
// 	{
// 		事件玩家.menu += 1;
// 		中止;
// 		事件玩家.menu = 4;
// 	}
// }

规则("page down in dev menu")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		事件玩家.menu != 0;
	}

	动作
	{
		根据条件跳过(事件玩家.menu >= 3, 2);
		事件玩家.menu += 1;
		中止;
		事件玩家.menu = 1;
	}
}

规则("menu mode settings display")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.menu == 1;
		禁用 (单次赋值(数组包含(全局.devList, 自定义字符串("{0}", 事件玩家))) != 假 || 主机玩家 == 事件玩家) == 真;
	}

	动作
	{
		消除HUD文本(事件玩家.menuTextID[0]);
		消除HUD文本(事件玩家.menuTextID[1]);
		消除HUD文本(事件玩家.menuTextID[2]);
		创建HUD文本(事件玩家, 自定义字符串("{0}", 事件玩家.isDev ? 自定义字符串("开发者模式") : 自定义字符串("游戏内面板")), 空, 空, 顶部, 2, 颜色(白色), 颜色(白色), 颜色(白色), 可见，字符串和颜色,
			始终不可见);
		事件玩家.menuTextID[0] = 上一个文本ID;
		IF(事件玩家.isDev);
			创建HUD文本(事件玩家, 空, 自定义字符串("{0}    自动重开：延长5分钟    \n{1}", 输入绑定字符串(按钮(主要攻击模式)), 
				自定义字符串("{0}    自动重开：缩短5分钟    \n{1}", 输入绑定字符串(按钮(辅助攻击模式)),
					自定义字符串("{0}    上一个称号    \n{1}", 输入绑定字符串(按钮(终极技能)), 
						自定义字符串("{0}    下一个称号    \n{1}", 输入绑定字符串(按钮(技能2)),
							自定义字符串("{0}    增加难度    \n{1}", 输入绑定字符串(按钮(技能1)),
								自定义字符串("{0}    降低难度    \n{1}", 输入绑定字符串(按钮(装填)),
									自定义字符串("{0}    第三人称视角    {1}\n{2}", 输入绑定字符串(按钮(跳跃)), 事件玩家.third == 真 ? 自定义字符串("O") : 自定义字符串("X"),
										自定义字符串("{0}    下一页    ", 输入绑定字符串(按钮(蹲下)))
									)
								)
							)
						)
					)
				)
			), 空, 顶部, 3, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
		ELSEIF(主机玩家 == 事件玩家);
			创建HUD文本(事件玩家, 空, 自定义字符串("{0}    自动重开：延长5分钟    \n{1}", 输入绑定字符串(按钮(主要攻击模式)), 
				自定义字符串("{0}    自动重开：缩短5分钟    \n{1}", 输入绑定字符串(按钮(辅助攻击模式)),
					自定义字符串("{0}    上一个称号    \n{1}", 输入绑定字符串(按钮(终极技能)), 
						自定义字符串("{0}    下一个称号    \n{1}", 输入绑定字符串(按钮(技能2)),
							自定义字符串("{0}    标记玩家    {1}\n{2}", 输入绑定字符串(按钮(技能1)), 全局.targetPlayer != 空 ? 自定义字符串("{0}（{1}）", 全局.targetPlayer, 所用英雄(全局.targetPlayer)) : 自定义字符串("空"),
								自定义字符串("{0}    移除标记玩家并临时拉黑    \n{1}", 输入绑定字符串(按钮(装填)),
									自定义字符串("{0}    第三人称视角    {1}\n", 输入绑定字符串(按钮(跳跃)), 事件玩家.third == 真 ? 自定义字符串("O") : 自定义字符串("X"),
									自定义字符串("{0}    下一页    ", 输入绑定字符串(按钮(蹲下)))
									)
								)
							)
						)
					)
				)
			), 空, 顶部, 3, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
		ELSE;
			创建HUD文本(事件玩家, 空, 自定义字符串("{0}    上一个称号    \n{1}", 输入绑定字符串(按钮(终极技能)), 
				自定义字符串("{0}    下一个称号    \n{1}", 输入绑定字符串(按钮(技能2)),
					自定义字符串("{0}    第三人称视角    {1}\n", 输入绑定字符串(按钮(跳跃)), 事件玩家.third == 真 ? 自定义字符串("O") : 自定义字符串("X"),
						自定义字符串("{0}    下一页    ", 输入绑定字符串(按钮(蹲下)))
					)
				)
			), 空, 顶部, 3, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
		END;
		事件玩家.menuTextID[1] = 上一个文本ID;
	}
}

规则("menu dev control display")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 2;
	}

	动作
	{
		消除HUD文本(事件玩家.menuTextID[0]);
		消除HUD文本(事件玩家.menuTextID[1]);
		消除HUD文本(事件玩家.menuTextID[2]);
		创建HUD文本(事件玩家, 自定义字符串("开发者模式"), 空, 空, 顶部, 2, 颜色(白色), 颜色(白色), 颜色(白色), 可见，字符串和颜色,
			始终不可见);
		事件玩家.menuTextID[0] = 上一个文本ID;
		创建HUD文本(事件玩家, 空, 自定义字符串("{0}    Debug 信息    {1}\n{2}", 输入绑定字符串(按钮(主要攻击模式)), 全局.debugInfo ? 自定义字符串("O") : 自定义字符串("X"), 
			自定义字符串("{0}    解锁全英雄    {1}\n{2}", 输入绑定字符串(按钮(辅助攻击模式)), 事件玩家.isWinner == 真 ? 自定义字符串("O") : 自定义字符串("X"), 
				自定义字符串("{0}    立即重开    \n{1}", 输入绑定字符串(按钮(装填)), 
					自定义字符串("{0}    标记玩家    {1}\n{2}", 输入绑定字符串(按钮(跳跃)), 全局.targetPlayer != 空 ? 自定义字符串("{0}（{1}）", 全局.targetPlayer, 所用英雄(全局.targetPlayer)) : 自定义字符串("空"),
						自定义字符串("{0}    移除标记玩家    \n{1}", 输入绑定字符串(按钮(终极技能)),
							自定义字符串("{0}    传送到标记玩家    \n{1}", 输入绑定字符串(按钮(技能2)),
								自定义字符串("{0}    受到伤害降低    {1}\n{2}", 输入绑定字符串(按钮(近身攻击)), 事件玩家.dmgReduc == 真 ? 自定义字符串("O") : 自定义字符串("X"),
									自定义字符串("{0}    无敌    {1}\n{2}", 输入绑定字符串(按钮(技能1)), 事件玩家.invincible == 真 ? 自定义字符串("O") : 自定义字符串("X"),
										自定义字符串("{0}    下一页    ", 输入绑定字符串(按钮(蹲下)))
									)
								)
							)
						)
					)
				)
			)
		), 空, 顶部, 3, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
		事件玩家.menuTextID[1] = 上一个文本ID;
	}
}

规则("menu dev devlop display")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 3;
	}

	动作
	{
		消除HUD文本(事件玩家.menuTextID[0]);
		消除HUD文本(事件玩家.menuTextID[1]);
		消除HUD文本(事件玩家.menuTextID[2]);
		创建HUD文本(事件玩家, 自定义字符串("开发者面板"), 空, 空, 顶部, 2, 颜色(白色), 颜色(白色), 颜色(白色), 可见，字符串和颜色,
			始终不可见);
		事件玩家.menuTextID[0] = 上一个文本ID;
		创建HUD文本(事件玩家, 空, 自定义字符串("{0}    浮空    {1}\n{2}", 输入绑定字符串(按钮(主要攻击模式)), 事件玩家.isAirWalkEnabled ? 自定义字符串("O") : 自定义字符串("X"), 
			自定义字符串("{0}    穿墙    {1}\n{2}", 输入绑定字符串(按钮(辅助攻击模式)), 事件玩家.isPortalEnabled == 真 ? 自定义字符串("O") : 自定义字符串("X"), 
				自定义字符串("{0}    选择目标点索引    {1}\n{2}", 输入绑定字符串(按钮(技能1)), 事件玩家.controlCenterIndex,
					自定义字符串("{0}    传送到目标点    \n{1}", 输入绑定字符串(按钮(技能2)),
						自定义字符串("{0}    下一页    ", 输入绑定字符串(按钮(蹲下)))
					)
				)
			)
		), 空, 顶部, 3, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
		事件玩家.menuTextID[1] = 上一个文本ID;
	}
}

规则("3rd camera toggle")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		禁用 事件玩家.isDev == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		事件玩家.menu == 1;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 无视条件);
		调用子程序(setThirdPerson);
	}
}

规则("dev debug mode toggle")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
		事件玩家.menu == 2;
	}

	动作
	{
		全局.debugInfo = !全局.debugInfo;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		// 事件玩家.debugInfo = !事件玩家.debugInfo;
		全局.devPlayer.debugInfo = 全局.debugInfo;
	}
}

规则("dev set difficulty")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.difficulty < 5;
		事件玩家.menu == 1;
		事件玩家.isDev == 真;
		按钮被按下(事件玩家, 按钮(技能1)) == 真;
	}

	动作
	{
		全局.difficulty += 1;
		调用子程序(setDifficulty);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		小字体信息(全局.devPlayer, 自定义字符串("  {0}  开发者模式： 已将难度设置为 {1}({2})", 图标字符串(箭矢), 首个(全局.difficultyText), 全局.difficulty));
		// 等待(服务器负载 / 100 * 0.032, 无视条件);
		// 小字体信息(全局.devPlayer, 自定义字符串("  {0}  成就挑战已禁用", 图标字符串(警告)));
	}
}

规则("dev set difficulty")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.difficulty > 0;
		事件玩家.menu == 1;
		事件玩家.isDev == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
	}

	动作
	{
		全局.difficulty -= 1;
		调用子程序(setDifficulty);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		小字体信息(全局.devPlayer, 自定义字符串("  {0}  开发者模式： 已将难度设置为 {1}({2})", 图标字符串(箭矢), 首个(全局.difficultyText), 全局.difficulty));
	}
}

规则("dev add auto reboot time")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.menu == 1;
		(事件玩家.isDev || 主机玩家 == 事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
	}

	动作
	{
		If(全局.rebootTime + 300 <= 15900);
			全局.rebootTime += 300;
			IF(事件玩家.isDev);
				小字体信息(全局.devPlayer, 自定义字符串("  {0}  开发者模式： 已将自动重开时间延长 {1} 分钟", 图标字符串(箭矢), 300 / 60));
			Else;
				小字体信息(所有玩家(所有队伍), 自定义字符串("  {0}  模式调整： 房主已将自动重开时间延长 {1} 分钟", 图标字符串(箭矢), 300 / 60));
			End;
		Else;
			小字体信息(事件玩家, 自定义字符串("  {0}  已达到最大上限", 图标字符串(警告)));
	}
}

规则("dev remove auto reboot time")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.menu == 1;
		(事件玩家.isDev || 主机玩家 == 事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
	}

	动作
	{
		禁用 等待(0.160, 当为“假”时中止);
		If(全局.rebootTime - 300 >= 300);
			全局.rebootTime -= 300;
			IF(事件玩家.isDev);
				小字体信息(全局.devPlayer, 自定义字符串("  {0}  开发者模式： 已将自动重开时间缩短 {1} 分钟", 图标字符串(箭矢), 300 / 60));
			Else;
				小字体信息(所有玩家(所有队伍), 自定义字符串("  {0}  模式调整： 房主已将自动重开时间缩短 {1} 分钟", 图标字符串(箭矢), 300 / 60));
			End;
	}
}

规则("player title menu - next")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.menu == 1;
		禁用 事件玩家.isDev == 真;
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		数量(事件玩家.playerTitles) > 0;
	}

	动作
	{
		禁用 等待(0.160, 当为“假”时中止);
		If(事件玩家.playerTitleIndex == 空);
			事件玩家.playerTitleIndex = 0;
		End;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		事件玩家.playerTitleIndex = (事件玩家.playerTitleIndex + 1) % 数量(事件玩家.playerTitles);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		// 停止追踪玩家变量(事件玩家, rgb_vect);
		// 等待(服务器负载 / 100 * 0.032, 无视条件);
		事件玩家.playerTitleAndColor = 数组(首个(事件玩家.playerTitles[事件玩家.playerTitleIndex]), 最后(事件玩家.playerTitles[事件玩家.playerTitleIndex]));
		等待(0.016, 无视条件);
		IF(事件玩家.playerTitleAndColor[1] == 空 && 数量(事件玩家.playerTitleAndColor[1]) == 0);
			停止追踪玩家变量(事件玩家, rgb_vect);
			事件玩家.info_pvar = 0;
			事件玩家.rgb_vect = 全局.rgbList[首个(事件玩家.info_pvar)];
			事件玩家.rgb_activated = 真;
		ELSEIF(事件玩家.playerTitleAndColor[1] != 空 && 数量(事件玩家.playerTitleAndColor[1]) >= 1);
			停止追踪玩家变量(事件玩家, rgb_vect);
			事件玩家.info_pvar = 0;
			事件玩家.rgb_vect = 首个(事件玩家.playerTitleAndColor[1]);
			事件玩家.rgb_activated = 真;
		ELSE;
			事件玩家.rgb_vect = 事件玩家.playerTitleAndColor[1];
			事件玩家.rgb_activated = 假;
		END;
		// IF(事件玩家.isDev && 事件玩家.playerTitleAndColor[1] == 空);
		// 	事件玩家.playerTitleAndColor[1] = 全局.rgbList;
		// 	事件玩家.rgb_vect = 全局.rgbList[首个(事件玩家.info_pvar)];
		// END;
		小字体信息(事件玩家, 自定义字符串("  {0}  已将称号更改为 {1}", 图标字符串(箭矢), 首个(事件玩家.playerTitles[事件玩家.playerTitleIndex])));
		等待(服务器负载 / 100 * 0.032, 无视条件);
	}
}

规则("player title menu - previous")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}
	
	条件
	{
		事件玩家.menu == 1;
		禁用 事件玩家.isDev == 真;
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		数量(事件玩家.playerTitles) > 0;
	}

	动作
	{
		禁用 等待(0.160, 当为“假”时中止);
		If(事件玩家.playerTitleIndex == 空 || 事件玩家.playerTitleIndex <= 0);
			事件玩家.playerTitleIndex = 数量(事件玩家.playerTitles);
		End;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		事件玩家.playerTitleIndex -= 1;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		// 停止追踪玩家变量(事件玩家, rgb_vect);
		事件玩家.playerTitleAndColor = 数组(首个(事件玩家.playerTitles[事件玩家.playerTitleIndex]), 最后(事件玩家.playerTitles[事件玩家.playerTitleIndex]));
		等待(0.016, 无视条件);
		IF(事件玩家.playerTitleAndColor[1] == 空 && 数量(事件玩家.playerTitleAndColor[1]) == 0);
			停止追踪玩家变量(事件玩家, rgb_vect);
			事件玩家.info_pvar = 0;
			事件玩家.rgb_vect = 全局.rgbList[首个(事件玩家.info_pvar)];
			事件玩家.rgb_activated = 真;
		ELSEIF(事件玩家.playerTitleAndColor[1] != 空 && 数量(事件玩家.playerTitleAndColor[1]) >= 1);
			停止追踪玩家变量(事件玩家, rgb_vect);
			事件玩家.info_pvar = 0;
			事件玩家.rgb_vect = 首个(事件玩家.playerTitleAndColor[1]);
			事件玩家.rgb_activated = 真;
		ELSE;
			事件玩家.rgb_vect = 事件玩家.playerTitleAndColor[1];
			事件玩家.rgb_activated = 假;
		END;
		// 事件玩家.rgb_vect = 事件玩家.playerTitleAndColor[1] != 空 && 数量(事件玩家.playerTitleAndColor[1]) <= 1 ? 首个(事件玩家.playerTitleAndColor[1]) : 全局.rgbList[首个(事件玩家.info_pvar)];
		// 根据条件跳过(数量(事件玩家.playerTitleAndColor[1]) <= 1, 2);
		// 事件玩家.rgb_activated = 数量(事件玩家.playerTitleAndColor[1]) <= 1 ? 假 : 真;
		// IF(事件玩家.isDev && 事件玩家.playerTitleAndColor[1] == 空);
		// 	事件玩家.playerTitleAndColor[1] = 全局.rgbList;
		// 	事件玩家.rgb_vect = 全局.rgbList[首个(事件玩家.info_pvar)];
		// END;
		小字体信息(事件玩家, 自定义字符串("  {0}  已将称号更改为 {1}", 图标字符串(箭矢), 首个(事件玩家.playerTitleAndColor)));
		等待(服务器负载 / 100 * 0.032, 无视条件);
	}
}

规则("dev reboot")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.menu == 2;
		事件玩家.isDev == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
	}

	动作
	{
		小字体信息(全局.devPlayer, 自定义字符串("  {0}  开发者模式： 长按 {1} 进行重启", 图标字符串(箭矢), 输入绑定字符串(按钮(装填))));
		等待(2, 当为“假”时中止);
		小字体信息(全局.devPlayer, 自定义字符串("  {0}  开发者模式： 正在重启...", 图标字符串(箭矢)));
		等待(2, 当为“假”时中止);
		重新开始比赛;
	}
}

规则("host set target player")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 主机玩家;
		事件玩家.menu == 1;
		按钮被按下(事件玩家, 按钮(技能1)) == 真;
	}

	动作
	{
		If(全局.targetPlayerIndex == 空 || 全局.targetPlayerIndex >= 数量(已排序的数组(所有玩家(队伍1), 当前数组元素)));
			全局.targetPlayerIndex = 0;
			等待(服务器负载 / 100 * 0.032, 无视条件);
		End;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		全局.targetPlayer = 已排序的数组(所有玩家(队伍1), 当前数组元素.joinTime)[全局.targetPlayerIndex];
		全局.targetPlayerIndex += 1;
		// 根据条件跳过(全局.targetPlayer == 空 || 全局.targetPlayer == 0, 1);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		小字体信息(添加至数组(全局.devPlayer, 主机玩家), 全局.targetPlayer == 空 ? 自定义字符串("  {0}  没有可标记的玩家", 图标字符串(箭矢)) : 自定义字符串("  {0}  房主操作： 已标记 {1}（{2}）", 图标字符串(箭矢), 全局.targetPlayer, 所用英雄(全局.targetPlayer)));
	}
}

规则("host remove target player")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 主机玩家;
		事件玩家.menu == 1;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
	}

	动作
	{
		根据条件中止(全局.targetPlayer == 空 || 数组包含(全局.devPlayer, 全局.targetPlayer));
		小字体信息(添加至数组(全局.devPlayer, 主机玩家), 自定义字符串("  {0}  房主操作： 长按 {1} 移除 {2}", 图标字符串(箭矢), 输入绑定字符串(按钮(装填)), 全局.targetPlayer));
		等待(2, 当为“假”时中止);
		小字体信息(添加至数组(全局.devPlayer, 主机玩家), 自定义字符串("  {0}  房主操作： 即将移除玩家 {1}", 图标字符串(箭矢), 全局.targetPlayer));
		等待(1, 当为“假”时中止);
		小字体信息(添加至数组(全局.devPlayer, 主机玩家), 自定义字符串("  {0}  房主操作： 已移除玩家 {1}", 图标字符串(箭矢), 全局.targetPlayer));
		修改全局变量(blackList, 添加至数组, 全局.targetPlayer);
		移除玩家(全局.targetPlayer);
		全局.targetPlayerIndex = 0;
		全局.targetPlayer = 空;
	}
}

规则("dev set target player")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 2;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
	}

	动作
	{
		If(全局.targetPlayerIndex == 空 || 全局.targetPlayerIndex >= 数量(已排序的数组(所有玩家(队伍1), 当前数组元素)));
			全局.targetPlayerIndex = 0;
			等待(服务器负载 / 100 * 0.032, 无视条件);
		End;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		全局.targetPlayer = 已排序的数组(所有玩家(队伍1), 当前数组元素.joinTime)[全局.targetPlayerIndex];
		全局.targetPlayerIndex += 1;
		// 根据条件跳过(全局.targetPlayer == 空 || 全局.targetPlayer == 0, 1);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		小字体信息(全局.devPlayer, 全局.targetPlayer == 空 ? 自定义字符串("  {0}  没有可标记的玩家", 图标字符串(箭矢)) : 自定义字符串("  {0}  开发者模式： 已标记 {1}（{2}）", 图标字符串(箭矢), 全局.targetPlayer, 所用英雄(全局.targetPlayer)));
	}
}

规则("dev remove target player")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 2;
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
	}

	动作
	{
		根据条件中止(全局.targetPlayer == 空 || 数组包含(全局.devPlayer, 全局.targetPlayer));
		小字体信息(全局.devPlayer, 自定义字符串("  {0}  开发者模式： 长按 {1} 移除 {2}", 图标字符串(箭矢), 输入绑定字符串(按钮(终极技能)), 全局.targetPlayer));
		等待(2, 当为“假”时中止);
		小字体信息(全局.devPlayer, 自定义字符串("  {0}  开发者模式： 即将移除玩家 {1}", 图标字符串(箭矢), 全局.targetPlayer));
		等待(1, 当为“假”时中止);
		小字体信息(全局.devPlayer, 自定义字符串("  {0}  开发者模式： 已移除玩家 {1}", 图标字符串(箭矢), 全局.targetPlayer));
		修改全局变量(blackList, 添加至数组, 全局.targetPlayer);
		移除玩家(全局.targetPlayer);
		全局.targetPlayerIndex = 0;
		全局.targetPlayer = 空;
	}
}

规则("dev set dmg reduction")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 2;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		// 事件玩家.isWinner == 假;
	}

	动作
	{
		事件玩家.dmgReduc = !事件玩家.dmgReduc;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		If(事件玩家.dmgReduc);
			设置受到伤害(事件玩家, 1);
			创建效果(所有玩家(所有队伍), 安娜纳米激素强化效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
			事件玩家.nanoEffect = 最后创建的实体;
			小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 已将伤害减免设置为 -{1}%", 图标字符串(箭矢), 99));
		Else;
			设置受到伤害(事件玩家, 100);
			消除效果(事件玩家.nanoEffect);
			小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 已取消伤害减免", 图标字符串(箭矢)));
		End;
	}
}

规则("dev set invincible")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 2;
		按钮被按下(事件玩家, 按钮(技能1)) == 真;
		// 事件玩家.isWinner == 假;
	}

	动作
	{
		事件玩家.invincible = !事件玩家.invincible;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		IF(事件玩家.invincible);
			设置状态(事件玩家, 空, 无敌, 999999986991104.000);
			创建效果(所有玩家(所有队伍), 巴蒂斯特维生力场保护效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
			事件玩家.invincibleEffect = 最后创建的实体;
			小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 已设置为无敌状态", 图标字符串(箭矢)));
		ELSE;
			清除状态(事件玩家, 无敌);
			消除效果(事件玩家.invincibleEffect);
			小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 已取消无敌状态", 图标字符串(箭矢)));
	}
}

规则("dev air walk toggle")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
		事件玩家.menu == 3;
	}

	动作
	{
		根据条件跳过(事件玩家.isAirWalkEnabled == 真, 4);
		设置引力(事件玩家, 0);
		事件玩家.isAirWalkEnabled = 真;
		小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 已开启浮空", 图标字符串(箭矢)));
		中止;
		设置引力(事件玩家, 100);
		事件玩家.isAirWalkEnabled = 假;
		小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 已关闭浮空", 图标字符串(箭矢)));
	}
}

规则("dev air lock")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.isAirWalkEnabled == 真;
		阈值(事件玩家) == 矢量(0, 0, 0);
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
	}

	动作
	{
		施加推力(事件玩家, 上, 0.001, 至地图, 取消相反运动);
		施加推力(事件玩家, 速率(事件玩家) * -1, 0.001, 至地图, 取消相反运动);
	}
}

规则("dev portal toggle")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 3;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
	}

	动作
	{
		根据条件跳过(事件玩家.isPortalEnabled == 真, 3);
		事件玩家.isPortalEnabled = 真;
		小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 已开启穿墙", 图标字符串(箭矢)));
		中止;
		事件玩家.isPortalEnabled = 假;
		小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 已关闭穿墙", 图标字符串(箭矢)));
	}
}

规则("dev R portal")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 0;
		事件玩家.isPortalEnabled == 真;
		存活(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		正在使用表情交流(事件玩家) == 假;
		(当前地图 == 地图(“地平线”月球基地) && 相距距离(事件玩家, 矢量(-9.380, 8.740, 2.050)) < 1) == 假;
	}

	动作
	{
		设置引力(事件玩家, 绝对值(0));
		根据条件跳过(按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真, 2);
		传送(事件玩家, 所选位置(事件玩家) + 面朝方向(事件玩家) * 4);
		跳过(1);
		传送(事件玩家, 所选位置(事件玩家) + 面朝方向(事件玩家) * 20);
		等待(0.160, 无视条件);
		如条件为“真”则循环;
		根据条件中止(事件玩家.isAirWalkEnabled == 真);
		设置引力(事件玩家, 绝对值(100));
	}
}

规则("dev pick control center Position")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 3;
		按钮被按下(事件玩家, 按钮(技能1)) == 真;
	}

	动作
	{
		If(全局.controlCenterPosition == 空);
			小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 目标点坐标为空", 图标字符串(箭矢)));
			中止;
		Else;
			根据条件跳过(事件玩家.controlCenterIndex >= 2, 3);
			事件玩家.controlCenterIndex += 1;
			小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 已选择目标点坐标：{1}", 图标字符串(箭矢), 全局.controlCenterPosition[事件玩家.controlCenterIndex]));
			中止;
			事件玩家.controlCenterIndex = 0;
			小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 已选择目标点坐标：{1}", 图标字符串(箭矢), 全局.controlCenterPosition[事件玩家.controlCenterIndex]));
		End;
	}
}

规则("dev to control center Position")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 3;
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		全局.controlCenterPosition != 空;
	}

	动作
	{
		传送(事件玩家, 最近的可行走位置(全局.controlCenterPosition[事件玩家.controlCenterIndex]));
	}
}

规则("dev to Target Player Position")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 2;
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		全局.targetPlayer != 空;
	}

	动作
	{
		传送(事件玩家, 最近的可行走位置(所选位置(全局.targetPlayer) - 矢量(0, 0, -1)));
		// 传送(事件玩家, 最近的可行走位置(所选位置(全局.targetPlayer) - 地图矢量(矢量(0, 0, 7), 事件玩家, 旋转)));
		设置朝向(事件玩家, 面朝方向(全局.targetPlayer), 至地图);
	}
}

规则("when a player joins, load player data if they have it and initialize them")
{
	事件
	{
		玩家加入比赛;
		队伍1;
		全部;
	}

	动作
	{
		事件玩家.isDev = 单次赋值(数组包含(全局.devList, 自定义字符串("{0}", 事件玩家)));
		根据条件跳过(!单次赋值(全局.dlcVishkarEvent),2);
		事件玩家.eventId = -1;
		事件玩家.sizeHealth = 1;
		等待(服务器负载 / 200 * 随机实数(1, 3), 无视条件);
		If(数组包含(全局.savedIndex, 自定义字符串("{0}", 事件玩家)));
			事件玩家.heroNumber = 全局.savedHero[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			等待(服务器负载 / 100 * 0.032, 无视条件);
			事件玩家.runDeathCount = 全局.savedDeaths[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			等待(服务器负载 / 100 * 0.032, 无视条件);
			事件玩家.isWinner = 全局.savedIsWinner[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			等待(服务器负载 / 100 * 0.032, 无视条件);
			事件玩家.skipCount = 全局.savedSkipCount[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			等待(服务器负载 / 100 * 0.032, 无视条件);
			事件玩家.winnerTime = 全局.savedWinnerTime[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			等待(服务器负载 / 100 * 0.032, 无视条件);
			事件玩家.A36TGrenade = 全局.savedA36TGrenade[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			等待(服务器负载 / 100 * 0.032, 无视条件);
			事件玩家.A36TGrenadeHit = 全局.savedA36TGrenadeHit[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			等待(服务器负载 / 100 * 0.032, 无视条件);
			事件玩家.A36TGrenadeDmg = 全局.savedA36TGrenadeDmg[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			等待(服务器负载 / 100 * 0.032, 无视条件);
			事件玩家.A36TGrenadeAlive = 全局.savedA36TGrenadeAlive[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			If(事件玩家.joinTime == 空 || 事件玩家.joinTime == 0);
				事件玩家.joinTime = 全局.savedJoinTime[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			End;
		ELSE;
			If(事件玩家.joinTime == 空 || 事件玩家.joinTime == 0);
				事件玩家.joinTime = 单次赋值(总计消耗时间);
			End;
		End;
		事件玩家.dmgReduc = 假;
		事件玩家.invincible = 假;
		// 事件玩家.combatRegen = 真;
		// IF(单次赋值(数组包含(全局.devList, 自定义字符串("{0}", 事件玩家))));
		// 	事件玩家.debugInfo = 全局.debugInfo;
		// END;
		开始强制玩家选择英雄(事件玩家, 全局.heroList[事件玩家.heroNumber]);
		停止强制玩家选择英雄(事件玩家);
		设置玩家可选的英雄(事件玩家, 数组分割(全局.heroList, 0, 事件玩家.heroNumber + 1));
		等待(6, 无视条件);
		// 事件玩家.playerTitles = 已过滤的数组(全局.allTitle, 数量(当前数组元素) > 0 && 当前数组元素[0] == 自定义字符串("{0}", 事件玩家));
		// IF(数量(事件玩家.playerTitles) > 0);
		// 	事件玩家.playerTitleAndColor = 数组(最后(事件玩家.playerTitles)[1], 最后(事件玩家.playerTitles)[2]);
		// END;
		IF(数组包含(全局.titlePlayer, 自定义字符串("{0}", 事件玩家)));
			事件玩家.playerTitleRelationIndex = 数组值的索引(全局.titlePlayer, 自定义字符串("{0}", 事件玩家));
			调用子程序(setPlayerTitle);
			等待(0.032, 无视条件);
			小字体信息(事件玩家, 自定义字符串("  称号已加载"));
			事件玩家.playerTitleAndColor = 数组(首个(最后(事件玩家.playerTitles)), 最后(最后(事件玩家.playerTitles)));
			事件玩家.rgb_vect = 事件玩家.playerTitleAndColor[1] != 空 ? 首个(事件玩家.playerTitleAndColor[1]) : 全局.rgbList[首个(事件玩家.info_pvar)];
		END;
		事件玩家.obstrucVis = 空数组;
		// 根据条件跳过(全局.controlRespawnPosition == 空 || 全局.portalPosition != 空,1);
		// 小字体信息(事件玩家, 自定义字符串("  通过第一个传送点可以按 {0} 使用存档点功能（单英雄仅限一次）", 按钮(装填)));
		If(数组包含(全局.savedIndex, 自定义字符串("{0}", 事件玩家)));
			小字体信息(事件玩家, 自定义字符串("  你的进度已成功加载"));
			小字体信息(从数组中移除(所有玩家(所有队伍), 事件玩家), 自定义字符串("  {0} 载入 {1}{2}", 事件玩家, 英雄图标字符串(全局.heroList[事件玩家.heroNumber]), 全局.heroList[事件玩家.heroNumber]));
	}
}

规则("initialize player title")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		存活(事件玩家) == 真;
		事件玩家.playerTitleAndColor != 空;
		事件玩家.titleTextID == 空;
	}

	动作
	{
		等待(栏位(事件玩家) * 0.080, 无视条件);
		// If(单次赋值(数组包含(全局.devList, 自定义字符串("{0}", 事件玩家))));
			事件玩家.info_pvar = 0;
		// 	事件玩家.rgb_vect = 全局.rgbList[首个(事件玩家.info_pvar)];
			创建地图文本(已过滤的数组(所有玩家(所有队伍), 在视线内(事件玩家, 当前数组元素, 屏障不会阻挡视线)), 自定义字符串("{0}{1}", 事件玩家.isDev ? 技能图标字符串(英雄(托比昂), 按钮(技能2)) : 自定义字符串(""), 事件玩家.playerTitleAndColor[0]), 事件玩家, 事件玩家.isDev ? 1 : 0.800, 不要截取, 可见，位置，字符串和颜色, 自定义颜色(X方向分量(
				事件玩家.rgb_vect), Y方向分量(事件玩家.rgb_vect), Z方向分量(事件玩家.rgb_vect), 255), 默认可见度);
		// Else;
			// 创建地图文本(已过滤的数组(所有玩家(所有队伍), 在视线内(事件玩家, 当前数组元素, 屏障不会阻挡视线)), 事件玩家.playerTitleAndColor[0], 事件玩家, 0.800, 不要截取, 可见，位置，字符串和颜色,
			// 	事件玩家.playerTitleAndColor[1], 默认可见度);
		// End;
		事件玩家.titleTextID = 上一个文本ID;
	}
}

规则("update title color")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		全局.antiCrashActivated == 假;
		事件玩家.playerTitleAndColor[1] == 空;
		数量(事件玩家.playerTitleAndColor[1]) == 0;
		// 事件玩家.rgb_activated == 真;
	}

	动作
	{
		等待(0.016, 当为“假”时中止);
		事件玩家.info_pvar = (事件玩家.info_pvar + 1) % 数量(全局.rgbList);
		持续追踪玩家变量(事件玩家, rgb_vect, 全局.rgbList[事件玩家.info_pvar], 1.500, 全部禁用);
		等待直到 (事件玩家.rgb_vect == 全局.rgbList[事件玩家.info_pvar], 999999986991104.000);
		如条件为“真”则循环;
		停止追踪玩家变量(事件玩家, rgb_vect);
		事件玩家.info_pvar = 0;
		// 事件玩家.rgb_vect = 首个(事件玩家.playerTitleAndColor[1]);
	}
}

规则("update title color")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		// 事件玩家.isDev == 真;
		全局.antiCrashActivated == 假;
		事件玩家.playerTitleAndColor[1] != 空;
		数量(事件玩家.playerTitleAndColor[1]) > 1;
		事件玩家.rgb_activated == 真;
	}

	动作
	{
		等待(0.016, 当为“假”时中止);
		事件玩家.info_pvar = (事件玩家.info_pvar + 1) % 数量(事件玩家.playerTitleAndColor[1]);
		持续追踪玩家变量(事件玩家, rgb_vect, 事件玩家.playerTitleAndColor[1][事件玩家.info_pvar], 2.500, 全部禁用);
		等待直到 (事件玩家.rgb_vect == 事件玩家.playerTitleAndColor[1][事件玩家.info_pvar] || !事件玩家.rgb_activated, 999999986991104.000);
		如条件为“真”则循环;
		等待(0.016, 无视条件);
		停止追踪玩家变量(事件玩家, rgb_vect);
		事件玩家.info_pvar = 0;
		事件玩家.rgb_vect = 首个(事件玩家.playerTitleAndColor[1]);
	}
}

规则("Dev to release heros")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		单次赋值(数组包含(全局.devList, 自定义字符串("{0}", 事件玩家))) != 假;
		事件玩家.menu == 2;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
		事件玩家.isWinner == 假;
	}

	动作
	{
		If(事件玩家.heroNumber < 数量(全局.heroList) - 1);
			事件玩家.heroNumber = 数量(全局.heroList) - 1;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			设置玩家可选的英雄(事件玩家, 数组分割(全局.heroList, 0, 事件玩家.heroNumber + 1));
			等待(服务器负载 / 100 * 0.500, 无视条件);
			小字体信息(事件玩家, 自定义字符串("  {0} 开发者模式：已解锁全英雄", 图标字符串(箭矢)));
			禁用 调用子程序(savePlayerData);
		Else If(事件玩家.isWinner == 假);
			事件玩家.isWinner = 真;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			小字体信息(事件玩家, 自定义字符串("  {0} 开发者模式：已通关", 图标字符串(箭矢)));
	}
}

规则("auto reboot")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		总计消耗时间 >= 全局.rebootTime - 60;
	}

	动作
	{
		大字体信息(所有玩家(所有队伍), 自定义字符串("游戏将在 1 分钟后自动重开"));
		等待(60, 无视条件);
		重新开始比赛;
	}
}

规则("[debug.opy]: player debug (Top Right)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		单次赋值(事件玩家.debugInfo) == 真;
		单次赋值(数组包含(全局.devList, 自定义字符串("{0}", 事件玩家))) != 假;
	}

	动作
	{
		创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("难度 = {0}", 首个(全局.difficultyText)), 空, 右边, 10, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("当前位置 = {0}", 所选位置(事件玩家)), 空, 右边, 26, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("当前速度 = {0}", 速度(事件玩家)), 空, 右边, 27, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("当前速率 = {0}", 速率(事件玩家)), 空, 右边, 28, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("当前地图 = {0}/{1}", 全局.__currentMap__, 当前地图), 空, 右边, 29, 空, 颜色(白色), 空, 可见和字符串,
			始终不可见);
		创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("重生室位置 = {0}", 所选位置(重生点(队伍1))), 空, 右边, 30, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		禁用 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("重生室距离 X = {0}/{1}/{2}", X方向分量(所选位置(事件玩家)), X方向分量(首个(全局.controlRespawnPosition)), 相距距离(矢量(X方向分量(所选位置(事件玩家)),
			0, 0), 矢量(Y方向分量(首个(全局.controlRespawnPosition)), 0, 0))), 空, 右边, 31, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		禁用 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("重生室距离 Y = {0}/{1}/{2}", Y方向分量(所选位置(事件玩家)), Y方向分量(首个(全局.controlRespawnPosition)), 相距距离(矢量(0,
			Y方向分量(所选位置(事件玩家)), 0), 矢量(0, Y方向分量(首个(全局.controlRespawnPosition)), 0))), 空, 右边, 32, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		禁用 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("重生室距离 Z = {0}/{1}/{2}", Z方向分量(所选位置(事件玩家)), Z方向分量(首个(全局.controlRespawnPosition)), 相距距离(矢量(0,
			0, Z方向分量(所选位置(事件玩家))), 矢量(0, 0, Z方向分量(首个(全局.controlRespawnPosition))))), 空, 右边, 33, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		// 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("转向速度 = {0}", 首个(已排序的数组(所有玩家(队伍2), 相距距离(事件玩家, 当前数组元素))).turnSpeed), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("当前事件 = {0}/{1}", 本地玩家.eventName, 本地玩家.eventId), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("上一个事件 = {0}/{1}", 首个(全局.buffEvent[本地玩家.eventLastId]), 本地玩家.eventLastId), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("重生室索引 = {0}", 本地玩家.controlJumpIndex), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		// 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("附身目标 = {0}/{1}", 已排序的数组(已过滤的数组(已过滤的数组(所有存活玩家(队伍1), 当前数组元素.eventType != 0 && 当前数组元素.eventId != 12), 当前数组元素.isWinner != 真 && 在视野内(事件玩家, 当前数组元素, 45) && 相距距离(事件玩家, 当前数组元素) < 20), 相距距离(事件玩家, 当前数组元素)), 数量(已排序的数组(已过滤的数组(已过滤的数组(所有存活玩家(队伍1), 当前数组元素.eventType != 0 && 当前数组元素.eventId != 12), 当前数组元素.isWinner != 真 && 在视野内(事件玩家, 当前数组元素, 45) && 相距距离(事件玩家, 当前数组元素) < 20), 相距距离(事件玩家, 当前数组元素)))), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		
		// 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("随机取值 = {0}", 已过滤的数组(全局.buffEventId, 当前数组元素 != 0)), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		// 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("正在使用技能 1 = {0}", 正在使用技能 1(事件玩家)), 空, 右边, 35, 空, 颜色(白色), 空, 字符串, 默认可见度);
		// 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("技能 1 冷却时间 = {0}", 技能冷却时间(事件玩家, 按钮(技能1))), 空, 右边, 36, 空, 颜色(白色), 空, 字符串, 默认可见度);
		// "hudSubheader(eventPlayer, \"isUsingAbility2() = {}\".format(eventPlayer.isUsingAbility2()), HudPosition.RIGHT, 1, Color.WHITE, HudReeval.STRING)"
		// 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("正在使用技能 2 = {0}", 正在使用技能 2(事件玩家)), 空, 右边, 37, 空, 颜色(白色), 空, 字符串, 默认可见度);
		// 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("技能 2 冷却时间 = {0}", 技能冷却时间(事件玩家, 按钮(技能2))), 空, 右边, 38, 空, 颜色(白色), 空, 字符串, 默认可见度);
		// 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("开发者RGB = {0}", 事件玩家.playerTitleAndColor[1] == 空), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		// 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("称号颜色组 = {0}", 数量(事件玩家.playerTitleAndColor[1])), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		// 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("称号变色效果 = {0}", 事件玩家.rgb_activated), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		// 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("称号颜色 = {0}", 首个(事件玩家.playerTitleAndColor[1])), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		// 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("当前称号颜色 = {0}", 事件玩家.rgb_vect), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		// 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("当前称号XYZ = {0}/{1}/{2}", X方向分量(
		// 		事件玩家.rgb_vect), Y方向分量(事件玩家.rgb_vect), Z方向分量(事件玩家.rgb_vect)), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
	}
}

禁用 规则("未经原作者许可，任何人不得将以下代码进行二次创作与发布")
{
	事件
	{
		持续 - 全局;
	}
}

规则("[VishkarEvent]: 疾风祝福")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 1), 当前数组元素) == 真;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 无视条件);
		创建效果(所有玩家(所有队伍), “士兵：76”疾跑效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
		事件玩家.eventEffect = 最后创建的实体;
		事件玩家.mod_speed_event = 50;
		调用子程序(updatePlayerStats);
		等待(事件玩家.eventDuration, 无视条件);
		事件玩家.mod_speed_event = 0;
		调用子程序(updatePlayerStats);
		调用子程序(clearEventEffect);
	}
}

规则("[VishkarEvent]: 钢铁防线")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 2), 当前数组元素) == 真;
	}

	动作
	{
		等待(0.032, 无视条件);
		// 调用子程序(setEventDuration);
		根据条件跳过(事件玩家.healthId[1] == 空, 1);
		移除玩家的生命池(事件玩家.healthId[1]);
		为玩家添加生命池(事件玩家, 护甲, 1500, 假, 假);
		事件玩家.healthId[1] = 最后创建的生命池;
		播放效果(所有玩家(所有队伍), 布丽吉塔恢复包护甲效果, 颜色(白色), 事件玩家, 200);
		事件玩家.mod_dmg_taken = -25;
		调用子程序(updatePlayerStats);
		等待直到(事件玩家.eventId == 空, 事件玩家.eventDuration);
		移除玩家的生命池(事件玩家.healthId[1]);
		事件玩家.mod_dmg_taken = 0;
		调用子程序(updatePlayerStats);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		事件玩家.healthId[1] = 空;
	}
}

规则("[VishkarEvent]: 肾上腺素")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 3), 当前数组元素) == 真;
	}

	动作
	{
		创建效果(所有玩家(所有队伍), 安娜纳米激素强化效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
		事件玩家.eventEffect[0] = 最后创建的实体;
		创建效果(所有玩家(所有队伍), 安娜纳米激素强化声音, 颜色(队伍1), 事件玩家, 200, 位置和半径);
		事件玩家.eventEffect[1] = 最后创建的实体;
		事件玩家.mod_dmg_taken = -50;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		调用子程序(updatePlayerStats);
		等待(事件玩家.eventDuration, 无视条件);
		事件玩家.mod_dmg_taken = 0;
		调用子程序(updatePlayerStats);
		调用子程序(clearEventEffect);
	}
}

规则("[VishkarEvent]: 生命源泉")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 4), 当前数组元素) == 真;
	}

	动作
	{
		// 停止持续治疗(事件玩家.healID);
		等待(0.032, 无视条件);
		创建效果(所有玩家(所有队伍), 治疗目标激活效果, 颜色(黄色), 事件玩家, 200, 位置和半径);
		事件玩家.eventEffect = 最后创建的实体;
		开始持续治疗(事件玩家, 事件玩家, 20, 最大生命值(事件玩家) * 0.15);
		// 事件玩家.healID = 上一个持续治疗效果ID;
		等待(事件玩家.eventDuration, 无视条件);
		调用子程序(clearEventEffect);
		// 停止持续治疗(事件玩家.healID);
		// 事件玩家.healID = 0;
	}
}

规则("[VishkarEvent]: 黑粉来袭")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 5), 当前数组元素) == 真;
	}

	动作
	{
		// 创建HUD文本(事件玩家, 空, 空, 自定义字符串("\r\n\r\n\r\n{0}/{1}", 数量(已过滤的数组(所有玩家(队伍2), 当前数组元素.target == 事件玩家)), 数量(全局.bastionPosition)), 顶部, 9, 空, 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		创建HUD文本(事件玩家, 空, 自定义字符串("\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r"), 自定义字符串("{0}/{1}", 数量(已过滤的数组(所有玩家(队伍2), 当前数组元素.target == 事件玩家)), 数量(全局.bastionPosition)), 顶部, 9, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.hudTextId = 上一个文本ID;
		// 事件玩家.hudText = 自定义字符串("{0}/{1}", 数量(已过滤的数组(所有玩家(队伍2), 当前数组元素.target == 事件玩家)), 数量(全局.bastionPosition));
		等待直到(事件玩家.eventId != 5, 事件玩家.eventDuration);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		消除HUD文本(事件玩家.hudTextId);
	}
}

规则("[VishkarEvent]: 足力健")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 6, 正在移动(事件玩家), 速度(事件玩家) != 0), 当前数组元素) == 真;
	}

	动作
	{
		等待(1, 当为“假”时中止);
		根据条件跳过(事件玩家.eventEffect != 空, 2);
		创建效果(所有玩家(所有队伍), “士兵：76”疾跑效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
		事件玩家.eventEffect = 最后创建的实体;
		事件玩家.mod_speed_event += 3;
		调用子程序(updatePlayerStats);
		如条件为“真”则循环;
		等待(0.032, 无视条件);
		事件玩家.mod_speed_event = 0;
		调用子程序(updatePlayerStats);
		调用子程序(clearEventEffect);
	}
}

规则("[VishkarEvent]: 血肉再生")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 7), 当前数组元素) == 真;
	}

	动作
	{
		等待(0.032, 无视条件);
		移除玩家的生命池(事件玩家.healthId[0]);
		为玩家添加生命池(事件玩家, 生命值, 取整(75 + 最大生命值(事件玩家) * 0.25, 至最近), 假, 假);
		事件玩家.healthId[0] = 最后创建的生命池;
		等待(4, 无视条件);
		如条件为“真”则循环;
		移除玩家的生命池(事件玩家.healthId[0]);
		事件玩家.healthId[0] = 空;
	}
}

规则("[VishkarEvent]: 心之钢 Effect")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 8), 当前数组元素) == 真;
	}

	动作
	{
		等待(0.016, 无视条件);
		根据条件跳过(事件玩家.eventEffect != 空, 2);
		创建效果(所有玩家(所有队伍), 温斯顿原始暴怒效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
		事件玩家.eventEffect = 最后创建的实体;
		等待直到(事件玩家.eventId == 空, 事件玩家.eventDuration);
		调用子程序(clearEventEffect);
	}
}

规则("[VishkarEvent]: 心之钢")
{
	事件
	{
		玩家阵亡;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 8), 当前数组元素) == 真;
		所用英雄(攻击方) == 英雄(堡垒);
	}

	动作
	{
		事件玩家.heart_steel += 0.75;
		小字体信息(事件玩家, 自定义字符串("  {0}  已获得 0.75% 额外最大生命值", 技能图标字符串(英雄(毛加), 按钮(技能2))));
		等待(0.032, 无视条件);
		等待直到(存活(事件玩家), 0.5);
		调用子程序(setPlayerHP);
		等待(0.032, 无视条件);
	}
}

规则("[VishkarEvent]: 危险感知")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 9), 当前数组元素) == 真;
		数量(已过滤的数组(所有玩家(队伍2), 当前数组元素.target == 事件玩家)) > 0;
	}

	动作
	{
		事件玩家.mod_speed_event = 60;
		事件玩家.mod_dmg_taken = -25;
		调用子程序(updatePlayerStats);
		等待直到(数量(已过滤的数组(所有玩家(队伍2), 当前数组元素.target == 事件玩家)) == 0, 事件玩家.eventDuration);
		等待(1.000, 无视条件);
		如条件为“真”则循环;
		事件玩家.mod_speed_event = 0;
		事件玩家.mod_dmg_taken = 0;
		调用子程序(updatePlayerStats);
	}
}

规则("[VishkarEvent]: 反应装甲")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 10), 当前数组元素) == 真;
	}

	动作
	{
		等待(0.032, 无视条件);
		根据条件跳过(事件玩家.healthId[1] == 空, 1);
		移除玩家的生命池(事件玩家.healthId[1]);
		为玩家添加生命池(事件玩家, 护甲, 150, 真, 假);
		事件玩家.healthId[1] = 最后创建的生命池;
		播放效果(所有玩家(所有队伍), 布丽吉塔恢复包护甲效果, 颜色(白色), 事件玩家, 200);
		等待(事件玩家.eventDuration, 无视条件);
		移除玩家的生命池(事件玩家.healthId[1]);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		事件玩家.healthId[1] = 空;
	}
}

规则("[VishkarEvent]: 反应装甲")
{
	事件
	{
		玩家受到伤害;
		队伍1;
		全部;
	}

	条件
	{
		攻击方 != 被攻击方;
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 10), 当前数组元素) == 真;
		类型的生命值(事件玩家, 护甲) > 0;
	}

	动作
	{
		等待(0.032, 当为“假”时中止);
		根据条件跳过(具有状态(攻击方, 击晕), 1);
		设置状态(攻击方, 被攻击方, 击晕, 1.00);
		等待(1.000, 无视条件);
	}
}

规则("[VishkarEvent]: 死亡延迟")
{
	事件
	{
		玩家受到伤害;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 11), 当前数组元素) == 真;
		// 所用英雄(攻击方) == 英雄(堡垒);
		对任意为“真”(数组(事件伤害 >= 生命值(事件玩家), 生命值(事件玩家) <= 最大生命值(事件玩家) * 0.15, 事件技能 == 按钮(辅助攻击模式) && 所用英雄(攻击方) == 英雄(堡垒) && 最大生命值(事件玩家) <= 500), 当前数组元素) == 真;
	}

	动作
	{
		等待(0.016, 当为“假”时中止);
		设置状态(事件玩家, 事件玩家, 无法杀死, 事件玩家.eventDuration);
		创建效果(所有玩家(所有队伍), 巴蒂斯特维生力场保护效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
		事件玩家.invincibleEffect = 最后创建的实体;
		创建效果(所有玩家(所有队伍), 巴蒂斯特维生力场保护声音, 颜色(队伍1), 事件玩家, 200, 位置和半径);
        事件玩家.eventEffect = 最后创建的实体;
		小字体信息(事件玩家, 自定义字符串("  {0}  已触发死亡延迟", 技能图标字符串(英雄(巴蒂斯特), 按钮(技能2))));
		等待直到(事件玩家.eventId == 空, 事件玩家.eventDuration);
		清除状态(事件玩家, 无法杀死);
		消除效果(事件玩家.invincibleEffect);
		调用子程序(clearEventEffect);
		等待(0.016, 无视条件);
		根据条件跳过(对任意为“真”(数组(具有状态(事件玩家, 相移), 具有状态(事件玩家, 无敌), 具有状态(事件玩家, 无法杀死)), 当前数组元素), 1);
		伤害(事件玩家, 攻击方, 9999999999);
	}
}

规则("[VishkarEvent]: 有我有你")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 12), 当前数组元素) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
	}

	动作
	{
		// 等待直到(按钮被按下(事件玩家, 按钮(互动)), 事件玩家.eventDuration);
		// 事件玩家.possess = 空;
		等待(0.032, 当为“假”时中止);
		事件玩家.possess = 已排序的数组(已过滤的数组(所有存活玩家(队伍1), 当前数组元素 != 事件玩家 && 当前数组元素.isWinner != 真 && 当前数组元素.possessed != 真 && 相距距离(事件玩家, 当前数组元素) < 40), 相距距离(事件玩家, 当前数组元素));
		等待(0.032, 无视条件);
		小字体信息(事件玩家, 自定义字符串("  {0}", 数量(事件玩家.possess) == 0 ? 自定义字符串("附近未找到可附身目标") : 自定义字符串("附身目标：{0}", 首个(事件玩家.possess))));
		// 等待(1, 当为“假”时中止);
		等待(0.032, 无视条件);
		根据条件跳过(数量(事件玩家.possess) == 0, 7);
		事件玩家.mod_heal_event += 25;
		调用子程序(updatePlayerStats);
		传送(事件玩家, 所选位置(首个(事件玩家.possess)));
		绑定玩家(事件玩家, 首个(事件玩家.possess), 矢量(0, 1, -1));
		首个(事件玩家.possess).possessed = 真;
		小字体信息(首个(事件玩家.possess), 自定义字符串("  你已被 {0} 附身", 事件玩家));
		设置状态(事件玩家, 空, 相移, 9999);
		设置状态(事件玩家, 空, 无敌, 9999);
		// 开始持续治疗(首个(事件玩家.possess), 事件玩家, 最大生命值(事件玩家) * 0.2, 事件玩家.eventDuration);
		等待直到 (死亡(首个(事件玩家.possess)) || 按钮被按下(事件玩家, 按钮(蹲下)) || !实体存在(首个(事件玩家.possess)) || 事件玩家.eventDuration == 0, 事件玩家.eventDuration);
		解除绑定(事件玩家);
		根据条件跳过(所选位置(首个(事件玩家.possess)) == 空 || 数量(事件玩家.possess) == 0, 1);
		传送(事件玩家, 最近的可行走位置(所选位置(首个(事件玩家.possess)) + 矢量(随机整数(-1, 1), 0.5, 随机整数(-1, 1))));
		首个(事件玩家.possess).possessed = 假;
		清除状态(事件玩家, 相移);
		清除状态(事件玩家, 无敌);
		事件玩家.possess = 空;
	}
}

规则("[VishkarEvent]: ↑↑↓↓←→←→BABA")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.controlRespawnPosition) == 空;
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 存活(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 13), 当前数组元素) == 真;
	}

	动作
	{
		If(单次赋值(全局.controlRespawnPosition) != 空);
			事件玩家.eventDuration = 0;
		End;
		事件玩家.controlPlayerRespawnPosition = 数组(所选位置(事件玩家), 面朝方向(事件玩家), 所用英雄(事件玩家));
		播放效果(事件玩家, “黑影”位移传动声音, 颜色(白色), 事件玩家, 100);
		// 播放效果(事件玩家, “黑影”位移传动材料效果, 颜色(蓝色), 事件玩家, 100);
		If(事件玩家.eventEffect == 空);
			创建效果(事件玩家, 火花, 颜色(黄色), 首个(事件玩家.controlPlayerRespawnPosition), 1, 可见，位置和半径);
			事件玩家.eventEffect = 最后创建的实体;
		End;
		等待(5, 无视条件);
		如条件为“真”则循环;
	}
}

规则("[VishkarEvent]: ↑↑↓↓←→←→BABA")
{
	事件
	{
		玩家阵亡;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.controlRespawnPosition) == 空;
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 13), 当前数组元素) == 真;
		事件玩家.isWinner != 真;
		事件玩家.controlPlayerRespawnPosition != 空数组;
	}

	动作
	{
		大字体信息(事件玩家, 自定义字符串("↑↑↓↓←→←→BABA"));
		播放效果(所有玩家(所有队伍), “猎空”闪回消失效果, 颜色(队伍1), 事件玩家, 200);
		关闭游戏预设复生模式(事件玩家);
		等待(3, 无视条件);
		开启游戏预设复生模式(事件玩家);
		复活(事件玩家);
		传送(事件玩家, 首个(事件玩家.controlPlayerRespawnPosition));
		设置朝向(事件玩家, 事件玩家.controlPlayerRespawnPosition[1], 至地图);
		播放效果(所有玩家(所有队伍), “猎空“闪回重现效果, 颜色(队伍1), 事件玩家, 200);
		等待(0.500, 无视条件);
		事件玩家.controlPlayerRespawnPosition = 空;
		调用子程序(clearEventEffect);
		事件玩家.eventDuration = 0;
	}
}

规则("[VishkarEvent]: 费斯卡光子护盾")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 14), 当前数组元素) == 真;
	}
	
	动作
	{
		等待(0.016, 无视条件);
		所有玩家(队伍1).target = 事件玩家;
		等待直到(死亡(事件玩家), 事件玩家.eventDuration);
		事件玩家.eventDuration = 0;
		所有玩家(队伍1).target = 空;
	}
}

规则("[VishkarEvent]: 费斯卡光子护盾")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 存活(事件玩家), 事件玩家.target != 空), 当前数组元素) == 真;
	}
	
	动作
	{
		等待(0.016, 无视条件);
		为玩家添加生命池(事件玩家, 护盾, 最大生命值(事件玩家.target) * 0.20 > 50 ? 最大生命值(事件玩家.target) * 0.20 : 50, 真, 假);
		事件玩家.healthId[2] = 最后创建的生命池;
		等待直到(!存活(事件玩家.target) || 事件玩家.target == 空, 事件玩家.target.eventDuration);
		移除玩家的生命池(事件玩家.healthId[2]);
		事件玩家.healthId[2] = 空;
	}
}

规则("[VishkarEvent]: 费斯卡呼吸机")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 15), 当前数组元素) == 真;
	}

	动作
	{
		事件玩家.ignoreObstrucVis = 真;
		等待(事件玩家.eventDuration, 无视条件);
		事件玩家.ignoreObstrucVis = 假;
	}
}

规则("[VishkarEvent]: 向我靠拢")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 16), 当前数组元素) == 真;
	}

	动作
	{
		等待(5.000, 无视条件);
		事件玩家.eventEffectPlayers = 已过滤的数组(所有存活玩家(队伍1), 相距距离(事件玩家, 当前数组元素) <= 15 && 在视线内(事件玩家, 当前数组元素, 屏障不会阻挡视线) == 真 && !具有状态(当前数组元素, 无敌));
		// 设置状态(事件玩家.eventEffectPlayers, 事件玩家, 无敌, 2.5);
		事件玩家.eventEffectPlayers.invincible = 数组(真, 事件玩家, 2.5);
		等待(0.5, 无视条件);
		事件玩家.eventEffectPlayers = 空;
		如条件为“真”则循环;
	}
}

规则("[VishkarEvent]: 向我靠拢")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), !具有状态(事件玩家, 无敌), 数量(事件玩家.invincible) >= 3), 当前数组元素) == 真;
	}

	动作
	{
		设置状态(事件玩家, 事件玩家.invincible[1], 无敌, 事件玩家.invincible[2]);
		创建效果(所有玩家(所有队伍), 巴蒂斯特维生力场保护效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
		事件玩家.invincibleEffect = 最后创建的实体;
		小字体信息(事件玩家, 自定义字符串("  {0}  {1}（{2}） 为你提供 2.5秒无敌效果", 技能图标字符串(英雄(巴蒂斯特), 按钮(技能2)), 事件玩家.invincible[1], 所用英雄(事件玩家.invincible[1])));
		等待(2.500, 无视条件);
		清除状态(事件玩家, 无敌);
		消除效果(事件玩家.invincibleEffect);
		事件玩家.invincibleEffect = 空;
		事件玩家.invincible = 空;
	}
}

规则("[VishkarEvent]: 我独自闯关")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 17), 当前数组元素) == 真;
	}

	动作
	{
		等待(0.050, 无视条件);
		IF(数量(范围内玩家(事件玩家, 8, 队伍1, 表面)) > 0);
			事件玩家.mod_dmg_taken = -15;
			事件玩家.mod_heal_event = 30;
			事件玩家.mod_speed_event = 12.5;
			设置受到的击退(事件玩家, 75);
			小字体信息(事件玩家, 自定义字符串("  {0}  已获得 15% 伤害减免", 图标字符串(方块)));
			小字体信息(事件玩家, 自定义字符串("  {0}  已获得 30% 治疗增益", 图标字符串(方块)));
			小字体信息(事件玩家, 自定义字符串("  {0}  已获得 12.5% 移速加成", 图标字符串(方块)));
			小字体信息(事件玩家, 自定义字符串("  {0}  已获得 25% 击退抵抗", 图标字符串(方块)));
		ELSE;
			大字体信息(事件玩家, 自定义字符串("我独自闯关！"));
			事件玩家.mod_dmg_taken = -30;
			事件玩家.mod_heal_event = 60;
			事件玩家.mod_speed_event = 25;
			设置受到的击退(事件玩家, 50);
			小字体信息(事件玩家, 自定义字符串("  {0}  已获得 30% 伤害减免", 图标字符串(梅花)));
			小字体信息(事件玩家, 自定义字符串("  {0}  已获得 60% 治疗增益", 图标字符串(梅花)));
			小字体信息(事件玩家, 自定义字符串("  {0}  已获得 25% 移速加成", 图标字符串(梅花)));
			小字体信息(事件玩家, 自定义字符串("  {0}  已获得 50% 击退抵抗", 图标字符串(梅花)));
		END;
		调用子程序(updatePlayerStats);
		等待(事件玩家.eventDuration, 无视条件);
		设置受到的击退(事件玩家, 100);
		事件玩家.mod_dmg_taken = 0;
		事件玩家.mod_heal_event = 0;
		事件玩家.mod_speed_event = 0;
		调用子程序(updatePlayerStats);
	}
}

规则("[VishkarEvent]: 坚定")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 18), 当前数组元素) == 真;
	}

	动作
	{
		事件玩家.knockback = -95;
		调用子程序(updatePlayerStats);
		等待(事件玩家.eventDuration, 无视条件);
		事件玩家.knockback = 0;
		调用子程序(updatePlayerStats);
	}
}

规则("[VishkarEvent]: 坚定")
{
	事件
	{
		玩家受到击退;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 18), 当前数组元素) == 真;
	}

	动作
	{
		根据条件跳过(事件玩家.mod_dmg_taken == -75, 2);
		事件玩家.mod_dmg_taken -= 5;
		调用子程序(updatePlayerStats);
		// 开始持续治疗(事件玩家, 事件玩家, 1, 最大生命值(事件玩家) * 0.08);
		治疗(事件玩家, 事件玩家, 最大生命值(事件玩家) * 0.08);
	}
}

规则("[VishkarEvent]: 胜利意志")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 19, 生命值(事件玩家) <= 最大生命值(事件玩家) * 0.3), 当前数组元素) == 真;
	}

	动作
	{
		设置状态(事件玩家, 事件玩家, 相移, 0.016);
		等待(0.016, 无视条件);
		清除状态(事件玩家, 无敌);
		消除效果(事件玩家.invincibleEffect);
		等待(0.016, 无视条件);
		根据条件中止(!存活(事件玩家));
		设置状态(事件玩家, 事件玩家, 无敌, 5);
		创建效果(所有玩家(所有队伍), 巴蒂斯特维生力场保护效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
		事件玩家.invincibleEffect = 最后创建的实体;
		创建效果(所有玩家(所有队伍), 巴蒂斯特维生力场保护声音, 颜色(队伍1), 事件玩家, 200, 位置和半径);
        事件玩家.eventEffect = 最后创建的实体;
		大字体信息(事件玩家, 自定义字符串("胜利意志！"));
		调用子程序(resetPlayerCD);
		// 开始持续治疗(事件玩家, 事件玩家, 1, 最大生命值(事件玩家) * 0.08);
		治疗(事件玩家, 事件玩家, 99999);
		等待直到(死亡(事件玩家), 5);
		事件玩家.eventDuration = 0;
		清除状态(事件玩家, 无敌);
		消除效果(事件玩家.invincibleEffect);
		事件玩家.invincibleEffect = 空;
		调用子程序(clearEventEffect);
	}
}

规则("[VishkarEvent]: 任务：菲迪皮德斯之力")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 20, 速度(事件玩家) != 0, 事件玩家.eventMission <= 42.195), 当前数组元素) == 真;
	}

	动作
	{
		根据条件跳过(事件玩家.hudTextId != 空, 2);
		创建HUD文本(事件玩家, 空, 自定义字符串("\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r"), 自定义字符串("{0}/42.195", 事件玩家.eventMission), 顶部, 9, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.hudTextId = 上一个文本ID;
		等待(0.5, 当为“假”时中止);
		事件玩家.eventMission += 0.5;
		如条件为“真”则循环;
	}
}

规则("[VishkarEvent]: 任务：菲迪皮德斯之力")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 20), 当前数组元素) == 真;
	}
	
	动作
	{
		等待直到(事件玩家.eventMission >= 42.195 || 事件玩家.eventId == 空, 事件玩家.eventDuration+1.5);
		等待(0.016, 无视条件);
		IF(事件玩家.eventMission >= 42.195);
			大字体信息(事件玩家, 自定义字符串("任务：菲迪皮德斯之力 成功！"));
			小字体信息(事件玩家, 自定义字符串("  {0}  任务奖励：永久获得 {1}% 移动速度加成", 技能图标字符串(英雄(士兵：76), 按钮(技能1)), 5));
			事件玩家.mod_speed_perma += 5;
			调用子程序(updatePlayerStats);
		ELSE;
			大字体信息(事件玩家, 自定义字符串("任务：菲迪皮德斯之力 失败"));
		END;
		事件玩家.eventMission = 0;
		消除HUD文本(事件玩家.hudTextId);
		事件玩家.hudTextId = 空;
		事件玩家.eventDuration = 0;
	}
}

规则("[VishkarEvent]: 心之钢 Pro")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 21), 当前数组元素) == 真;
	}

	动作
	{
		事件玩家.heart_steel += 6;
		IF(事件玩家.heart_steel > 0);
			设置最大生命值(事件玩家, 100 + 事件玩家.heart_steel * 2);
			等待(事件玩家.eventDuration, 无视条件);
			调用子程序(setPlayerHP);
		Else;
			事件玩家.eventDuration = 0;
		END;
	}
}

规则("[VishkarEvent]: 数值之力")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 22), 当前数组元素) == 真;
	}

	动作
	{
		事件玩家.mod_heal_event = 400;
		事件玩家.heal_recv = 400;
		调用子程序(updatePlayerStats);
		创建效果(所有玩家(所有队伍), 安娜生物手雷增疗效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
        事件玩家.eventEffect = 最后创建的实体;
        播放效果(事件玩家, 安娜生物手雷增疗声音, 颜色(白色), 事件玩家, 200);
		等待(事件玩家.eventDuration, 无视条件);
		事件玩家.mod_heal_event = 0;
		事件玩家.heal_recv = 0;
		调用子程序(updatePlayerStats);
		调用子程序(clearEventEffect);
	}
}

规则("[VishkarEvent]: 我按Q辣")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 23, 正在移动(事件玩家), 速度(事件玩家) != 0), 当前数组元素) == 真;
	}

	动作
	{
		等待(1.00, 当为“假”时中止);
		设置终极技能充能(事件玩家, 终极技能充能百分比(事件玩家) + 10);
		如条件为“真”则循环;
		根据条件跳过(事件玩家.isWinner, 1);
		设置终极技能充能(事件玩家, 0);
	}
}

规则("[VishkarEvent]: 我按Q辣")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 0, 事件玩家.eventId == 23, 正在使用终极技能(事件玩家)), 当前数组元素) == 真;
	}

	动作
	{
		调用子程序(resetPlayerCD);
		事件玩家.mod_dmg_taken = -75;
		调用子程序(updatePlayerStats);
		等待直到(!正在使用终极技能(事件玩家), 事件玩家.eventDuration);
		事件玩家.mod_dmg_taken = 0;
		调用子程序(updatePlayerStats);
	}
}

// debuff

规则("[VishkarEvent]: 重力异常")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 1, 事件玩家.eventId == 0), 当前数组元素) == 真;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 无视条件);
		事件玩家.mod_speed_event = -40;
		调用子程序(updatePlayerStats);
		设置引力(事件玩家, 100 + 70);
		创建效果(所有玩家(所有队伍), “西格玛”引力乱流目标效果, 颜色(队伍2), 事件玩家, 200, 位置和半径);
        事件玩家.eventEffect[0] = 最后创建的实体;
        创建效果(所有玩家(所有队伍), “西格玛”引力乱流目标声音, 颜色(队伍2), 事件玩家, 200, 位置和半径);
        事件玩家.eventEffect[1] = 最后创建的实体;
		等待(事件玩家.eventDuration, 无视条件);
		事件玩家.mod_speed_event = 0;
		调用子程序(updatePlayerStats);
		调用子程序(clearEventEffect);
		设置引力(事件玩家, 100);
	}
}

规则("[VishkarEvent]: 电磁脉冲")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		// 单次赋值(全局.dlcVishkarEvent) == 真;
		// 已重生(事件玩家) == 真;
		// 事件玩家.eventType == 1;
		// 事件玩家.eventId == 1;
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 1, 事件玩家.eventId == 1), 当前数组元素) == 真;
	}

	动作
	{
		停止追踪玩家变量(事件玩家, hack_timer);
		设置状态(事件玩家, 首个(选择英雄的玩家(英雄(堡垒), 队伍2)), 被入侵, 8);
		// 创建效果(事件玩家, “黑影”黑客入侵完成声音, 颜色(队伍2), 事件玩家, 200, 位置和半径);
        // 事件玩家.eventEffect = 最后创建的实体;
        // 播放效果(所有玩家(所有队伍), “黑影”电磁脉冲爆炸效果, 颜色(队伍2), 事件玩家, 200);
        播放效果(所有玩家(所有队伍), “黑影”黑客入侵完成开始效果, 颜色(队伍2), 事件玩家, 200);
		事件玩家.hack_timer = 8;
		追踪玩家变量频率(事件玩家, hack_timer, 0, 1, 全部禁用);
	}
}

规则("[VishkarEvent]: 吸血鬼")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 1, 事件玩家.eventId == 2), 当前数组元素) == 真;
		对任意为“真”(数组(已过滤的数组(所有存活玩家(队伍1), 正在使用技能1(当前数组元素)) > 0, 已过滤的数组(所有存活玩家(队伍1), 正在使用技能2(当前数组元素)) > 0), 当前数组元素) == 真;
	}

	动作
	{
		调用子程序(stopCombatRegen);
		播放效果(所有玩家(所有队伍), 莫伊拉消散重现效果, 颜色(队伍2), 事件玩家, 200);
		伤害(事件玩家, 首个(已排序的数组(已过滤的数组(所有存活玩家(队伍1), 正在使用技能1(当前数组元素) || 正在使用技能2(当前数组元素)), 相距距离(事件玩家, 当前数组元素))), 最大生命值(事件玩家) * 0.1);
		等待(较大(0.500, 服务器负载 / 100 * 0.032), 无视条件);
		如条件为“真”则循环;
	}
}

规则("[VishkarEvent]: 易损")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 1, 事件玩家.eventId == 3), 当前数组元素) == 真;
	}

	动作
	{
		创建效果(所有玩家(所有队伍), 禅雅塔乱目标效果, 颜色(队伍2), 事件玩家, 200, 位置和半径);
        事件玩家.eventEffect[0] = 最后创建的实体;
        创建效果(所有玩家(所有队伍), 禅雅塔乱目标声音, 颜色(队伍2), 事件玩家, 200, 位置和半径);
        事件玩家.eventEffect[1] = 最后创建的实体;
		事件玩家.mod_dmg_taken = 25;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		调用子程序(updatePlayerStats);
		等待(事件玩家.eventDuration, 无视条件);
		事件玩家.mod_dmg_taken = 0;
		调用子程序(updatePlayerStats);
		调用子程序(clearEventEffect);
	}
}

规则("[VishkarEvent]: 限速40")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 1, 事件玩家.eventId == 4, 正在移动(事件玩家), 速度(事件玩家) != 0), 当前数组元素) == 真;
	}

	动作
	{
		调用子程序(stopCombatRegen);
		等待(1, 当为“假”时中止);
		根据条件跳过(具有状态(事件玩家, 燃烧), 1);
		设置状态(事件玩家, 空, 燃烧, 3);
		开始持续伤害(事件玩家, 空, 1, 25 + 取整(最大生命值(事件玩家) * 0.075, 至最近));
		等待(0.032, 无视条件);
		如条件为“真”则循环;
		清除状态(事件玩家, 燃烧);
	}
}

规则("[VishkarEvent]: 引力异常")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 存活(事件玩家), 事件玩家.eventType == 1, 事件玩家.eventId == 5), 当前数组元素) == 真;
	}

	动作
	{
		根据条件跳过(事件玩家.mod_speed_event != 0, 2);
		事件玩家.mod_speed_event -= 25;
		调用子程序(updatePlayerStats);
		根据条件跳过(事件玩家.eventEffect != 空, 4);
        创建效果(所有玩家(所有队伍), “西格玛”引力乱流目标效果, 颜色(队伍2), 事件玩家, 200, 位置和半径);
        事件玩家.eventEffect[0] = 最后创建的实体;
        创建效果(所有玩家(所有队伍), “西格玛”引力乱流目标声音, 颜色(队伍2), 事件玩家, 200, 位置和半径);
        事件玩家.eventEffect[1] = 最后创建的实体;
		施加推力(事件玩家, 方向(事件玩家, 首个(已排序的数组(所有玩家(队伍2), 相距距离(事件玩家, 当前数组元素)))), 正在空中(事件玩家) ? 0.425 : 0.825, 至地图, 合并相反运动);
		等待(0.016, 无视条件);
		// 等待(事件玩家.eventDuration, 无视条件);
		如条件为“真”则循环;
		事件玩家.mod_speed_event = 0;
		调用子程序(updatePlayerStats);
		调用子程序(clearEventEffect);
	}
}

规则("[VishkarEvent]: 骨质疏松")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 1, 事件玩家.eventId == 6), 当前数组元素) == 真;
	}

	动作
	{
		根据条件跳过(事件玩家.eventEffect != 空, 2);
        创建效果(所有玩家(所有队伍), 美冰冻效果, 颜色(队伍2), 事件玩家, 200, 位置和半径);
        事件玩家.eventEffect = 最后创建的实体;
		While(事件玩家.mod_speed_event != -50);
			事件玩家.mod_speed_event -= 5;
			调用子程序(updatePlayerStats);
			等待(1.000, 无视条件);
		END;
		调用子程序(updatePlayerStats);
		调用子程序(clearEventEffect);
	}
}

规则("[VishkarEvent]: 电磁脉冲 ProMax")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 1, 事件玩家.eventId == 7), 当前数组元素) == 真;
	}

	动作
	{
		已过滤的数组(所有玩家(队伍1), 相距距离(事件玩家, 当前数组元素) <= 75).empProMax = 事件玩家;
		播放效果(所有玩家(所有队伍), “黑影”电磁脉冲爆炸效果, 颜色(队伍2), 事件玩家, 200);
		等待(事件玩家.eventDuration - 1, 无视条件);
		所有玩家(队伍1).empProMax = 空;
	}
}

规则("[VishkarEvent]: 电磁脉冲 ProMax")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 具有状态(事件玩家, 被入侵) != 真, 事件玩家.empProMax != 空, 事件玩家.hack_timer == 0), 当前数组元素) == 真;
	}

	动作
	{
		停止追踪玩家变量(事件玩家, hack_timer);
		事件玩家.hack_timer = 较大(0, 事件玩家.empProMax == 事件玩家 ? 8 : 8 - 相距距离(事件玩家, 事件玩家.empProMax) * 0.08);
		根据条件跳过(事件玩家.hack_timer <= 0.9, 1);
		播放效果(所有玩家(所有队伍), “黑影”黑客入侵完成开始效果, 颜色(队伍2), 事件玩家, 200);
		设置状态(事件玩家, 事件玩家.empProMax, 被入侵, 事件玩家.hack_timer);
		追踪玩家变量频率(事件玩家, hack_timer, 0, 1, 全部禁用);
		等待(事件玩家.hack_timer, 无视条件);
		事件玩家.hack_timer = 0;
		事件玩家.empProMax = 空;
	}
}

规则("[VishkarEvent]: 能量泄漏")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 1, 事件玩家.eventId == 8), 当前数组元素) == 真;
		对任意为“真”(数组(
			正在使用技能 1(事件玩家),
			正在使用技能 2(事件玩家)
		), 当前数组元素) == 真;
	}

	动作
	{
		调用子程序(stopCombatRegen);
		等待(0.016, 无视条件);
		播放效果(所有玩家(所有队伍), “回声”黏性炸弹爆炸效果, 颜色(队伍2), 事件玩家, 200);
		伤害(事件玩家, 空, 最大生命值(事件玩家) * 0.25);
		等待(1.000, 无视条件);
		如条件为“真”则循环;
	}
}

规则("[VishkarEvent]: 生命在于运动")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 存活(事件玩家), 事件玩家.eventType == 1, 事件玩家.eventId == 9), 当前数组元素) == 真;
	}

	动作
	{
		调用子程序(stopCombatRegen);
		等待(0.016, 无视条件);
		伤害(事件玩家, 空, 取整(最大生命值(事件玩家) * 正在移动(事件玩家) ? 0.03 : 0.015, 上));
		设置状态(事件玩家, 空, 燃烧, 1.000);
		等待(0.960, 无视条件);
		如条件为“真”则循环;
	}
}

规则("[VishkarEvent]: 有难同当")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 1, 事件玩家.eventId == 10), 当前数组元素) == 真;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 无视条件);
		创建效果(所有玩家(所有队伍), 托比昂热力过载效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
		事件玩家.eventEffect = 最后创建的实体;
		等待(事件玩家.eventDuration, 无视条件);
		调用子程序(clearEventEffect);
	}
}

规则("[VishkarEvent]: 有难同当")
{
	事件
	{
		玩家受到伤害;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 1, 事件玩家.eventId == 10), 当前数组元素) == 真;
		所用英雄(攻击方) == 英雄(堡垒);
		事件技能 != 空;
	}

	动作
	{
		等待(0.016, 无视条件);
		伤害(已过滤的数组(所有存活玩家(队伍1), !具有状态(当前数组元素, 相移) && !具有状态(当前数组元素, 无敌) && 相距距离(事件玩家, 当前数组元素) <= 15 && 事件玩家 != 当前数组元素), 攻击方, 事件伤害 * 0.75);
		等待(0.016, 无视条件);
	}
}

规则("[VishkarEvent]: 狂欢盛宴")
{
	事件
	{
		玩家阵亡;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 1, 事件玩家.eventId == 11, 所用英雄(攻击方) == 英雄(堡垒)), 当前数组元素) == 真;
	}

	动作
	{
		大字体信息(所有玩家(所有队伍), 自定义字符串("盛宴！"));
		小字体信息(所有玩家(队伍1), 自定义字符串("  {0} {1} 阵亡触发了狂欢盛宴", 图标字符串(警告), 事件玩家));
		所有玩家(队伍2).hasNano = 真;
		全局.berserkerTime += 10;
		等待(5, 无视条件);
	}
}

规则("[VishkarEvent]: 狂欢盛宴计时器")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.berserkerTime != 0;
	}

	动作
	{
		等待(2, 无视条件);
		全局.berserkerTime -= 2;
		如条件为“真”则循环;
		所有玩家(队伍2).hasNano = 假;
	}
}

规则("[VishkarEvent]: 无能的丈夫/妻子")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 1, 事件玩家.eventId == 12), 当前数组元素) == 真;
	}

	动作
	{
		设置状态(已过滤的数组(所有存活玩家(队伍1), 相距距离(事件玩家, 当前数组元素) <= 45 && 事件玩家 != 当前数组元素 ), 空, 击倒, 2);
		等待(2, 无视条件);
	}
}

规则("[VishkarEvent]: 重伤")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 1, 事件玩家.eventId == 13), 当前数组元素) == 真;
	}

	动作
	{
		事件玩家.mod_heal_event = -85;
		事件玩家.heal_recv = -85;
		调用子程序(updatePlayerStats);
		创建效果(所有玩家(所有队伍), 安娜生物手雷禁疗效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
        事件玩家.eventEffect = 最后创建的实体;
        播放效果(事件玩家, 安娜生物手雷禁疗声音, 颜色(白色), 事件玩家, 200);
		等待(事件玩家.eventDuration, 无视条件);
		调用子程序(clearEventEffect);
		事件玩家.mod_heal_event = 0;
		事件玩家.heal_recv = 0;
		调用子程序(updatePlayerStats);
		调用子程序(clearEventEffect);
	}
}

规则("[VishkarEvent]: 减半")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 事件玩家.eventType == 1, 事件玩家.eventId == 14, 生命值(事件玩家) != 0), 当前数组元素) == 真;
	}

	动作
	{
		调用子程序(stopCombatRegen);
		IF(生命值(事件玩家) <= 最大生命值(事件玩家) * 0.050);
			击杀(事件玩家, 事件玩家);
			播放效果(所有玩家(所有队伍), D.Va自毁爆炸效果, 颜色(队伍2), 事件玩家, 200);
		ELSE;
			等待(5, 无视条件);
			开始持续伤害(事件玩家, 空, 1, 生命值(事件玩家) * 0.50);
			播放效果(所有玩家(所有队伍), 查莉娅粒子炮爆炸效果, 颜色(队伍2), 事件玩家, 3);
		End;
		如条件为“真”则循环;
	}
}

规则("[VishkarEvent]: 舍己为人")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 1, 事件玩家.eventId == 15), 当前数组元素) == 真;
	}

	动作
	{
		IF(最大生命值(事件玩家) <= 125);
			事件玩家.eventDuration = 0;
		ELSE;
			从数组中移除(所有玩家(队伍1), 事件玩家).heart_steel += 1;
			从数组中移除(所有玩家(队伍1), 事件玩家).setPlayerHP = 真;
			事件玩家.heart_steel -= 1 * (数量(从数组中移除(所有玩家(队伍1), 事件玩家)));
			调用子程序(setPlayerHP);
		END;
		播放效果(所有玩家(所有队伍), 奥丽莎站住别动内爆效果, 颜色(队伍1), 事件玩家, 200);
		播放效果(所有玩家(所有队伍), 有益选择效果 , 颜色(绿色), 事件玩家, 100);
		等待(事件玩家.eventDuration, 无视条件);
	}
}

规则("[VishkarEvent]: 舍己为人")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.setPlayerHP), 当前数组元素) == 真;
	}

	动作
	{
		调用子程序(setPlayerHP);
		事件玩家.setPlayerHP = 假;
	}
}

// mech

规则("[VishkarEvent]: 极限挑战")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 2, 事件玩家.eventId == 0), 当前数组元素) == 真;
	}

	动作
	{
		事件玩家.mod_heal_event = -1000;
		事件玩家.heal_recv = -1000;
		创建效果(所有玩家(所有队伍), 安娜生物手雷禁疗效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
        事件玩家.eventEffect = 最后创建的实体;
        播放效果(事件玩家, 安娜生物手雷禁疗声音, 颜色(白色), 事件玩家, 200);
		设置玩家生命值(事件玩家, 最大生命值(事件玩家) * 0.3);
		事件玩家.mod_dmg_taken = -99;
		调用子程序(updatePlayerStats);
		等待直到(死亡(事件玩家), 事件玩家.eventDuration);
		事件玩家.mod_dmg_taken = 0;
		调用子程序(updatePlayerStats);
		调用子程序(clearEventEffect);
		事件玩家.mod_heal_event = 0;
		事件玩家.heal_recv = 0;
		调用子程序(updatePlayerStats);
		事件玩家.eventDuration = 0;
	}
}

规则("[VishkarEvent]: 极限挑战")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 2, 事件玩家.eventId == 0), 当前数组元素) == 真;
		(生命值(事件玩家) > 最大生命值(事件玩家) * 0.3) == 真;
	}

	动作
	{
		等待(0.5, 当为“假”时中止);
		设置玩家生命值(事件玩家, 最大生命值(事件玩家) * 0.3);
		等待(5, 无视条件);
		如条件为“真”则循环;
	}
}

规则("[VishkarEvent]: 纳米战甲")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 2, 事件玩家.eventId == 1), 当前数组元素) == 真;
	}

	动作
	{
		等待(0.016, 无视条件);
		等待直到(存活(事件玩家), 事件玩家.eventDuration);
		为玩家添加生命池(事件玩家, 生命值, 最大生命值(事件玩家) * 8, 假, 假);
		事件玩家.healthId[0] = 最后创建的生命池;
		事件玩家.mod_speed_event = -25;
		调用子程序(updatePlayerStats);
		等待(事件玩家.eventDuration, 无视条件);
		事件玩家.mod_speed_event = 0;
		调用子程序(updatePlayerStats);
		移除玩家的生命池(事件玩家.healthId[0]);
		事件玩家.healthId[0] = 空;
	}
}

规则("[VishkarEvent]: 赌徒")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 2, 事件玩家.eventId == 2, 按钮被按下(事件玩家, 按钮(装填))), 当前数组元素) == 真;
	}

	动作
	{
		等待(0.500, 当为“假”时中止);
		IF(随机整数(0, 100) <= 50);
			事件玩家.heart_steel -= 5;
			事件玩家.dlcTimeChallenge = 事件玩家.dlcTimeChallenge > 0 ? 0 : 事件玩家.dlcTimeChallenge - 1;
			小字体信息(事件玩家, 自定义字符串("  {0}  输！失去 5% 最大生命值", 图标字符串(方块)));
		Else;
			事件玩家.heart_steel += 5;
			事件玩家.dlcTimeChallenge += 1;
			小字体信息(事件玩家, 自定义字符串("  {0}  赢！获得 5% 最大生命值", 图标字符串(梅花)));
		End;
		等待(0.016, 无视条件);
		调用子程序(setPlayerHP);
		等待(0.016, 无视条件);
		事件玩家.eventDuration = 0;
	}
}

规则("[VishkarEvent]: 有点松弛")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 2, 事件玩家.eventId == 3, 正在移动(事件玩家), 速度(事件玩家) != 0), 当前数组元素) == 真;
	}

	动作
	{
		等待(0.016, 无视条件);
		根据条件跳过(事件玩家.eventEffect != 空, 2);
		创建效果(所有玩家(所有队伍), “破坏球”重力坠击火焰效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
		事件玩家.eventEffect = 最后创建的实体;
		创建效果(已过滤的数组(所有玩家(队伍1), !当前数组元素.ignoreObstrucVis), 云, 数组随机取值(数组(颜色(黄色), 颜色(绿色), 颜色(橙色), 颜色(灰绿色), 颜色(紫色))), 单次赋值(所选位置(事件玩家)), 12, 可见，位置和半径);
		等待(0.016, 无视条件);
		修改玩家变量(事件玩家, obstrucVis, 添加至数组, 最后创建的实体);
		等待(1.000, 无视条件);
		如条件为“真”则循环;
		调用子程序(clearEventEffect);
	}
}

规则("[VishkarEvent]: 有点松弛")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		事件玩家.obstrucVis != 空数组;
		数量(事件玩家.obstrucVis) > 0;
	}

	动作
	{
		等待(20, 当为“假”时中止);
		消除效果(首个(事件玩家.obstrucVis));
		修改玩家变量(事件玩家, obstrucVis, 根据值从数组中移除, 首个(事件玩家.obstrucVis));
		等待(0.500, 无视条件);
		如条件为“真”则循环;
	}
}

规则("[VishkarEvent]: 体积膨胀")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 2, 事件玩家.eventId == 4), 当前数组元素) == 真;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 无视条件);
		事件玩家.sizeHealth = 4;
		开始调整玩家大小(事件玩家, 1.75, 假);
		开始调整障碍大小(事件玩家, 1.75, 假);
		开始修改英雄语音(事件玩家, 0.500, 假);
		事件玩家.mod_dmg_taken = -20;
		调用子程序(updatePlayerStats);
		调用子程序(setPlayerHP);
		等待直到(事件玩家.eventId == -1, 事件玩家.eventDuration);
		事件玩家.sizeHealth = 1;
		调用子程序(setPlayerHP);
		事件玩家.mod_dmg_taken = 0;
		调用子程序(updatePlayerStats);
		停止调整玩家大小(事件玩家);
		停止调整障碍大小(事件玩家);
		停止修改英雄语音(事件玩家);
	}
}

规则("[VishkarEvent]: 迷你形态")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 2, 事件玩家.eventId == 5), 当前数组元素) == 真;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 无视条件);
		事件玩家.sizeHealth = 0.5;
		开始调整玩家大小(事件玩家, 0.4, 假);
		开始调整障碍大小(事件玩家, 0.4, 假);
		开始修改英雄语音(事件玩家, 1.500, 假);
		事件玩家.mod_speed_event = 25;
		调用子程序(updatePlayerStats);
		调用子程序(setPlayerHP);
		等待直到(事件玩家.eventId == -1, 事件玩家.eventDuration);
		事件玩家.sizeHealth = 1;
		调用子程序(setPlayerHP);
		事件玩家.mod_speed_event = 0;
		调用子程序(updatePlayerStats);
		停止调整玩家大小(事件玩家);
		停止调整障碍大小(事件玩家);
		停止修改英雄语音(事件玩家);
	}
}

规则("[VishkarEvent]: 悄悄地进村")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		// 单次赋值(全局.dlcVishkarEvent) == 真;
		// 已重生(事件玩家) == 真;
		// 事件玩家.eventType == 2;
		// 事件玩家.eventId == 6;
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 2, 事件玩家.eventId == 6), 当前数组元素) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
	}

	动作
	{
		创建效果(所有玩家(所有队伍), “死神”幽灵形态效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
		事件玩家.eventEffect = 最后创建的实体;
		事件玩家.targetSilence = 真;
		事件玩家.mod_speed_event -= 25;
		调用子程序(updatePlayerStats);
		等待直到(按钮被按下(事件玩家, 按钮(蹲下)) == 假, 事件玩家.eventDuration);
		事件玩家.targetSilence = 假;
		事件玩家.mod_speed_event = 0;
		调用子程序(updatePlayerStats);
		调用子程序(clearEventEffect);
		等待(0.250, 无视条件);
	}
}

规则("[VishkarEvent]: 紧急避障")
{
	事件
	{
		玩家受到伤害;
		队伍1;
		全部;
	}

	条件
	{
		// 单次赋值(全局.dlcVishkarEvent) == 真;
		// 已重生(事件玩家) == 真;
		// 事件玩家.eventType == 2;
		// 事件玩家.eventId == 7;
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 2, 事件玩家.eventId == 7), 当前数组元素) == 真;
	}

	动作
	{
		等待(0.032, 当为“假”时中止);
		事件玩家.mod_speed_event += 30;
		调用子程序(updatePlayerStats);
		创建效果(所有玩家(所有队伍), “士兵：76”疾跑效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
		事件玩家.eventEffect = 最后创建的实体;
		等待(3, 无视条件);
		事件玩家.mod_speed_event = 0;
		调用子程序(updatePlayerStats);
		调用子程序(clearEventEffect);
	}
}

规则("[VishkarEvent]: 逆风而行")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 2, 事件玩家.eventId == 8), 当前数组元素) == 真;
	}

	动作
	{
		等待(0.032, 当为“假”时中止);
		停止限制阈值(事件玩家);
		开始限制阈值(事件玩家, 0, 0, 0, 1, 0, 事件玩家.eventDuration);
		事件玩家.mod_speed_event += 60;
		事件玩家.mod_dmg_taken = -60;
		调用子程序(updatePlayerStats);
		创建效果(所有玩家(所有队伍), “士兵：76”疾跑效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
		事件玩家.eventEffect = 最后创建的实体;
		等待(事件玩家.eventDuration, 无视条件);
		停止限制阈值(事件玩家);
		事件玩家.mod_speed_event = 0;
		事件玩家.mod_dmg_taken = 0;
		调用子程序(updatePlayerStats);
		调用子程序(clearEventEffect);
	}
}

规则("[VishkarEvent]: 刹车失灵")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 2, 事件玩家.eventId == 9), 当前数组元素) == 真;
	}

	动作
	{
		开始定向阈值(事件玩家, 前, 1, 至玩家, 替换现有阈值, 无);
		等待(事件玩家.eventDuration, 无视条件);
		停止定向阈值(事件玩家);
	}
}

规则("[VishkarEvent]: 刹车失灵")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 2, 事件玩家.eventId == 9), 当前数组元素) == 真;
	}

	动作
	{
		While(事件玩家.mod_speed_event < 75);
			事件玩家.mod_speed_event += 5;
			根据条件跳过(事件玩家.mod_dmg_taken == 50, 1);
			事件玩家.mod_dmg_taken += 5;
			调用子程序(updatePlayerStats);
			等待(1.000, 无视条件);
		End;
	}
}

规则("[VishkarEvent]: 冲锋激励")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 2, 事件玩家.eventId == 10, 正在移动(事件玩家), 速度(事件玩家) != 0, 事件玩家.healthId[1] == 空), 当前数组元素) == 真;
	}

	动作
	{
		根据条件跳过(事件玩家.hudTextId != 空, 2);
		创建HUD文本(事件玩家, 空, 自定义字符串(
			"\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r"),
			自定义字符串("{0}/300", 事件玩家.eventMission), 顶部, 9, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.hudTextId = 上一个文本ID;
		等待(5.000, 当为“假”时中止);
		根据条件跳过(事件玩家.eventMission >= 300, 2);
		事件玩家.eventMission += 100;
		等待(0.016, 无视条件);
		如条件为“真”则循环;
		// 移除玩家的生命池(事件玩家.healthId[1]);
		// 事件玩家.healthId[1] = 空;
	}
}

规则("[VishkarEvent]: 冲锋激励")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 2, 事件玩家.eventId == 10, 事件玩家.eventMission == 300), 当前数组元素) == 真;
	}

	动作
	{
		// 等待(5.000, 当为“假”时中止);
		根据条件跳过(事件玩家.healthId[1] == 空, 1);
		移除玩家的生命池(事件玩家.healthId[1]);
		// 根据条件跳过(事件玩家.eventMission != 300, 2);
		为玩家添加生命池(事件玩家, 护甲, 事件玩家.eventMission, 假, 假);
		事件玩家.healthId[1] = 最后创建的生命池;
		事件玩家.eventMission = 0;
		等待(15, 无视条件);
		移除玩家的生命池(事件玩家.healthId[1]);
		事件玩家.healthId[1] = 空;
	}
}

规则("[VishkarEvent]: 生命在于反击")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 2, 事件玩家.eventId == 11, 标准化生命值(事件玩家) != 1), 当前数组元素) == 真;
	}

	动作
	{
		事件玩家.mod_speed_event = (最大生命值(事件玩家) - 生命值(事件玩家)) / 最大生命值(事件玩家) * 100 < 75 ? (最大生命值(事件玩家) - 生命值(事件玩家)) / 最大生命值(事件玩家) * 100 : 75;
		事件玩家.mod_dmg_taken = (最大生命值(事件玩家) - 生命值(事件玩家)) / 最大生命值(事件玩家) * 100 < 75? (最大生命值(事件玩家) - 生命值(事件玩家)) / 最大生命值(事件玩家) * 100 : 50;
		调用子程序(updatePlayerStats);
		等待(1.000, 无视条件);
		如条件为“真”则循环;
		事件玩家.mod_speed_event = 0;
		事件玩家.mod_dmg_taken = 0;
		调用子程序(updatePlayerStats);
	}
}

规则("[VishkarEvent]: 屁动力")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 2, 事件玩家.eventId == 12, 按钮被按下(事件玩家, 按钮(跳跃))), 当前数组元素) == 真;
	}

	动作
	{
		根据条件跳过(事件玩家.nanoEffect != 空, 4);
		事件玩家.mod_dmg_taken = -50;
		调用子程序(updatePlayerStats);
		创建效果(所有玩家(所有队伍), 安娜纳米激素强化效果, 颜色(队伍2), 事件玩家, 200, 可见，位置和半径);
		事件玩家.nanoEffect = 最后创建的实体;
		施加推力(事件玩家, 面朝方向(事件玩家), 15, 至地图, 取消相反运动);
		等待(0.016, 无视条件);
		如条件为“真”则循环;
		事件玩家.mod_dmg_taken = 0;
		调用子程序(updatePlayerStats);
		消除效果(事件玩家.nanoEffect);
		事件玩家.nanoEffect = 空;
	}
}

规则("[VishkarEvent]: 赌徒：竞速挑战")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 已重生(事件玩家), 事件玩家.eventType == 2, 事件玩家.eventId == 13, 按钮被按下(事件玩家, 按钮(装填))), 当前数组元素) == 真;
	}

	动作
	{
		等待(0.500, 当为“假”时中止);
		设置玩家生命值(事件玩家, 最大生命值(事件玩家) * 0.5);
		事件玩家.categoryRoll = 随机实数(0, 100);
		if(事件玩家.categoryRoll <= 49);
			事件玩家.mod_speed_perma += 5;
			事件玩家.dlcTimeChallenge += 1;
			小字体信息(事件玩家, 自定义字符串("  {0}  赢！永久获得 5% 移动速度加成", 图标字符串(梅花)));
		else if(事件玩家.categoryRoll <= 98);
			事件玩家.mod_speed_perma -= 5;
			事件玩家.dlcTimeChallenge = 事件玩家.dlcTimeChallenge > 0 ? 0 : 事件玩家.dlcTimeChallenge - 1;
			小字体信息(事件玩家, 自定义字符串("  {0}  输！永久失去 5% 移动速度加成", 图标字符串(方块)));
		else if(事件玩家.categoryRoll <= 99);
			事件玩家.mod_speed_perma += 12;
			事件玩家.dlcTimeChallenge += 1;
			小字体信息(事件玩家, 自定义字符串("  {0}  赢！永久获得 12% 移动速度加成", 图标字符串(梅花)));
		else;
			事件玩家.mod_speed_perma -= 12;
			事件玩家.dlcTimeChallenge = 事件玩家.dlcTimeChallenge > 0 ? 0 : 事件玩家.dlcTimeChallenge - 1;
			小字体信息(事件玩家, 自定义字符串("  {0}  输！永久失去 12% 移动速度加成", 图标字符串(方块)));
		end;
		事件玩家.categoryRoll = 0;
		调用子程序(updatePlayerStats);
		事件玩家.eventDuration = 0;
	}
}

// global event
规则("[VishkarEvent]: Global event - 势不可挡")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 全局.eventId == 1), 当前数组元素) == 真;
	}

	动作
	{
		设置状态(事件玩家, 空, 相移, 全局.eventDuration);
		等待直到(全局.eventId == 空, 全局.eventDuration);
		清除状态(事件玩家, 相移);
	}
}

规则("[VishkarEvent]: Global event - 任务：生存")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 全局.eventId == 3), 当前数组元素) == 真;
	}

	动作
	{
		等待直到(全局.eventId == 空 || 全局.eventCount > 10, 全局.eventDuration);
		IF(全局.eventCount > 10);
			大字体信息(所有玩家(队伍1), 自定义字符串("任务：生存 失败"));
		Else;
			大字体信息(所有玩家(队伍1), 自定义字符串("任务：生存 成功！"));
			小字体信息(所有玩家(队伍1), 自定义字符串("  {0}  任务奖励：永久增加 {1}% 最大生命值", 图标字符串(加号), 15));
		End;
		
	}
}

规则("[VishkarEvent]: Global event - 任务：占领")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 全局.eventId == 4, 数量(所有玩家(队伍1)) >= 4), 当前数组元素) == 真;
	}
}

规则("[VishkarEvent]: Global event - 任务：竞速")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		对全部为“真”(数组(单次赋值(全局.dlcVishkarEvent), 全局.eventId == 5), 当前数组元素) == 真;
	}

	动作
	{
		等待直到(全局.eventId == 空, 全局.eventDuration);
		IF(数量(已过滤的数组(所有玩家(队伍1), 当前数组元素.heroNumber >= 22)) < 数量(所有玩家(队伍1)) / 2);
			大字体信息(所有玩家(队伍1), 自定义字符串("任务：竞速 失败"));
		Else;
			大字体信息(所有玩家(队伍1), 自定义字符串("任务：竞速 成功！"));
			小字体信息(所有玩家(队伍1), 自定义字符串("  {0}  任务奖励：永久获得 {1}% 移动速度加成", 技能图标字符串(英雄(士兵：76), 按钮(技能1)), 5));
			小字体信息(所有玩家(队伍1), 自定义字符串("  {0}  任务奖励：永久获得 {1}% 伤害减免", 技能图标字符串(英雄(毛加), 按钮(技能2)), 10));
		End;
		
	}
}
