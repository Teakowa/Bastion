设置
{
	主程序
	{
		描述: "全新DLC：随机事件 已上线\n使用全英雄逃出生天!!!\n————————————————\n代码【SVMQK】  | 最近更新：25.1023.1\n\nowmod.net/2650\n\n企鹅聊天群：445152554\n\n原作［OW2 PASTION ESCAPE］"
		描述: "全新DLC：随机事件 已上线\n使用全英雄逃出生天!!!\n————————————————\n代码【SVMQK】  | 最近更新：25.1023.1\n\nowmod.net/2650\n\n企鹅聊天群：445152554\n\n原作［OW2 PASTION ESCAPE］"
		模式名称: "躲避堡垒3"
	}

	大厅
	{
		地图轮换: 完成比赛后
		比赛语音聊天: 启用
		玩家上限 队伍1: 10
		玩家上限 队伍2: 0
		观战者人数上限: 12
		返回大厅: 从不
		队列中的玩家可以加入: 是
	}

	模式
	{
		突击模式
		{
			// 启用地图
			// {
			// 	66号公路 972777519512068153 972777519512068154 972777519512068194
			// 	“地平线”月球基地 972777519512068154
			// 	努巴尼 972777519512068154
			// 	哈瓦那 972777519512068153 972777519512068154
			// 	国王大道 972777519512068153 972777519512068292
			// 	多拉多 972777519512068153 972777519512068292
			// 	好莱坞 972777519512068153 972777519512068154
			// 	巴黎 972777519512068292
			// 	帕拉伊苏 972777519512068154 972777519512068292
			// 	沃斯卡娅工业区 972777519512068292
			// 	渣客镇 972777519512068154
			// 	监测站：直布罗陀 972777519512068154 972777519512068292
			// 	艾兴瓦尔德 972777519512068292 972777519512068154
			// 	花村 972777519512068154
			// 	里阿尔托 972777519512068292 972777519512068154
			// 	阿努比斯神殿 972777519512068154
			// 	香巴里寺院 972777519512068153
			// 	中城 972777519512068154 972777519512068153
			// 	皇家赛道 972777519512068154 972777519512068153
			// 	埃斯佩兰萨 972777519512068154
			// 	新皇后街 972777519512068154 972777519512068197
			// 	斗兽场
			// 	鲁纳塞彼 972777519512068154
			// 	南极半岛
			// }
			启用地图
			{
				66号公路 972777519512068153 972777519512068154 972777519512068194
				“地平线”月球基地 972777519512068154
				努巴尼 972777519512068154
				哈瓦那 972777519512068153 972777519512068154
				国王大道 972777519512068153 972777519512068292
				多拉多 972777519512068153 972777519512068292
				好莱坞 972777519512068153 972777519512068154
				巴黎 972777519512068292
				帕拉伊苏 972777519512068154 972777519512068292
				沃斯卡娅工业区 972777519512068292
				渣客镇 972777519512068154
				监测站：直布罗陀 972777519512068154 972777519512068292
				艾兴瓦尔德 972777519512068292 972777519512068154
				花村 972777519512068154
				里阿尔托 972777519512068292 972777519512068154
				阿努比斯神殿 972777519512068154
				香巴里寺院 972777519512068153
				中城 972777519512068154 972777519512068153
				皇家赛道 972777519512068154 972777519512068153
				埃斯佩兰萨 
				新皇后街 972777519512068154 972777519512068197
				斗兽场
				鲁纳塞彼 972777519512068154
				南极半岛
				漓江塔
				萨摩亚
				釜山
				绿洲城
				万圣节好莱坞
				万圣节艾兴瓦尔德
				圣诞节国王大道
				圣诞节暴雪世界
				春节漓江塔
				新渣客城
			}
			// 禁用地图
			// {
			// 	地图工坊室内
			// 	地图工坊岛屿
			// 	地图工坊岛屿（夜间）
			// 	地图工坊空地
			// 	地图工坊空地（夜间）
			// 	地图工坊绿幕
			// 	尼泊尔
			// 	新渣客城
			// 	// 春节漓江塔
			// 	漓江塔
			// 	// 绿洲城
			// 	花冈
			// 	苏拉瓦萨
			// 	阿努比斯王座
			// 	// 萨摩亚
			// 	// 釜山
				
			// 	// 阿特利斯
			// }
		}

		综合
		{
			启用威能: 开启
			复生时间: 10%
			威能充能速度: 500%
			急救包刷新时间: 20%
			敌方生命条: 关闭
			游戏模式开始: 手动
			英雄限制: 关闭
			阵亡镜头: 关闭
		}
	}

	英雄
	{
		队伍1
		{
			技能冷却时间: 30%

			堡垒
			{
				生命值: 150%
			}
		}

		队伍2
		{
			受到伤害量: 25%
			技能冷却时间: 0%
			生命值: 500%

			堡垒
			{
				A-36战术榴弹冷却时间: 25%
				A-36战术榴弹击退倍率: 125%
				弹道速度: 150%
				无需装弹: 开启
				生命值: 500%
			}
		}

		综合
		{
			战斗时终极技能充能速度: 0%
			无需装弹: 开启
			终极技能自动充能速度: 0%

			D.Va
			{
				推进器冷却时间: 125%
			}

			半藏
			{
				“跃”冷却时间: 60%
				音冷却时间: 0%
			}

			卡西迪
			{
				战术翻滚冷却时间: 50%
			}

			回声
			{
				飞行冷却时间: 33%
			}

			天使
			{
				守护天使冷却时间: 67%
			}

			奥丽莎
			{
				强固防御冷却时间: 50%
				标枪旋击冷却时间: 70%
			}

			安娜
			{
				麻醉镖冷却时间: 67%
			}

			巴蒂斯特
			{
				受到治疗量: 50%
				弹道速度: 500%
				投射物重力: 0%
				生命值: 50%
				维生力场冷却时间: 20%
			}

			布丽吉塔
			{
				屏障护盾充能速度: 500%
				能量盾击冷却时间: 80%
			}

			弗蕾娅
			{
				疾冲冷却时间: 67%
				疾冲距离: 130%
			}

			托比昂
			{
				可用武器: 仅限锻造锤
				热力过载冷却时间: 20%
				热力过载持续时间: 40%
				部署炮台: 关闭
			}

			探奇
			{
				钻地持续时间倍率: 25%
			}

			末日铁拳
			{
				悍猛格挡冷却时间: 50%
				火箭重拳冷却时间: 80%
				裂地重拳冷却时间: 80%
			}

			朱诺
			{
				滑翔推进冷却时间: 67%
				滑翔推进持续时间倍率: 50%
			}

			查莉娅
			{
				垂直跳跃速度: 140%
				投射屏障冷却时间: 56%
				粒子屏障冷却时间: 46%
				粒子炮辅助攻击击退倍率: 200%
			}

			死神
			{
				幽灵形态冷却时间: 75%
				暗影步冷却时间: 300%
			}

			毛加
			{
				蛮力冲撞冷却时间: 80%
			}

			温斯顿
			{
				喷射背包冷却时间: 80%
				屏障发射器冷却时间: 83%
			}

			源氏
			{
				闪冷却时间: 75%
			}

			狂鼠
			{
				震荡地雷冷却时间: 100%
				震荡地雷击退倍率: 100%
			}

			猎空
			{
				闪回冷却时间: 50%
				闪现冷却时间: 50%
			}

			生命之梭
			{
				生命之握冷却时间: 84%
				生命之握和愈疗灵花射程: 200%
				花瓣平台冷却时间: 84%
			}

			破坏球
			{
				动力铁球始终激活: 关闭
			}

			禅雅塔
			{
				治疗量: 200%
				生命值: 150%
			}

			秩序之光
			{
				传送面板冷却时间: 66%
				哨戒炮: 关闭
			}

			美
			{
				冰墙冷却时间: 67%
			}

			艾什
			{
				延时雷管冷却时间: 50%
				短筒猎枪冷却时间: 40%
			}

			莫伊拉
			{
				消散冷却时间: 50%
				生化之球治疗最大值: 500%
			}

			莱因哈特
			{
				冲锋冷却时间: 75%
			}

			西格玛
			{
				动能俘获冷却时间: 75%
				实验屏障冷却时间: 50%
				质量吸附冷却时间: 50%
			}

			路霸
			{
				呼吸器冷却时间: 100%
				// 呼吸器充能速度: 100%
			}

			雾子
			{
				“瞬”距离倍率: 143%
				铃冷却时间: 43%
			}

			黑百合
			{
				终极技能持续时间无限: 开启
			}

            骇灾
			{
				尖刺墙冷却时间: 92%
				尖刺墙击退: 0%
				尖刺墙生命值: 25%
				尖刺护体资源消耗: 0%
			}

			黑影
			{
				位移传动冷却时间: 0%
			}
		}
	}

    地图工坊
	{
		难度: [4]
	}

	扩展
	{
		生成更多机器人
		增益状态效果
	}
}

变量
{
	全局:
		0: bastionPosition
		1: heroRingPosition
		2: resetPosition
		3: creditsPosition
		4: endPosition
		5: heroList
		6: missingHeroes
		7: maxDeath
		8: I
		9: kills
		10: bastionBotTargetPrefer
		11: difficulty
		12: scoreboardArray
		13: firstPlace
		14: secondPlace
		15: thirdPlace
		16: textIDs
		17: savedIndex
		18: savedHero
		19: savedDeaths
		20: savedIsWinner
		21: savedSkipCount
		22: savedJoinTime
		23: devList
		24: __currentMap__
		25: dmgReduction
		26: blackList
		27: rebootTime
		28: targetPlayer
		29: targetPlayerIndex
		30: thirdPersonPosition
		31: debugInfo
		32: devPlayer
		33: bastionBotSeconFire
		34: difficultyText
		35: controlCenterPosition
		36: controlJumpPosition
		37: secondJumpPosition
		38: controlRespawnPosition
		39: controlRespawnAxis
		40: controlRespawnAxisThreshold
		43: mapTitleRelation
		44: allTitle
		45: titlePlayer
		47: playerTitleRelation
		48: rgbList
		49: savedWinnerTime
		51: savedA36TGrenade
		52: savedA36TGrenadeHit
		53: savedA36TGrenadeDmg
		54: savedA36TGrenadeAlive
		55: turnSpeedMultiplier
		56: A36TGrenadeFB
		69: hashTag
		70: dlcBerserker
		71: dlcVishkarEvent
		72: vishkarEventActivated
		// 73: vishkarEvent
		81: buffEvent
		82: buffEventId
		83: debuffEvent
		84: debuffEventId
		85: mechEvent
		86: mechEventId

		89: obstrucVis
		90: heroColor
		91: breathRed
		92: breathPurple
		93: breathBlue
		100: springBoardPosition
		101: portalPosition
		105: __currentMapText__
		127: antiCrashActivated

	玩家:
		0: heroNumber
		1: progressionDeathCount
		2: skipCount
		3: isWinner
		4: dmgReduc
		5: anaSleepLimit
		6: temp
		7: attacker
		8: I
		9: target
		10: aimPosition
		11: turnSpeed
		12: tempAimPosition
		13: nearestTargetOutOfLoS
		14: dvaStart
		15: healID
		16: isInPosition
		17: rainbowOff
		18: runDeathCount
		19: joinTime
		20: menu
		21: menuTextID
		22: isDev
		23: debugInfo
		24: third
		25: hasNano
		26: nanoEffect
		27: invincible
		28: invincibleEffect
		29: isAirWalkEnabled
		30: isPortalEnabled
		31: controlCenterIndex
		32: controlJumpIndex
		33: controlPlayerRespawnPosition
		34: controlPlayerRespawn
		37: playerTitleAndColor
		38: titleTextID
		39: rgb_vect
		40: info_pvar
		41: rgb_activated
		42: winnerTime
		43: playerTitles
		44: playerTitleIndex
		45: playerTitleRelationIndex
		46: playerTitleWhileIndex
		50: A36TGrenade
		51: A36TGrenadeHit
		52: A36TGrenadeDmg
		53: A36TGrenadeAlive
		59: mercyResurrect
		60: eventId
		61: eventLastId
		62: eventType
		63: eventDuration
		64: eventName
		65: eventDesc
		66: eventCount
		67: eventLucky
		68: eventEffect
		69: categoryRoll
		70: mov_speed_penalty
		71: mov_speed_buff
		72: healing_increase // 增加造成治疗量 healing_received_increase heal_recv_inc
		73: healing_decrease // 减少造成治疗量 healing_received_decrease heal_recv_dec
		74: dmg_increase // 增加受到伤害量 damage_received_increase  dmg_recv_inc
		75: dmg_reduction // 减少受到伤害量 damage_received_decrease  dmg_recv_dec
		76: healthId
		77: hack_timer
		78: targetWeight
		79: targetSilence
		80: hudTextId
		81: heart_steel
		82: obstrucVis
		83: sizeHealth
		84: eventDurationHud
}

子程序
{
	0: savePlayerData
	1: progressHero
	2: setDifficulty
	3: setThirdPerson
	4: setPlayerTitle
	5: setPlayerEvent
	6: clearPlayerEvent
	7: setPlayerMovSpeed
	8: setPlayerDmgReduc
	9: setPlayerHP
	10: setEventDuration
}

禁用 规则("声明：为了地图工坊社区的健康发展，本模式代码不得用于商业用途")
{
	事件
	{
		持续 - 全局;
	}
}

禁用 规则("在模式描述中保留原作者署名与原模式代码的前提下，你可基于本模式及其代码进行二次创作与发布")
{
	事件
	{
		持续 - 全局;
	}
}

规则("OverPy Map Detection")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		If(数组包含(数组(地图(阿育陀耶), 地图(黑森林), 地图(黑森林), 地图(暴雪世界), 地图(暴雪世界), 地图(釜山), 地图(釜山), 地图(釜山), 地图(城堡), 地图(吉拉德堡), 地图(吉拉德堡), 地图(皇家赛道), 地图(斗兽场),
			地图(多拉多), 地图(生态监测站：南极洲), 地图(南极半岛), 地图(艾兴瓦尔德), 地图(艾兴瓦尔德), 地图(埃斯佩兰萨), 地图(阿努比斯王座), 地图(花村), 地图(花村), 地图(哈瓦那), 地图(好莱坞), 地图(好莱坞), 地图(
			“地平线”月球基地), 地图(伊利奥斯), 地图(伊利奥斯), 地图(伊利奥斯), 地图(伊利奥斯), 地图(怪鼠复仇), 地图(渣客镇), 地图(新渣客城), 地图(国王大道), 地图(国王大道), 地图(漓江塔控制中心), 地图(漓江塔控制中心),
			地图(漓江塔庭院), 地图(漓江塔庭院), 地图(漓江塔夜市), 地图(漓江塔夜市), 地图(漓江塔), 地图(漓江塔), 地图(马莱温多), 地图(中城), 地图(墓园), 地图(尼泊尔), 地图(尼泊尔), 地图(尼泊尔), 地图(尼泊尔), 地图(
			尼泊尔), 地图(新皇后街), 地图(努巴尼), 地图(绿洲城), 地图(绿洲城), 地图(绿洲城), 地图(绿洲城), 地图(帕拉伊苏), 地图(巴黎), 地图(佩特拉), 地图(训练靶场), 地图(里阿尔托), 地图(66号公路), 地图(
			阿努比斯神殿), 地图(沃斯卡娅工业区), 地图(监测站：直布罗陀), 地图(地图工坊室内), 地图(地图工坊空地), 地图(地图工坊空地), 地图(地图工坊绿幕), 地图(地图工坊岛屿), 地图(地图工坊岛屿), 地图(香巴里寺院)), 当前地图));
			全局.__currentMap__ = 当前地图;
			中止;
		End;
		全局.__currentMap__ = 射线命中位置(矢量(500, 100, 500), 矢量(-500, -100, -500), 空, 空, 假);
		If(全局.__currentMap__ == 矢量(0, 0, 0) || 全局.__currentMap__ == 矢量(-500, -100, -500));
			全局.__currentMap__ = 射线命中位置(矢量(30, 5, 0), 矢量(-30, -10, -10), 空, 空, 假);
			If(全局.__currentMap__ == 矢量(-30, -10, -10));
				全局.__currentMap__ = 射线命中位置(矢量(200, 20, 100), 矢量(100, -100, -100), 空, 空, 假);
				If(全局.__currentMap__ == 矢量(100, -100, -100));
					全局.__currentMap__ = 射线命中位置(矢量(300, 20, -100), 矢量(300, -100, 100), 空, 空, 假);
					If(全局.__currentMap__ == 矢量(300, -100, 100));
						全局.__currentMap__ = 射线命中位置(矢量(50, 100, -150), 矢量(-50, -100, -160), 空, 空, 假);
						If(全局.__currentMap__ == 矢量(-50, -100, -160));
							全局.__currentMap__ = 射线命中位置(矢量(0, 300, 340), 矢量(0, -100, -300), 空, 空, 假);
							If(全局.__currentMap__ == 矢量(0, -100, -300));
								全局.__currentMap__ = 射线命中位置(矢量(140, 10, -240), 矢量(200, -10, -300), 空, 空, 假);
								If(全局.__currentMap__ == 矢量(200, -10, -300));
									全局.__currentMap__ = 射线命中位置(矢量(-180, 30, 60), 矢量(-180, -50, -60), 空, 空, 假);
								End;
							End;
						End;
					End;
				End;
			End;
		End;
		全局.__currentMap__ = 100 * 取整(Y方向分量(全局.__currentMap__), 上) + 10 * 取整(X方向分量(全局.__currentMap__), 至最近) + 取整(Z方向分量(全局.__currentMap__),
			下);
		If(全局.__currentMap__ == 10121);
			全局.__currentMap__ = 射线命中位置(矢量(-60, 20, -60), 矢量(60, -10, 60), 空, 空, 假);
			If(全局.__currentMap__ == 矢量(60, -10, 60));
				全局.__currentMap__ = 射线命中位置(矢量(-180, -70, 60), 矢量(-180, -100, -60), 空, 空, 假);
			End;
			全局.__currentMap__ = 100 * 取整(Y方向分量(全局.__currentMap__), 上) + 10 * 取整(X方向分量(全局.__currentMap__), 至最近) + 取整(Z方向分量(全局.__currentMap__),
				下);
		End;
		// If(数组包含(数组(地图(釜山), 地图(南极半岛), 地图(伊利奥斯), 地图(漓江塔), 地图(尼泊尔), 地图(绿洲城), 地图(萨摩亚)), 全局.__currentMap__));
			全局.controlCenterPosition =  数组(目标位置(0), 目标位置(1), 目标位置(2));
		// END;
	}
}

规则("Initialize global variables")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		// 禁用 全局.dlcBerserker = 地图工坊设置开关(自定义字符串("2. DLC 扩展内容"), 自定义字符串("狂暴之心（即将到来）"), 假, 6);
		全局.dlcVishkarEvent = 地图工坊设置开关(自定义字符串("2. DLC 扩展内容"), 自定义字符串("随机事件扩展包"), 假, 5);
		全局.rebootTime = 地图工坊设置实数(自定义字符串("1. 游戏"), 自定义字符串("自动重开时间间隔（小时）"), 3.500, 1, 4, 0) * 3600;
		全局.bastionBotTargetPrefer = 地图工坊设置组合(自定义字符串("1. 游戏"), 自定义字符串("AI 堡垒瞄准系统"), 0, 数组(自定义字符串("自动"), 自定义字符串("近距离优先"), 自定义字符串("低生命值优先")), 2);
		全局.difficulty = 地图工坊设置组合(自定义字符串("1. 游戏"), 自定义字符串("难度"), 1, 数组(自定义字符串("简单"), 自定义字符串("一般"), 自定义字符串("困难"), 自定义字符串("专家"), 自定义字符串("传奇"),
			自定义字符串("地狱：无法跳过英雄")), 1);
		全局.dmgReduction = 地图工坊设置开关(自定义字符串("1. 游戏"), 自定义字符串("全英雄威能充能"), 真, 4);
		全局.bastionBotSeconFire = 地图工坊设置开关(自定义字符串("1. 游戏"), 自定义字符串("AI 堡垒使用榴弹（忽略难度）"), 假, 3);
		全局.turnSpeedMultiplier = 全局.difficulty < 4 ? 4 + 全局.difficulty : 10 * 0.800;
		全局.maxDeath = 5 * 全局.difficulty;
		全局.savedIndex = 空数组;
		全局.savedHero = 空数组;
		全局.savedDeaths = 空数组;
		全局.savedIsWinner = 空数组;
		全局.savedSkipCount = 空数组;
		全局.savedJoinTime = 空数组;
		全局.devList = 数组(自定义字符串("他又"), 自定义字符串("别感冒"));
		全局.devPlayer = 空数组;
		全局.mapTitleRelation = 空数组;
		全局.obstrucVis = 空数组;
	}
}

规则("Setup Blacklist")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.blackList = 空数组;
		修改全局变量(blackList, 添加至数组, 字符串分割(自定义字符串("腾讯游戏-GabrielReyes-Pakho"), 自定义字符串("-")));
	}
}

规则("Remove Player from Blacklist")
{
	事件
	{
		玩家加入比赛;
		队伍1;
		全部;
	}

	条件
	{
		数组包含(全局.blackList, 自定义字符串("{0}", 事件玩家)) == 真;
	}

	动作
	{
		移除玩家(事件玩家);
	}
}

规则("Update devPlayer from devList")
{
	事件
	{
		玩家加入比赛;
		队伍1;
		全部;
	}

	条件
	{
		数组包含(全局.devList, 自定义字符串("{0}", 事件玩家)) == 真;
		数组包含(全局.devPlayer, 自定义字符串("{0}", 事件玩家)) == 假;
	}

	动作
	{
		修改全局变量(devPlayer, 添加至数组, 事件玩家);
	}
}

规则("Update targetPlayer when player left")
{
	事件
	{
		玩家离开比赛;
		队伍1;
		全部;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 无视条件);
		全局.targetPlayerIndex = 0;
		全局.targetPlayer = 首个(已排序的数组(所有玩家(队伍1), 当前数组元素.joinTime));
	}
}

规则("initialize color array")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.rgbList = 数组(
			矢量(255, 0, 0),    // 红
            矢量(255, 165, 0),  // 橙
            矢量(255, 255, 0),  // 黄
            矢量(0, 255, 0),    // 绿
            矢量(0, 0, 255),    // 蓝
            矢量(75, 0, 130),   // 靛
            矢量(238, 130, 238) // 紫
		);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		全局.breathRed = 数组(
            矢量(238, 75, 43),       // 朱红
            矢量(233, 116, 81),     // 锡耶纳色
            矢量(210, 43, 43),   // 镉红色
			矢量(220, 20, 60), // 深红
			矢量(255, 36, 0), // 猩红
            矢量(255, 50, 50),     // 亮红
            矢量(255, 0, 0)        // 纯红
        );

		全局.breathPurple = 数组(
            矢量(161, 73, 197), // 紫色
            矢量(93, 63, 211),       // 虹膜色
			矢量(218, 112, 214), // 兰花色
			矢量(112, 41, 99), // 拜占庭色
            矢量(191, 64, 191),     // 亮紫色
            矢量(204, 204, 255),        // 长春花色
			矢量(128, 0, 128)   // 紫色
        );

		全局.breathBlue = 数组(
			
			矢量(85, 178, 204), // 基础蓝
			
			矢量(120, 200, 225), // 天蓝
			矢量(160, 220, 240), // 浅天蓝
			矢量(25, 80, 120), // 深海军蓝
			矢量(45, 125, 165), // 宝石蓝
			矢量(200, 235, 245), // 淡蓝
			矢量(230, 245, 250) // 冰蓝
		);

		全局.heroColor = 数组(
			矢量(124, 62, 82),//REAPER 0 rgb(124, 62, 82)
			矢量(214, 145, 65),//TRACER 1 rgb(214, 145, 65)
			矢量(236, 233, 189),//MERCY 2 rgb(236, 233, 189)
			矢量(185, 179, 137),//HANZO 3 rgb(185, 179, 137)
			矢量(191, 115, 110),//TORBJÖRN 4 rgb(191, 115, 110)
			矢量(148, 161, 165),//REINHARDT 5 rgb(148, 161, 165)
			矢量(60, 126, 204),//PHARAH 6 rgb(60, 126, 204)
			矢量(160, 169, 186),//WINSTON 7 rgb(160, 169, 186)
			矢量(157, 105, 166),//WIDOWMAKER 8 rgb(157, 105, 166)
			矢量(124, 143, 122),//BASTION 9 rgb(124, 143, 122)
			矢量(45, 187, 209),//SYMMETRA 10 rgb(45, 187, 209)
			矢量(236, 229, 128),//ZENYATTA 11 rgb(236, 229, 128)
			矢量(149, 239, 66),//GENJI 12 rgb(149, 239, 66)
			矢量(179, 139, 80),//ROADHOG 13 rgb(179, 139, 80)
			矢量(173, 90, 95),//CASSIDY 14 rgb(173, 90, 95)
			矢量(236, 190, 82),//JUNKRAT 15 rgb(236, 190, 82)
			矢量(231, 130, 184),//ZARYA 16 rgb(231, 130, 184)
			矢量(109, 121, 149),//SOLDIER: 76 17 rgb(109, 121, 149)
			矢量(132, 201, 81),//LÚCIO 18 rgb(132, 201, 81)
			矢量(237, 147, 199),//D.VA 19 rgb(237, 147, 199)
			矢量(09, 171, 235),//MEI 20 rgb(9, 171, 235)
			矢量(118, 93, 189),//SOMBRA 21 rgb(118, 93, 189)
			矢量(131, 83, 76),//DOOMFIST 22 rgb(131, 83, 76)
			矢量(110, 137, 177),//ANA 23 rgb(110, 137, 177)
			矢量(69, 139, 66),//ORISA 24 rgb(69, 139, 66)
			矢量(139, 98, 94),//BRIGITTE 25 rgb(139, 98, 94)
			矢量(151, 113, 228),//MOIRA 26 rgb(151, 113, 228)
			矢量(219, 147, 66),//WRECKING BALL 27 rgb(219, 147, 66)
			矢量(198, 28, 65),//SOJOURN 28 rgb(198, 28, 65)
			矢量(105, 105, 104),//ASHE 29 rgb(105, 105, 104)
			矢量(154, 202, 243),//ECHO 30 rgb(154, 202, 243)
			矢量(85, 178, 204),//BAPTISTE 31 rgb(85, 178, 204)
			矢量(212, 135, 143),//KIRIKO 32 rgb(212, 135, 143)
			矢量(142, 181, 215),//JUNKER QUEEN 33 rgb(142, 181, 215)
			矢量(148, 160, 165),//SIGMA 34 rgb(148, 160, 165)
			矢量(157, 140, 208),//RAMATTRA 35 rgb(157, 140, 208)
			矢量(224, 182, 198),//LIFEWEAVER 36 rgb(224, 182, 198)
			矢量(220, 132, 125),//MAUGA 37 rgb(220, 132, 125)
			矢量(183, 168, 142),//ILLARI 38 rgb(183, 168, 142)
			矢量(121, 97, 78),//VENTURE 39 rgb(121, 97, 78)
			矢量(173, 143, 203),//HAZARD 40 rgb(173, 143, 203)
			矢量(114, 31, 163),//JUNO 41 rgb(114, 31, 163)
			矢量(54, 127, 221),//FREJA 42 rgb(54, 127, 221)
			矢量(238, 75, 43),//朱红 43 rgb(238, 75, 43)
			矢量(93, 63, 211),//拜占庭 44 rgb(93, 63, 211)
			矢量(196, 30, 58)//枢机红 45 rgb(196, 30, 58)
		);
	}
}

规则("initialize title array")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.titlePlayer = 数组(
			自定义字符串("他又"), // 0
            自定义字符串("别感冒"), // 1
            自定义字符串("草艮"), // 2
            自定义字符串("烛台与南九"), // 3
            自定义字符串("顾北酒笙"), // 4
            自定义字符串("WildRage"), // 5
            自定义字符串("尘风歌者"), // 6
            自定义字符串("吾携秋水揽星河"), // 7
            自定义字符串("寒霜冰湮"), // 8
            自定义字符串("Cold"), // 9
            自定义字符串("豆本豆豆奶"), // 10
            自定义字符串("神之岛風咲"), // 11
            自定义字符串("溪云初起日沉阁"), // 12
            自定义字符串("卖核弹的小女孩"), // 13
            自定义字符串("挽风"), // 14
            自定义字符串("物语之光"), // 15
            自定义字符串("别打老顾我啊"), // 16
            自定义字符串("看啊情"), // 17
            自定义字符串("眼镜小宅"), // 18
            自定义字符串("初一吖"), // 19
            自定义字符串("锦木千束"), // 20
			自定义字符串("她说话有股孩子气"), // 21
			自定义字符串("白银之鹰"), // 22
			自定义字符串("蝎子莱莱"), // 23
			自定义字符串("雨鸢") // 24
		);
		等待(服务器负载 / 100 * 0.500, 无视条件);
		全局.allTitle = 数组(
			数组(自定义字符串("{0}开拓者", 全局.__currentMapText__ != 空 ? 全局.__currentMapText__ : 当前地图), 全局.heroColor[12]), // 0
			数组(自定义字符串("这是一个超长的称号测试字段如果到这里还没有被截断说明确实很长你说得对但是广告位招租啊哈大OW是我的家乡"), 空), // 1
            数组(自定义字符串("地图不是我做的"), 空), // 2
            数组(自定义字符串("野生开发者"), 空), // 3
            数组(自定义字符串("堡垒建筑师"), 空), // 4
			数组(自定义字符串("友善的地图维护者"), 空), // 5
            数组(自定义字符串("三合一地图作者"), 空), // 6
            数组(自定义字符串("害群之马"), 空), // 7
            数组(自定义字符串("纯害战士"), 空), // 8
			数组(自定义字符串("{0}征服者", 全局.__currentMapText__ != 空 ? 全局.__currentMapText__ : 当前地图), 全局.heroColor[43]), // 9 地图称号模板
            数组(自定义字符串("{0}主宰", 全局.__currentMapText__ != 空 ? 全局.__currentMapText__ : 当前地图), 全局.heroColor[44]),   // 10 地图称号模板
			数组(自定义字符串("专家幸存者"), 矢量(236, 153, 0)), // 11
			数组(自定义字符串("传奇挑战者"), 矢量(200, 0, 19)), // 12
            数组(自定义字符串("地狱穿梭者"), 矢量(161, 73, 197)), // 13
            数组(自定义字符串("终极闪避"), 全局.heroColor[1]), // 14
			数组(自定义字符串("轻装上阵"), 全局.heroColor[2]), // 15
            数组(自定义字符串("完美无缺"), 矢量(0, 230, 151)), // 16
			数组(自定义字符串("永不言弃"), 矢量(0, 230, 151)), // 17
			数组(自定义字符串("坚韧不拔"), 矢量(255, 255, 255)), // 18
			数组(自定义字符串("速通传奇"), 矢量(0, 230, 151)), // 19
			数组(自定义字符串("闪避の神"), 全局.heroColor[28]), // 20
			数组(自定义字符串("钢铁之躯"), 全局.heroColor[28]), // 21
			数组(自定义字符串("大难不死"), 全局.heroColor[45]), // 22
            数组(自定义字符串("吸弹仙人"), 矢量(200, 0, 19)), // 23
           	数组(自定义字符串("堡垒の偶像"), 矢量(200, 0, 19)), // 24
		   	数组(自定义字符串("第一颗蛋"), 矢量(200, 0, 19)), // 25
		   	数组(自定义字符串("我还能吃"), 矢量(238, 75, 43)), // 26
			数组(自定义字符串("万象归一"), 全局.breathRed), // 27
			数组(自定义字符串("守望旅行家"), 全局.heroColor[33]), // 28
			数组(自定义字符串("万域天穹"), 全局.breathPurple), // 29
			数组(自定义字符串("狂暴烈焰"), 全局.heroColor[28]), // 30
			数组(自定义字符串("万蛋丛中过"), 全局.heroColor[28]), // 31
			数组(自定义字符串("天选之子"), 全局.heroColor[11]), // 32
			数组(自定义字符串("幸运星"), 全局.heroColor[3]), // 33
			数组(自定义字符串("时来运转"), 全局.heroColor[15]), // 34
			数组(自定义字符串("福星高照"), 全局.heroColor[32]), // 35
			数组(自定义字符串("倒霉蛋"), 全局.heroColor[22]), // 36
			数组(自定义字符串("What can i say"), 全局.heroColor[11]), // 37 混沌化身
			数组(自定义字符串("我命由我"), 全局.breathBlue) // 38 
		);

		全局.playerTitleRelation = 数组(
			// 玩家0: "他又" - 全部称号
            数组(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38), 
			// 玩家1: "芋泥玛奇朵" - 全部称号
            数组(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38),
            // 玩家"草艮"的称号索引: 11,12
           	数组(12, 13),
    
			// 玩家3: "烛台与南九" - 3个称号
			数组(12, 13, 25),
			
			// 玩家4: "顾北酒笙" - 4个称号
			数组(12, 16, 19, 13),
			
			// 玩家5: "WildRage" - 1个称号
			数组(12, 13, 22, 25),
			
			// 玩家6: "尘风歌者" - 10个称号
			数组(12, 13, 16, 18, 19, 15, 14, 22, 25, 31),
			
			// 玩家7: "吾携秋水揽星河" - 7个称号
			数组(12, 16, 17, 13, 19, 22, 15, 14, 16, 27, 28, 29, 32, 35, 37),
			
			// 玩家8: "寒霜冰湮" - 7个称号
			数组(12, 16, 17, 13, 19, 22, 15, 14, 27, 28, 29, 33, 37),
			
			// 玩家9: "Cold" - 9个称号
			数组(16, 17, 12, 13, 19, 22, 15, 14, 25, 27, 28, 29, 31, 37),
			
			// 玩家10: "豆本豆豆奶" - 8个称号
			数组(16, 12, 17, 19, 13, 22, 14, 25, 36),
			
			// 玩家11: "神之岛風咲" - 3个称号
			数组(16, 12, 13),
			
			// 玩家12: "溪云初起日沉阁" - 5个称号
			数组(19, 16, 17, 12, 13, 22, 25, 36),
			
			// 玩家13: "卖核弹的小女孩" - 3个称号
			数组(19, 16, 12),
			
			// 玩家14: "挽风" - 5个称号
			数组(15, 14, 19, 16, 12),
			
			// 玩家15: "物语之光" - 4个称号
			数组(12, 19, 13, 22),
			
			// 玩家16: "别打老顾我啊" - 5个称号
			数组(12, 13, 16, 19, 22),
			
			// 玩家17: "看啊情" - 4个称号
			数组(12, 16, 13, 22),
			
			// 玩家18: "眼镜小宅" - 4个称号
			数组(12, 13, 14, 15, 16, 19, 22, 33),
			数组(12, 13, 14, 15, 16, 19, 22, 33),
			
			// 玩家19: "初一吖" - 3个称号
			数组(12, 13, 16, 22, 25, 31, 32, 37),
			
			// 玩家20: "锦木千束" - 3个称号
			数组(12, 13, 16),

			// 玩家21: "她说话有股孩子气"
			数组(12, 16, 19),

			// 玩家22: "白银之鹰"
			数组(12, 13, 19),

			// 玩家23: 蝎子莱莱
			数组(12, 13, 16, 19, 22),

			// 玩家24: 雨鸢
			数组(12, 13, 22, 36, 37)
        );
	}
}

规则("initialize event flag")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		总计消耗时间 > 120; // 等待10秒以确保地图名称已被正确读取
	}

	动作
	{
		全局.vishkarEventActivated = 单次赋值(全局.dlcVishkarEvent);
		等待直到(总计消耗时间 > 全局.rebootTime, 999999986991104.000);
	}
}

规则("initialize event array")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.vishkarEventActivated == 真;
	}

	动作
	{
		全局.buffEvent = 空数组;
		全局.buffEventId = 空数组;
		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包：增益"), 自定义字符串("奥利维娅的礼物"), 真, 0), 2);
		全局.buffEvent[0] = 数组(自定义字符串("奥利维娅的礼物"), 自定义字符串("你好"), 5);
		修改全局变量(buffEventId, 添加至数组, 0);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包：增益"), 自定义字符串("疾风祝福"), 真, 1), 2);
		全局.buffEvent[1] = 数组(自定义字符串("疾风祝福"), 自定义字符串("移动速度提高50%"), 20);
		修改全局变量(buffEventId, 添加至数组, 1);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包：增益"), 自定义字符串("钢铁防线"), 真, 2), 2);
		全局.buffEvent[2] = 数组(自定义字符串("钢铁防线"), 自定义字符串("获得2500点临时护甲与25%伤害减免"), 25);
		修改全局变量(buffEventId, 添加至数组, 2);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包：增益"), 自定义字符串("肾上腺素"), 真, 3), 2);
		全局.buffEvent[3] = 数组(自定义字符串("肾上腺素"), 自定义字符串("获得50%额外伤害减免"), 20);
		修改全局变量(buffEventId, 添加至数组, 3);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包：增益"), 自定义字符串("生命源泉"), 真, 4), 2);
		全局.buffEvent[4] = 数组(自定义字符串("生命源泉"), 自定义字符串("每秒恢复15%最大生命值"), 30);
		修改全局变量(buffEventId, 添加至数组, 4);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包：增益"), 自定义字符串("黑粉来袭"), 真, 5), 2);
		全局.buffEvent[5] = 数组(自定义字符串("黑粉来袭"), 自定义字符串("显示正在瞄准你的堡垒数量"), 20);
		修改全局变量(buffEventId, 添加至数组, 5);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包：增益"), 自定义字符串("足力健"), 真, 6), 2);
		全局.buffEvent[6] = 数组(自定义字符串("足力健"), 自定义字符串("持续移动1秒获得3%可叠加的移动速度"), 45);
		修改全局变量(buffEventId, 添加至数组, 6);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包：增益"), 自定义字符串("不朽意志"), 真, 7), 2);
		全局.buffEvent[7] = 数组(自定义字符串("不朽意志"), 自定义字符串("受到伤害后在2秒内恢复40%最大生命值"), 25);
		修改全局变量(buffEventId, 添加至数组, 7);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包：增益"), 自定义字符串("心之钢"), 真, 8), 2);
		全局.buffEvent[8] = 数组(自定义字符串("心之钢"), 自定义字符串("阵亡后永久增加1%最大生命值"), 45);
		修改全局变量(buffEventId, 添加至数组, 8);

		// 2.0
		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：增益"), 自定义字符串("危险感知"), 假, 9), 2);
		// 全局.buffEvent[9] = 数组(自定义字符串("危险感知"), 自定义字符串("被锁定时获得40%移动速度与25%伤害减免"), 60);
		// 修改全局变量(buffEventId, 添加至数组, 9);

		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：增益"), 自定义字符串("反应装甲"), 假, 10), 2);
		// 全局.buffEvent[10] = 数组(自定义字符串("反应装甲"), 自定义字符串("获得一个可恢复的护甲\n如果堡垒对你的伤害未能击穿护甲\n则堡垒将被击晕"), 90);
		// 修改全局变量(buffEventId, 添加至数组, 10);

		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：增益"), 自定义字符串("生命借贷"), 假, 11), 2);
		// 全局.buffEvent[11] = 数组(自定义字符串("生命借贷"), 自定义字符串("如果你的生命值降低至1点，你不会阵亡\n接下来受到的伤害将被存储，在事件结束后持续扣除"), 45);
		// 修改全局变量(buffEventId, 添加至数组, 11);

		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：增益"), 自定义字符串("死亡延迟"), 假, 11), 2);
		// 全局.buffEvent[11] = 数组(自定义字符串("死亡延迟"), 自定义字符串("如果你受到的伤害大于当前生命值，你的阵亡将被延迟到事件结束后"), 45);
		// 修改全局变量(buffEventId, 添加至数组, 11);

		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：增益"), 自定义字符串("有我有你"), 假, 12), 2);
		// 全局.buffEvent[12] = 数组(自定义字符串("有我有你"), 自定义字符串("长按{0}附身一名队友\n该队友获得你拥有的150%的护盾与护甲和25%伤害减免\n你获得25%治疗增益", 按钮(互动)), 120);
		// 修改全局变量(buffEventId, 添加至数组, 12);

		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：增益"), 自定义字符串("↑↑↓↓←→←→BABA"), 假, 13), 2);
		// 全局.buffEvent[13] = 数组(自定义字符串("↑↑↓↓←→←→BABA"), 自定义字符串("如果你在事件持续期间阵亡，你会在5秒前的位置复活，事件立刻结束"), 120);
		// 修改全局变量(buffEventId, 添加至数组, 13);

		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：增益"), 自定义字符串("高空优势"), 假, 14), 2);
		// 全局.buffEvent[14] = 数组(自定义字符串("高空优势"), 自定义字符串("在空中时获得 75% 伤害减免"), 45);
		// 修改全局变量(buffEventId, 添加至数组, 14);

		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：增益"), 自定义字符串("费斯卡光子护盾"), 假, 15), 2);
		// 全局.buffEvent[15] = 数组(自定义字符串("费斯卡光子护盾"), 自定义字符串("所有人获得一个可恢复的护盾\n其数值为你最大生命值的 25%\n护盾持续到你阵亡或事件结束"), 240);
		// 修改全局变量(buffEventId, 添加至数组, 15);

		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：增益"), 自定义字符串("光学迷彩"), 假, 16), 2);
		// 全局.buffEvent[16] = 数组(自定义字符串("光学迷彩"), 自定义字符串("受到堡垒的伤害会根据距离衰减，每1米衰减1%，最大衰减50%"), 45);
		// 修改全局变量(buffEventId, 添加至数组, 16);

		// 全局.buffEvent = 数组(
		// 	数组(自定义字符串("奥利维娅的礼物"), 自定义字符串("你好"), 5),
		// 	// "buff"
		// 	数组(自定义字符串("疾风祝福"), 自定义字符串("移动速度提高50%"), 20),
        //     // 数组(自定义字符串("纳米战甲"), 自定义字符串("获得1500点临时生命值与25%伤害减免"), 25),
		// 	数组(自定义字符串("钢铁防线"), 自定义字符串("获得2500点临时护甲与25%伤害减免"), 25),
        //     数组(自定义字符串("肾上腺素"), 自定义字符串("获得50%额外伤害减免"), 20),
        //     数组(自定义字符串("生命源泉"), 自定义字符串("每秒恢复最大生命值的8%"), 30),
        //     数组(自定义字符串("黑粉来袭"), 自定义字符串("显示正在瞄准你的堡垒数量"), 20),
        //     数组(自定义字符串("足力健"), 自定义字符串("持续移动1秒获得3%可叠加的移动速度"), 45),
        //     数组(自定义字符串("不朽意志"), 自定义字符串("受到伤害后在2秒内恢复40%最大生命值"), 25),
        //     数组(自定义字符串("心之钢"), 自定义字符串("阵亡后永久增加1%最大生命值"), 60)
		// );

		// "debuff"
		全局.debuffEvent = 空数组;
		全局.debuffEventId = 空数组;

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包：减益"), 自定义字符串("重力异常"), 真, 0), 2);
		全局.debuffEvent[0] = 数组(自定义字符串("重力异常"), 自定义字符串("移动速度降低50%，跳跃高度降低70%"), 20);
		修改全局变量(debuffEventId, 添加至数组, 0);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包：减益"), 自定义字符串("电磁脉冲"), 真, 1), 2);
		全局.debuffEvent[1] = 数组(自定义字符串("电磁脉冲"), 自定义字符串("被侵入，无法使用技能"), 8);
		修改全局变量(debuffEventId, 添加至数组, 1);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包：减益"), 自定义字符串("粉丝狂热"), 真, 2), 2);
		全局.debuffEvent[2] = 数组(自定义字符串("粉丝狂热"), 自定义字符串("成为所有AI堡垒的优先攻击目标"), 25);
		修改全局变量(debuffEventId, 添加至数组, 2);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包：减益"), 自定义字符串("易损"), 真, 3), 2);
		全局.debuffEvent[3] = 数组(自定义字符串("易损"), 自定义字符串("受到的所有伤害提高25%"), 25);
		修改全局变量(debuffEventId, 添加至数组, 3);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包：减益"), 自定义字符串("限速40"), 真, 4), 2);
		全局.debuffEvent[4] = 数组(自定义字符串("限速40"), 自定义字符串("移动时每秒损失50+7.5%最大生命值"), 25);
		修改全局变量(debuffEventId, 添加至数组, 4);

		// 2.0
		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：减益"), 自定义字符串("引力异常"), 假, 5), 2);
		// 全局.debuffEvent[5] = 数组(自定义字符串("引力异常"), 自定义字符串("被持续性拉向最近的堡垒，移动速度降低25%"), 30);
		// 修改全局变量(debuffEventId, 添加至数组, 5);

		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：减益"), 自定义字符串("骨质疏松"), 假, 5), 2);
		// 全局.debuffEvent[5] = 数组(自定义字符串("骨质疏松"), 自定义字符串("移动速度随时间降低，最多75%"), 30);
		// 修改全局变量(debuffEventId, 添加至数组, 5);
		
		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：减益"), 自定义字符串("电磁脉冲 ProMax"), 假, 6), 2);
		// 全局.debuffEvent[6] = 数组(自定义字符串("电磁脉冲 ProMax"), 自定义字符串("被侵入，无法使用技能，以你为中心扩散至75米以内的队友"), 8);
		// 修改全局变量(debuffEventId, 添加至数组, 6);

		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：减益"), 自定义字符串("能量泄漏"), 假, 7), 2);
		// 全局.debuffEvent[7] = 数组(自定义字符串("能量泄漏"), 自定义字符串("使用技能会消耗10%生命值"), 30);
		// 修改全局变量(debuffEventId, 添加至数组, 7);

		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：减益"), 自定义字符串("我燃尽了"), 假, 8), 2);
		// 全局.debuffEvent[8] = 数组(自定义字符串("我燃尽了"), 自定义字符串("每秒扣除1%最大生命值，移动时扣除速度翻倍"), 45);
		// 修改全局变量(debuffEventId, 添加至数组, 8);

		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：减益"), 自定义字符串("有难同当"), 假, 9), 2);
		// 全局.debuffEvent[9] = 数组(自定义字符串("有难同当"), 自定义字符串("你受到伤害的25%会额外扩散给15米内所有队友"), 30);
		// 修改全局变量(debuffEventId, 添加至数组, 9);

		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：减益"), 自定义字符串("狂欢盛宴"), 假, 10), 2);
		// 全局.debuffEvent[10] = 数组(自定义字符串("狂欢盛宴"), 自定义字符串("如果你在盛宴期间内阵亡，那么全体堡垒将进入10秒狂暴状态"), 45);
		// 修改全局变量(debuffEventId, 添加至数组, 10);

		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：减益"), 自定义字符串("战术瞄准镜"), 假, 11), 2);
		// 全局.debuffEvent[11] = 数组(自定义字符串("战术瞄准镜"), 自定义字符串("受到堡垒的伤害会根据距离提升\n每1米提升0.5%，最大提升50%"), 25);
		// 修改全局变量(debuffEventId, 添加至数组, 11);
		// 全局.debuffEvent = 数组(
		// 	数组(自定义字符串("重力异常"), 自定义字符串("移动速度降低50%，跳跃高度降低70%"), 20),
        //     数组(自定义字符串("电磁脉冲"), 自定义字符串("被侵入，无法使用技能"), 8),
        //     数组(自定义字符串("粉丝狂热"), 自定义字符串("成为所有AI堡垒的优先攻击目标"), 25),
        //     数组(自定义字符串("易损"), 自定义字符串("受到的所有伤害提高25%"), 25),
		// 	数组(自定义字符串("限速40"), 自定义字符串("移动时每秒损失25+300%额外移动速度的生命值"), 25)
		// );

		// "机制"
		全局.mechEvent = 空数组;
		全局.mechEventId = 空数组;

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包：机制"), 自定义字符串("痛苦转化"), 真, 0), 2);
		全局.mechEvent[0] = 数组(自定义字符串("痛苦转化"), 自定义字符串("单次受到超过最大生命值30%的伤害立即回复25%最大生命值"), 30);
		修改全局变量(mechEventId, 添加至数组, 0);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包：机制"), 自定义字符串("纳米战甲"), 真, 1), 2);
		全局.mechEvent[1] = 数组(自定义字符串("纳米战甲"), 自定义字符串("获得最大生命值1000%的临时生命值，被减速25%"), 15);
		修改全局变量(mechEventId, 添加至数组, 1);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包：机制"), 自定义字符串("赌徒"), 真, 2), 2);
		全局.mechEvent[2] = 数组(自定义字符串("赌徒"), 自定义字符串("技能有50%概率永久损失或增加10%最大生命值"), 15);
		修改全局变量(mechEventId, 添加至数组, 2);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包：机制"), 自定义字符串("有点松弛"), 真, 3), 2);
		全局.mechEvent[3] = 数组(自定义字符串("有点松弛"), 自定义字符串("移动时产生阻挡友方视线的迷雾"), 30);
		修改全局变量(mechEventId, 添加至数组, 3);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包：机制"), 自定义字符串("体积膨胀"), 真, 4), 2);
		全局.mechEvent[4] = 数组(自定义字符串("体积膨胀"), 自定义字符串("体积变大200%，最大生命值提高500%"), 60);
		修改全局变量(mechEventId, 添加至数组, 4);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包：机制"), 自定义字符串("迷你形态"), 真, 5), 2);
		全局.mechEvent[5] = 数组(自定义字符串("迷你形态"), 自定义字符串("体积缩小60%，最大生命值降低50%"), 60);
		修改全局变量(mechEventId, 添加至数组, 5);

		根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包：机制"), 自定义字符串("悄悄滴进村"), 真, 6), 2);
		全局.mechEvent[6] = 数组(自定义字符串("悄悄滴进村"), 自定义字符串("下蹲让堡垒无法检测到你，移动速度降低 25%"), 45);
		修改全局变量(mechEventId, 添加至数组, 6);

		// 2.0
		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：机制"), 自定义字符串("紧急避障"), 真, 7), 2);
		// 全局.mechEvent[7] = 数组(自定义字符串("紧急避障"), 自定义字符串("受到伤害 3 秒后移动速度提高 80%"), 45);
		// 修改全局变量(mechEventId, 添加至数组, 7);

		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：机制"), 自定义字符串("逆风而行"), 真, 8), 2);
		// 全局.mechEvent[8] = 数组(自定义字符串("逆风而行"), 自定义字符串("移动速度提高 60%，但只能向后移动"), 30);
		// 修改全局变量(mechEventId, 添加至数组, 8);

		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：机制"), 自定义字符串("刹车失灵"), 真, 9), 2);
		// 全局.mechEvent[9] = 数组(自定义字符串("刹车失灵"), 自定义字符串("不受控的向前移动，移动速度会逐渐提高至 200%"), 45);
		// 修改全局变量(mechEventId, 添加至数组, 9);

		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：机制"), 自定义字符串("跑步减肥"), 真, 10), 2);
		// 全局.mechEvent[10] = 数组(自定义字符串("跑步减肥"), 自定义字符串("体型随移动速度变化，速度越快体型越小"), 45);
		// 修改全局变量(mechEventId, 添加至数组, 10);

		// 根据条件跳过(!地图工坊设置开关(自定义字符串("随机事件包 2：机制"), 自定义字符串("ALL IN or Nothing"), 真, 11), 2);
		// 全局.mechEvent[11] = 数组(自定义字符串("ALL IN or Nothing"), 自定义字符串("50% 概率获得 2 个增益或减益效果"), 45);
		// 修改全局变量(mechEventId, 添加至数组, 11);

		// 全局.mechEvent = 数组(
        //     数组(自定义字符串("痛苦转化"), 自定义字符串("单次受到超过最大生命值30%的伤害立即回复25%最大生命值"), 30),
        //     // 数组(自定义字符串("钢铁防线"), 自定义字符串("获得最大生命值500%的临时护甲，被侵入15秒"), 30),
		// 	数组(自定义字符串("纳米战甲"), 自定义字符串("获得最大生命值1000%的临时生命值，被减速25%"), 15),
        //     数组(自定义字符串("赌徒"), 自定义字符串("技能有50%概率永久损失或增加10%最大生命值"), 15),
        //     数组(自定义字符串("有点松弛"), 自定义字符串("移动时产生阻挡友方视线的迷雾"), 45),
		// 	数组(自定义字符串("体积膨胀"), 自定义字符串("体积变大200%，最大生命值提高500%"), 60),
        //     数组(自定义字符串("迷你形态"), 自定义字符串("体积缩小60%，最大生命值降低50%"), 60),
		// 	数组(自定义字符串("悄悄滴进村"), 自定义字符串("下蹲让堡垒无法检测到你，移动速度降低 25%"), 45)
		// );

		// "英雄专属"
		// 全局.heroEvent = 数组(	
		// 	数组(自定义字符串("胜利意志"), 自定义字符串("致命伤害时无敌并持续恢复"), 30),
        //     数组(自定义字符串("大功率标枪"), 自定义字符串("标枪旋击可以朝前方飞行"), 30),
        //     数组(自定义字符串("我佛慈悲"), 自定义字符串("造成伤害会击晕敌人1.25秒"), 25),
        //     数组(自定义字符串("美丽冻人"), 自定义字符串("伤害会使敌人冰冻0.5-5秒"), 25)
		// );
	}
}

规则("[VishkarEvent]: set player event")
{
	事件
	{
		子程序;
		setPlayerEvent;
	}

	动作
	{
		事件玩家.categoryRoll = 随机整数(0, 100);
		if(事件玩家.categoryRoll <= 40);
            // 增益事件 40%
            事件玩家.eventType = 0;
			事件玩家.eventId = 随机整数(0, 数量(全局.buffEvent) - 1);
			事件玩家.eventName = 首个(全局.buffEvent[事件玩家.eventId]);
			事件玩家.eventDesc = 全局.buffEvent[事件玩家.eventId][1];
			事件玩家.eventDuration = 最后(全局.buffEvent[事件玩家.eventId]);
			事件玩家.eventCount[0] += 1;
			根据条件跳过(事件玩家.eventId == 0, 1);
			事件玩家.eventLucky = 事件玩家.eventLucky > 0 ? 事件玩家.eventLucky + 1 : 1;
        else if(事件玩家.categoryRoll <= 80);
			// 减益事件 40%
			事件玩家.eventType = 1;
			事件玩家.eventId = 随机整数(0, 数量(全局.debuffEvent) - 1);
			事件玩家.eventName = 首个(全局.debuffEvent[事件玩家.eventId]);
			事件玩家.eventDesc = 全局.debuffEvent[事件玩家.eventId][1];
			事件玩家.eventDuration = 最后(全局.debuffEvent[事件玩家.eventId]);
			事件玩家.eventCount[1] += 1;
			事件玩家.eventLucky = 事件玩家.eventLucky < 0 ? 事件玩家.eventLucky - 1 : -1;
		else;
			// 机制事件 20%
			事件玩家.eventType = 2;
			事件玩家.eventId = 随机整数(0, 数量(全局.mechEvent) - 1);
			事件玩家.eventName = 首个(全局.mechEvent[事件玩家.eventId]);
			事件玩家.eventDesc = 全局.mechEvent[事件玩家.eventId][1];
			事件玩家.eventDuration = 最后(全局.mechEvent[事件玩家.eventId]);
			事件玩家.eventCount[2] += 1;
		end;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		事件玩家.eventLastId = 事件玩家.eventId;
		根据条件跳过(事件玩家.eventId == 666, 2);
		小字体信息(事件玩家, 自定义字符串("  {0}  触发事件：{1}（{2}）", 技能图标字符串(英雄(黑影), 按钮(终极技能)), 事件玩家.eventName, 事件玩家.eventDuration > 0 ? 自定义字符串("{0}秒", 事件玩家.eventDuration) : 自定义字符串("一次性")));
		小字体信息(事件玩家, 自定义字符串("  {0}  事件效果：{1}", 技能图标字符串(英雄(黑影), 按钮(终极技能)), 事件玩家.eventDesc));
		调用子程序(setEventDuration);
	}
}

规则("[VishkarEvent]: player event end")
{
	事件
	{
		子程序;
		clearPlayerEvent;
	}

	动作
	{
		事件玩家.categoryRoll = 空;
		事件玩家.eventId = -1;
		事件玩家.eventType = 空;
		事件玩家.eventDuration = 空;
		事件玩家.eventName = 空;
		事件玩家.eventDesc = 空;
		事件玩家.mov_speed_penalty = 空;
		事件玩家.mov_speed_buff = 空;
		事件玩家.healing_increase = 空;
		事件玩家.healing_decrease = 空;
		事件玩家.dmg_reduction = 空;
		事件玩家.dmg_increase = 空;
		事件玩家.targetWeight = 空;
		事件玩家.targetSilence = 假;
		事件玩家.sizeHealth = 1;
		消除效果(事件玩家.eventEffect);
		事件玩家.eventEffect = 空;
		调用子程序(setPlayerMovSpeed);
		调用子程序(setPlayerDmgReduc);
		小字体信息(事件玩家, 自定义字符串("  事件已结束"));
	}
}

规则("[VishkarEvent]: set player movement speed")
{
	事件
	{
		子程序;
		setPlayerMovSpeed;
	}

	动作
	{
		// 等待(服务器负载 / 100 * 0.032, 无视条件);
		设置移动速度(事件玩家, 100 - 事件玩家.mov_speed_penalty + 事件玩家.mov_speed_buff);
	}
}

规则("[VishkarEvent]: set player healing")
{
	事件
	{
		子程序;
		setPlayerDmgReduc;
	}

	动作
	{
		// 等待(服务器负载 / 100 * 0.032, 无视条件);
		设置受到伤害(事件玩家, 100 + 事件玩家.dmg_increase - 事件玩家.dmg_reduction);
	}
}

规则("[VishkarEvent]: set player HP")
{
	事件
	{
		子程序;
		setPlayerHP;
	}

	动作
	{
		// 等待(服务器负载 / 100 * 0.032, 无视条件);
		设置最大生命值(事件玩家, 100 * 事件玩家.sizeHealth + 事件玩家.heart_steel);
		// 治疗(事件玩家, 最大生命值(事件玩家));
	}
}

规则("[VishkarEvent]: set Event Duration")
{
	事件
	{
		子程序;
		setEventDuration;
	}

	动作
	{
		// 等待(服务器负载 / 100 * 0.032, 无视条件);
		停止追踪玩家变量(事件玩家, eventDurationHud);
		事件玩家.eventDurationHud = 事件玩家.eventDuration;
		// 根据条件中止(事件玩家.eventDuration == 0);
		// 设置最大生命值(事件玩家, 100 * 事件玩家.sizeHealth + 事件玩家.heart_steel);
		追踪玩家变量频率(事件玩家, eventDurationHud, 0, 1, 全部禁用);
		// 治疗(事件玩家, 最大生命值(事件玩家));
	}
}



规则("[VishkarEvent]: get player event")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		全局.vishkarEventActivated == 真;
		事件玩家.heroNumber > 2;
		已重生(事件玩家) == 真;
		// 事件玩家.isWinner != 真;
		事件玩家.eventId == -1;
	}

	动作
	{
		等待(!事件玩家.isWinner ? 随机整数(30, 45) : 45, 当为“假”时中止);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		调用子程序(setPlayerEvent);
		等待直到(事件玩家.eventDuration == 0, 事件玩家.eventDuration);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		调用子程序(clearPlayerEvent);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		如条件为“真”则循环;
	}
}

规则("[VishkarEvent]: check player event lucky")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		全局.vishkarEventActivated == 真;
		已重生(事件玩家) == 真;
		// 事件玩家.isWinner != 真;
		事件玩家.eventLucky >= 10;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 无视条件);
		创建HUD文本(事件玩家, 空, 自定义字符串("幸运星 {0} ", 图标字符串(星形)), 空, 左边, 70, 空, 自定义颜色(X方向分量(全局.heroColor[5]),Y方向分量(全局.heroColor[5]),Z方向分量(全局.heroColor[5]),255), 空, 可见和字符串, 始终不可见);
		等待直到(总计消耗时间 > 全局.rebootTime, 999999986991104.000);
	}
}

规则("[VishkarEvent]: check player event unlucky")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		全局.vishkarEventActivated == 真;
		已重生(事件玩家) == 真;
		// 事件玩家.isWinner != 真;
		事件玩家.eventLucky == -10;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 无视条件);
		创建HUD文本(事件玩家, 空, 自定义字符串("What Can I Say {0} ", 图标字符串(晕眩)), 空, 左边, 71, 空, 自定义颜色(X方向分量(全局.heroColor[5]),Y方向分量(全局.heroColor[5]),Z方向分量(全局.heroColor[5]),255), 空, 可见和字符串, 始终不可见);
		等待直到(总计消耗时间 > 全局.rebootTime, 999999986991104.000);
	}
}

规则("set player title")
{
	事件
	{
		子程序;
		setPlayerTitle;
	}
	
	动作
	{
		等待(服务器负载 / 100 * 0.500, 无视条件);
		事件玩家.playerTitles = 空数组;
		事件玩家.playerTitleWhileIndex = 0;
		"关联查询"
		While(数量(事件玩家.playerTitles) < 数量(全局.playerTitleRelation[事件玩家.playerTitleRelationIndex]));
			修改玩家变量(事件玩家, playerTitles, 添加至数组, 数组(全局.allTitle[全局.playerTitleRelation[事件玩家.playerTitleRelationIndex][事件玩家.playerTitleWhileIndex]]));
			// 小字体信息(事件玩家, 自定义字符串("{0}", 全局.playerTitleRelation[事件玩家.playerTitleRelationIndex][事件玩家.playerTitleWhileIndex]));
			事件玩家.playerTitleWhileIndex += 1;
			等待(0.016, 无视条件);
			禁用 根据条件中止(事件玩家.playerTitleWhileIndex >= 数量(全局.playerTitleRelation[事件玩家.playerTitleRelationIndex]));
		END;
		等待(0.016, 无视条件);
		事件玩家.playerTitleWhileIndex = 0;
		IF(数量(已过滤的数组(全局.mapTitleRelation, 首个(当前数组元素) == 事件玩家.playerTitleRelationIndex)) > 0);
			While(数量(事件玩家.playerTitles) < 数量(全局.playerTitleRelation[事件玩家.playerTitleRelationIndex]) + 数量(已过滤的数组(全局.mapTitleRelation, 首个(当前数组元素) == 事件玩家.playerTitleRelationIndex)));
			// 禁用 小字体信息(事件玩家, 自定义字符串("{0}", 已过滤的数组(全局.mapTitleRelation, 首个(当前数组元素) == 事件玩家.playerTitleRelationIndex)));
				修改玩家变量(事件玩家, playerTitles, 添加至数组, 数组(全局.allTitle[已过滤的数组(全局.mapTitleRelation, 首个(当前数组元素) == 事件玩家.playerTitleRelationIndex)[事件玩家.playerTitleWhileIndex][1]]));
			事件玩家.playerTitleWhileIndex += 1;
			等待(0.016, 无视条件);
		END;
		// 事件玩家.playerTitleAndColor = 数组(首个(最后(事件玩家.playerTitles)), 最后(最后(事件玩家.playerTitles)));
	}
}

规则("save player data if the player has pa﻿ssed round 2")
{
	事件
	{
		子程序;
		savePlayerData;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.500, 无视条件);
		If(事件玩家.heroNumber > 2);
			"We're saving data as a string, because although we can't hold entity id's, we can hold entity names as string."
			If(!数组包含(全局.savedIndex, 自定义字符串("{0}", 事件玩家)));
				修改全局变量(savedIndex, 添加至数组, 自定义字符串("{0}", 事件玩家));
			End;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			全局.savedHero[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.heroNumber;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			全局.savedDeaths[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.runDeathCount;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			全局.savedIsWinner[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.isWinner;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			全局.savedSkipCount[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.skipCount;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			根据条件跳过(事件玩家.winnerTime == 空, 1);
			全局.savedWinnerTime[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.winnerTime;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			全局.savedA36TGrenade[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.A36TGrenade;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			全局.savedA36TGrenadeHit[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.A36TGrenadeHit;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			全局.savedA36TGrenadeDmg[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.A36TGrenadeDmg;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			全局.savedA36TGrenadeAlive[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.A36TGrenadeAlive;
			根据条件跳过(事件玩家.joinTime != 空, 1);
			全局.savedJoinTime[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 单次赋值(事件玩家.joinTime);
			小字体信息(事件玩家, 自定义字符串("  你的进度数据已保存"));
			等待(2, 无视条件);
			小字体信息(事件玩家, 自定义字符串("  如果当前游戏重开，所有人的进度数据将被清空"));
			等待(2, 无视条件);
			小字体信息(事件玩家, 自定义字符串("  为了保证房间处于公开状态，请确保房主赞赏等级为 3 级或以上"));
		End;
	}
}

规则("add 1 to heroNumber, switch player to the newly unlocked hero, and set hero availability to that hero and all preceding")
{
	事件
	{
		子程序;
		progressHero;
	}

	动作
	{
		事件玩家.heroNumber += 1;
		事件玩家.controlJumpIndex = 0;
		事件玩家.controlPlayerRespawn = 假;
		事件玩家.controlPlayerRespawnPosition = 空;
		小字体信息(所有玩家(所有队伍), 自定义字符串("  {0} 已经解锁 {1}！", 事件玩家, 英雄图标字符串(全局.heroList[事件玩家.heroNumber])));
		播放效果(事件玩家, 状态爆炸声音, 颜色(白色), 所选位置(事件玩家), 200);
		事件玩家.progressionDeathCount = 0;
		等待(0.032, 无视条件);
		开始强制玩家选择英雄(事件玩家, 全局.heroList[事件玩家.heroNumber]);
		等待直到 (所用英雄(事件玩家) == 全局.heroList[事件玩家.heroNumber], 0.500);
		停止强制玩家选择英雄(事件玩家);
		等待(服务器负载 / 100 * 0.500, 无视条件);
		设置玩家可选的英雄(事件玩家, 数组分割(全局.heroList, 0, 事件玩家.heroNumber + 1));
		等待(服务器负载 / 100 * 0.500, 无视条件);
		预加载英雄(事件玩家, 数组(全局.heroList[事件玩家.heroNumber + 1], 全局.heroList[事件玩家.heroNumber + 1]));
		等待(服务器负载 / 100 * 0.500, 无视条件);
		等待(3, 无视条件);
		调用子程序(savePlayerData);
		等待(0.100, 无视条件);
	}
}

规则("initialize difficulty effects text")
{
	事件
	{
		子程序;
		setDifficulty;
	}

	动作
	{
		等待(服务器负载 / 100, 无视条件);
		If(真);
			跳过(数组(18, 0, 3, 6, 9, 12, 15)[1 + 数组值的索引(数组(0, 1, 2, 3, 4, 5), 全局.difficulty)]);
			全局.difficultyText[0] = 自定义字符串("简单");
			全局.difficultyText[1] = 颜色(绿色);
		Else;
			全局.difficultyText[0] = 自定义字符串("一般");
			全局.difficultyText[1] = 颜色(灰绿色);
		Else;
			全局.difficultyText[0] = 自定义字符串("困难");
			全局.difficultyText[1] = 颜色(黄色);
		Else;
			全局.difficultyText[0] = 自定义字符串("专家");
			全局.difficultyText[1] = 颜色(橙色);
		Else;
			全局.difficultyText[0] = 自定义字符串("传奇");
			全局.difficultyText[1] = 颜色(红色);
		Else;
			全局.difficultyText[0] = 自定义字符串("地狱");
			全局.difficultyText[1] = 颜色(紫色);
		Else;
		End;
	}
}

规则("3rd camera function")
{
	事件
	{
		子程序;
		setThirdPerson;
	}

	动作
	{
		事件玩家.third = !事件玩家.third;
		If(事件玩家.third);
			"by overclocking"
			开始镜头(事件玩家, 射线命中位置(事件玩家 + 上 * (相距距离(眼睛位置(事件玩家), 事件玩家) + 0.500), 射线命中位置(事件玩家 + 上 * (相距距离(眼睛位置(事件玩家), 事件玩家) + 0.500), 事件玩家 + 上 * (
				相距距离(眼睛位置(事件玩家), 事件玩家) + 0.500) + 面朝方向(事件玩家) * -3, 空, 事件玩家, 真), 空, 事件玩家, 真), 事件玩家 + 面朝方向(事件玩家) * 100, 100);
		Else;
			停止镜头(事件玩家);
		End;
	}
}

规则("map - b﻿lizzworld")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(暴雪世界) || 全局.__currentMap__ == 1228) == 真;
	}

	动作
	{
		全局.bastionPosition[0] = 矢量(-121.979, 0.148, 110.507);
		全局.bastionPosition[1] = 矢量(-93.733, -1.047, 110.100);
		全局.bastionPosition[2] = 矢量(-66.733, 7.079, 110.571);
		全局.bastionPosition[3] = 矢量(-0.165, 7.421, 89.178);
		全局.bastionPosition[4] = 矢量(3.082, 3.900, 43.609);
		全局.bastionPosition[5] = 矢量(3.049, -4.850, 16.685);
		全局.endPosition = 矢量(2.772, -6.500, -6.900);
		全局.thirdPersonPosition = 矢量(-149.170, 0.830, 100.850);
		全局.resetPosition = 矢量(-150.250, 0.830, 104.510);
		全局.creditsPosition = 矢量(-170.800, 3.650, 96.450);
		开始强制重生室(队伍1, 2);
		全局.__currentMapText__ = 自定义字符串("暴雪世界");
		全局.mapTitleRelation = 数组(
            // 格式: [玩家索引, 称号索引]
            数组(7, 9), // 吾携秋水揽星河-征服者
            数组(7, 10), // 吾携秋水揽星河-主宰

			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰

			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9)  // 征服者
        );
	}
}

规则("map - dorado")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(多拉多);
	}

	动作
	{
		// 全局.bastionPosition = 矢量(170.288, 19.100, 45.051);
		全局.bastionPosition = 矢量(167.25, 10.85, 42.40);
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(126.713, 16.300, 17.517));
		修改全局变量(bastionPosition, 添加至数组, 矢量(113.04, 13.800, 24.63));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(118.262, 18.250, 1.209));
		修改全局变量(bastionPosition, 添加至数组, 矢量(112.06, 17.250, -2.91));
		修改全局变量(bastionPosition, 添加至数组, 矢量(102.79, 11.01, -23.56));
		修改全局变量(bastionPosition, 添加至数组, 矢量(78.973, 17.480, -6.843));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(34.074, 11.080, -17.958));
		修改全局变量(bastionPosition, 添加至数组, 矢量(34.78, 10.05, -6.80));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(26.361, 10.650, 20.115));
		修改全局变量(bastionPosition, 添加至数组, 矢量(32.21, 10.59, 20.55));
		修改全局变量(bastionPosition, 添加至数组, 矢量(8.83, 2.380, 25.76));
		// 全局.endPosition = 矢量(16.012, 空数组, 5.874);
		全局.endPosition = 矢量(15.47, 9.54, -1.000);
		全局.thirdPersonPosition = 矢量(182.470, 7.040, 42.270);
		全局.resetPosition = 矢量(183.300, 7.040, 37.960);
		全局.creditsPosition = 矢量(197.720, 10.010, 44.630);
		开始强制重生室(队伍1, 1);
		全局.mapTitleRelation = 数组(
			// 卖核弹的小女孩 - 征服者
			数组(13, 9),
			
			// 吾携秋水揽星河 - 征服者和主宰
			数组(7, 9),
			数组(7, 10),

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			
			// Cold - 征服者和主宰
			数组(9, 9),
			数组(9, 10),

			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰
			
			// 看啊情 - 征服者和主宰
			数组(17, 9),
			数组(17, 10),

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰
			
			// 尘风歌者 - 征服者和主宰
			数组(6, 9),
			数组(6, 10),

			// 寒霜冰湮 (索引8)
			数组(8, 9)   // 征服者
		);
	}
}

规则("map - eichenwalde")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(艾兴瓦尔德) || 全局.__currentMap__ == 565) == 真;
	}

	动作
	{
		全局.bastionPosition = 矢量(115.780, 14.732, -29.038);
		修改全局变量(bastionPosition, 添加至数组, 矢量(119.480, 18.855, -43.120));
		修改全局变量(bastionPosition, 添加至数组, 矢量(54.429, 23.320, -102.936));
		修改全局变量(bastionPosition, 添加至数组, 矢量(75.164, 12.660, -71.852));
		修改全局变量(bastionPosition, 添加至数组, 矢量(36.490, 8.938, -71.140));
		修改全局变量(bastionPosition, 添加至数组, 矢量(2.584, 8.026, -63.687));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-12.503, 3.514, -31.548));
		修改全局变量(bastionPosition, 添加至数组, 矢量(0.632, 6.073, -2.154));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-32.381, -1.334, 0.005));
		修改全局变量(bastionPosition, 添加至数组, 矢量(70.234, 18.381, -65.979));
		修改全局变量(bastionPosition, 添加至数组, 矢量(8.544, 10.396, -42.598));
		// 全局.bastionPosition[0] = 矢量(123.333, 8.971, -27.303);
		// 全局.bastionPosition[1] = 矢量(89.318, 21.095, -62.697);
		// 全局.bastionPosition[2] = 矢量(37.930, 12.620, -79.920);
		// 全局.bastionPosition[3] = 矢量(23.799, 7.417, -53.839);
		// 全局.bastionPosition[4] = 矢量(-4.858, 6.957, -31.559);
		// 全局.bastionPosition[5] = 矢量(25.587, 6.300, -14.531);
		// 全局.endPosition = 矢量(-10.354, -2.149, -12.399);
		全局.endPosition = 矢量(-26.72, 1.97, -34.09);
		全局.thirdPersonPosition = 矢量(131.335, 10.720, 1.098);
		全局.resetPosition = 矢量(128.060, 10.720, 1.840);
		全局.creditsPosition = 矢量(132.820, 13.720, 9.040);
		开始强制重生室(队伍1, 2);
		全局.__currentMapText__ = 全局.__currentMap__ == 565 ? 自定义字符串("阿德勒斯布鲁恩") : 当前地图;
		全局.mapTitleRelation = 数组(
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰
			数组(6, 0),   // 开拓者
			
			// 顾北酒笙 (索引4)
			数组(4, 9),   // 征服者
			数组(4, 10),  // 主宰
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			数组(7, 0),   // 开拓者
			
			// 挽风 (索引14)
			数组(14, 9),  // 征服者
			
			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			
			// 看啊情 (索引17)
			数组(17, 9),  // 征服者
			
			// 她说话有股孩子气 (索引21)
			数组(21, 9),  // 征服者
			
			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰
			数组(12, 0),  // 开拓者
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			数组(9, 0),   // 开拓者

			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰
			数组(10, 0),   // 开拓者
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			数组(8, 0),   // 开拓者
			
			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰
			数组(18, 0),  // 开拓者
			
			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰
			数组(19, 0),  // 开拓者
			
			// 锦木千束 (索引20)
			数组(20, 9),  // 征服者
			数组(20, 10), // 主宰
			数组(20, 0)   // 开拓者
		);
	}
}

规则("map - havana")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(哈瓦那);
	}

	动作
	{
		全局.bastionPosition = 矢量(117.332, 14.433, -58.091);
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(140.438, 6.413, -16.667));
		修改全局变量(bastionPosition, 添加至数组, 矢量(97.00, 9.01, -25.51));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(31.288, 18.900, -75.331));
		修改全局变量(bastionPosition, 添加至数组, 矢量(62.21, 12.06, -83.30));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(14.787, 7.300, -47.470));
		修改全局变量(bastionPosition, 添加至数组, 矢量(11.580, 7.960, -52.71));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(15.880, 12.660, -52.71));
		修改全局变量(bastionPosition, 添加至数组, 矢量(10.13, 6.000, -100.38));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-32.514, 7.150, -79.487));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-37.54, 8.230, -72.23));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-71.110, 5.846, -72.362));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-77.17, 10.13, -66.78));
		// 全局.endPosition = 矢量(-77.203, 2, -50.678);
		全局.endPosition = 矢量(-77.24, 7.22, -49.83);
		全局.thirdPersonPosition = 矢量(158.256, 11, -47.739);
		全局.resetPosition = 矢量(158.300, 11, -44.350);
		全局.creditsPosition = 矢量(193.450, 13.250, -46.490);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(
			数组(0, 9),   // 征服者
			数组(0, 10),  // 主宰
			数组(1, 9),   // 征服者
			数组(1, 10),  // 主宰
			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰

			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰

			// 尘风歌者 - 征服者和主宰
			数组(6, 9),
			数组(6, 10),

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰

			// 顾北酒笙 (索引4)
			数组(4, 9),   // 征服者
			数组(4, 10),  // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9)  // 征服者
		);
	}
}

规则("map - hollywood")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(好莱坞) || 全局.__currentMap__ == 1505) == 真;
	}

	动作
	{
		全局.bastionPosition = 矢量(-27.99, 6.85, -137.80);
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(97.00, 9.01, -25.51));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-2.241, 12.161, -112.505));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-35.35, 3.77, -112.58));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-19.99, 9.75, -100.10));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-5.46, 4.62, -73.74));
		修改全局变量(bastionPosition, 添加至数组, 矢量(7.94, 10.90, -69.79));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(11.552, 6.303, -69.943));
		修改全局变量(bastionPosition, 添加至数组, 矢量(30.55, 3.57, -42.43));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-7.480, 7.441, -43.441));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-20.714, 8.050, 9.977));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(4.864, 7.147, 38.401));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-9.16, 5.01, 46.10));
		// 根据条件跳过(全局.difficulty < 4, 1);
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-17.03, 6.33, 46.71));
		// 全局.bastionPosition[0] = 矢量(-26.166, 7.503, -134.609);
		// 全局.bastionPosition[1] = 矢量(-2.241, 12.161, -112.505);
		// 全局.bastionPosition[2] = 矢量(11.552, 6.303, -69.943);
		// 全局.bastionPosition[3] = 矢量(-7.480, 7.441, -43.441);
		// 全局.bastionPosition[4] = 矢量(-20.714, 8.050, 9.977);
		// 全局.bastionPosition[5] = 矢量(4.864, 7.147, 38.401);
		全局.endPosition = 矢量(-12.002, -1.307, 69.489);
		全局.thirdPersonPosition = 矢量(-27.291, 3.920, -156.654);
		全局.resetPosition = 矢量(-23.640, 3.920, -157.440);
		全局.creditsPosition = 矢量(-31.650, 8.960, -175.050);
		开始强制重生室(队伍1, 2);

		全局.mapTitleRelation = 数组(
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰·

			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9)  // 征服者
		);
	}
}

规则("map - horizon lunar colony")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(“地平线”月球基地);
	}

	动作
	{
		全局.bastionPosition[0] = 矢量(-15.287, 6, -127.244);
		全局.bastionPosition[1] = 矢量(16.250, 11.860, -106.756);
		// 全局.bastionPosition[2] = 矢量(64.269, 16, -74.726);
		全局.bastionPosition[2] = 矢量(62.52, 14, -77.970);
		"Fixed by 他又"
		全局.bastionPosition[3] = 矢量(33.140, 13.03, -43.680);
		全局.bastionPosition[4] = 矢量(19.496, 9, -1.439);
		全局.bastionPosition[5] = 矢量(66.687, 8.520, -37.241);
		全局.endPosition = 矢量(34.476, 12, -23.518);
		全局.thirdPersonPosition = 矢量(-41.390, 5, -159.030);
		全局.resetPosition = 矢量(-45.620, 5, -156.870);
		全局.creditsPosition = 矢量(-55.870, 7.680, -171.970);
		开始强制重生室(队伍1, 0);

		全局.mapTitleRelation = 数组(
			// 烛台与南九 (索引3)
			数组(3, 9),   // 征服者
			数组(3, 10),  // 主宰

			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰

			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰

			// 顾北酒笙 (索引4)
			数组(4, 9),   // 征服者

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			数组(13, 10), // 主宰
			数组(13, 10), // 主宰

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 雨鸢 (索引19)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰

			// 雨鸢 (索引19)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10)  // 主宰
		);
	}
}

规则("map - junkerto﻿wn")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(渣客镇);
	}

	动作
	{
		// 全局.bastionPosition = 矢量(-96.235, 13.672, -136.725);
		全局.bastionPosition = 矢量(-101.37, 12.72, -135.27);
		修改全局变量(bastionPosition, 添加至数组, 矢量(-72.634, 6.669, -145.321));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-27.431, 13.480, -100.155));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-57.67, 13.98, -92.45));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-27.85, 14.52, -97.33));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-25.34, 8.29, -36.47));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-2.080, 11.366, -61.807));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-5.660, 14.63, -74.46));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(30.116, 13.407, -59.880));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(29.97, 16.37, -91.860));
		修改全局变量(bastionPosition, 添加至数组, 矢量(32.15, 15.16, -89.130));
		全局.endPosition = 矢量(30.248, 5.515, -81.733);
		全局.thirdPersonPosition = 矢量(-88.030, 11.220, -88);
		全局.resetPosition = 矢量(-103.910, 11.690, -86.600);
		全局.creditsPosition = 矢量(-92.710, 14.040, -73.790);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(
			// WildRage (索引5)
			数组(5, 9),   // 征服者
			数组(5, 10),  // 主宰
			
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰

			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰
			
			// 看啊情 (索引17)
			数组(17, 9),  // 征服者
			数组(17, 10)  // 主宰
		);
	}
}

规则("map - king's row")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(国王大道) || 全局.__currentMap__ == 742) == 真;
	}

	动作
	{
		全局.bastionPosition = 矢量(-143.900, 7.130, 10.150);
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-120.990, 1.070, -12.080));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-116.440, 6.130, 5.72));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-103.120, 6.930, -4.02));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-91.380, 1.140, -27.900));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-91.990, 7.50, -28.630));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-55.460, -0.200, -29.830));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-66.62, 4.500, -35.930));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-29.170, 2.55, -31.430));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(5.980, 6.110, -30.350));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-21.560, 2.580, -8.160));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-10.67, 16.970, 5.65));
		全局.endPosition = 矢量(-1.900, 5, -0.290);
		全局.thirdPersonPosition = 矢量(-176.048, -0.070, 36.540);
		全局.resetPosition = 矢量(-175.230, -0.070, 43.030);
		全局.creditsPosition = 矢量(-185.560, 3.530, 38.320);
		全局.__currentMapText__ = 自定义字符串("国王大道");
		开始强制重生室(队伍1, 1);
		全局.mapTitleRelation = 数组(
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰

			// 吾携秋水揽星河 - 征服者和主宰
			数组(7, 9),
			数组(7, 10),
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10),  // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰
			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9)  // 征服者
		);
	}
}

规则("map - numbani")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(努巴尼);
	}

	动作
	{
		"Fixed by 他又"
		全局.bastionPosition[0] = 矢量(179.102, 4.250, 13.115);
		全局.bastionPosition[1] = 矢量(154.224, -4.180, 13.616);
		全局.bastionPosition[2] = 矢量(118.815, 4.250, 3.556);
		全局.bastionPosition[3] = 矢量(78.459, 6.250, -11.527);
		全局.bastionPosition[4] = 矢量(67.43, 6.25, 18.39);
		全局.bastionPosition[5] = 矢量(38.95, 5.50, 8.93);
		全局.endPosition = 矢量(17.97, -0.18, 18.53);
		全局.thirdPersonPosition = 矢量(225.74, 0.200, 4.550);
		全局.resetPosition = 矢量(224.54, 0.200, 0.390);
		全局.creditsPosition = 矢量(254.540, 3.200, 22.870);
		开始强制重生室(队伍1, 1);
		全局.mapTitleRelation = 数组(
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰
			
			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),   // 主宰

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9)  // 征服者
		);
	}
}

规则("map - paraiso")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(帕拉伊苏);
	}

	动作
	{
		全局.bastionPosition = 矢量(-47.030, 6.860, -141.730);
		修改全局变量(bastionPosition, 添加至数组, 矢量(5.220, 12, -122));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-5.81, 10.000, -88.750));
		修改全局变量(bastionPosition, 添加至数组, 矢量(10.080, 3.900, -56.920));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(3.130, 11.160, -62.560));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-23.510, 10.110, -48.500));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-13.620, 8.220, -44.110));
		修改全局变量(bastionPosition, 添加至数组, 矢量(11.420, 5.100, -24.260));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-6.880, 0.500, 26.090));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(4.780, 0.97, 13.330));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-40.630, 3.000, 40.010));
		// 全局.endPosition = 矢量(-30.920, 3.300, 21.460);
		全局.endPosition = 矢量(-39.540, -2.000, 62.860);
		全局.thirdPersonPosition = 矢量(-78.250, 6.330, -167.960);
		全局.resetPosition = 矢量(-78.300, 5.030, -170.800);
		全局.creditsPosition = 矢量(-70.200, 7.750, -183.140);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			
			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10),  // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9)  // 征服者
		);
	}
}

规则("map - paris")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(巴黎);
	}

	动作
	{
		"made by 芋泥玛奇朵"
		全局.bastionPosition = 矢量(-95.984, 13.454, -83.535);
		修改全局变量(bastionPosition, 添加至数组, 矢量(-72.132, 11.976, -44.042));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-42.867, 18.510, -12.093));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-30.230, 10.020, 3.280));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-14.721, 14.250, -35.219));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-2.715, 10.080, -52.081));
		全局.endPosition = 矢量(9.563, 8.329, -59.980);
		全局.thirdPersonPosition = 矢量(-109.263, 15.300, -111.151);
		全局.resetPosition = 矢量(-115.030, 15.970, -122.820);
		全局.creditsPosition = 矢量(-119.740, 19, -132.450);
		开始强制重生室(队伍1, 1);
		全局.mapTitleRelation = 数组(
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰
			
			// 叽里咕噜说什么呢 (索引21)
			数组(21, 9),  // 征服者
			数组(21, 10)  // 主宰
		);
	}
}

规则("map - rialto")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(里阿尔托);
	}

	动作
	{
		开始强制重生室(队伍1, 2);
		"图外重生点"
		// 全局.controlRespawnPosition = 空数组;
		全局.controlRespawnPosition = 矢量(-52.36,3.83,-176.36);
		修改全局变量(controlRespawnPosition,  添加至数组, 矢量(53.17,1.25,22.99));
		全局.bastionPosition =  矢量(-64.421, 5.040, -125.927);
		修改全局变量(bastionPosition, 添加至数组, 矢量(-16.976, 1.660, -38.459));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-36.002, 4.750, -77.344));
		修改全局变量(bastionPosition, 添加至数组, 矢量(59.058, 0.070, -8.103));
		修改全局变量(bastionPosition, 添加至数组, 矢量(54.797, 1.740, -59.938));
		修改全局变量(bastionPosition, 添加至数组, 矢量(87.874, -0.370, 0.268));
		"高塔"
		修改全局变量(bastionPosition, 添加至数组, 矢量(60.53,50.43,61.63));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-13.12,4.75,47.31));
		修改全局变量(bastionPosition, 添加至数组, 矢量(27.18,4.75,36.89));
		修改全局变量(bastionPosition, 添加至数组, 矢量(20.90,0.75,54.61));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-19.85,10.75,8.80));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-19.85,10.75,11.92));
		全局.controlJumpPosition = 矢量(98.662, -1.500, -21.009);
		全局.endPosition = 矢量(-12.27, -1.250, -14.73);
		全局.thirdPersonPosition = 矢量(-54.920, 3.750, -158.320);
		全局.resetPosition = 矢量(-59.050, 3.750, -158.410);
		全局.creditsPosition = 矢量(-57.060, 5.250, -181.510);
		全局.mapTitleRelation = 数组(
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			
			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰
			
			// 草艮 (索引2)
			数组(2, 9),   // 征服者
			数组(2, 10),  // 主宰
			数组(2, 0),   // 开拓者
			
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰
			数组(10, 0),  // 开拓者
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			数组(8, 0),   // 开拓者
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			数组(9, 0)    // 开拓者
		);
	}
}

规则("map - route 66")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(66号公路);
	}

	动作
	{
		全局.bastionPosition[0] = 矢量(-95.624, 12.660, -5.541);
		// 全局.bastionPosition[1] = 矢量(-38.680, 12.750, -22.136);
		全局.bastionPosition[1] = 矢量(-61.870, 10.87, 5.36);
		// 全局.bastionPosition[2] = 矢量(-15.784, 8.540, -12.685);
		// 全局.bastionPosition[2] = 矢量(-20.44, 12.170, -15.13);
		全局.bastionPosition[2] = 矢量(-38.680, 12.750, -22.136);
		// 全局.bastionPosition[3] = 矢量(36.467, 2.140, -4.003);
		全局.bastionPosition[3] = 矢量(-20.44, 12.170, -15.13);
		// 全局.bastionPosition[4] = 矢量(48.707, 10.110, 25.063);
		全局.bastionPosition[4] = 矢量(26.871, 7.010, 2.468);
		全局.bastionPosition[5] = 矢量(53.82, 12.860, 10.55);
		// 全局.bastionPosition[6] = 矢量(37.23, 12.470, 55.15);
		全局.bastionPosition[6] = 矢量(33.75, 5.540, 48.50);
		全局.endPosition = 矢量(47.956, 5.200, 47.318);
		全局.thirdPersonPosition = 矢量(-115.228, 5.799, -49.590);
		全局.resetPosition = 矢量(-115.010, 4.500, -46.010);
		全局.creditsPosition = 矢量(-113.270, 7.500, -63.140);
		开始强制重生室(队伍1, 1);
		全局.mapTitleRelation = 数组(
			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰
			
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰

			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10)   // 主宰
		);
	}
}

规则("map - shambali monastery")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(香巴里寺院);
	}

	动作
	{
		全局.bastionPosition = 空数组;
		修改全局变量(bastionPosition, 添加至数组, 矢量(-36.100, 28.400, 190.320));
		// 禁用 修改全局变量(bastionPosition, 添加至数组, 矢量(-13.000, 25.500, 146.040));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-14.930, 25.08, 134.990));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-3.04, 25.04, 106.730));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-57.820, 29, 122.100));
		// 禁用 修改全局变量(bastionPosition, 添加至数组, 矢量(16.53, 22.000, 89.330));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-10.35, 20.570, 73.85));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-18.190, 23.250, 88.510));
		// 禁用 修改全局变量(bastionPosition, 添加至数组, 矢量(-37.18, 14.000, 68.800));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-39.84, 14.570, 60.140));
		修改全局变量(bastionPosition, 添加至数组, 矢量(10.190, 15.500, 40.290));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-16.060, 6.180, 12));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-13.310, 8.00, 0.33));
		全局.endPosition = 矢量(5.450, 9, 17.500);
		全局.thirdPersonPosition = 矢量(-7.690, 31.070, 226.970);
		全局.resetPosition = 矢量(-1.970, 31.070, 221.850);
		全局.creditsPosition = 矢量(1.750, 35, 232.500);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰
			
			// 烛台与南九 (索引3)
			数组(3, 9),   // 征服者
			数组(3, 10),  // 主宰
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			
			// 神之岛風咲 (索引11)
			数组(11, 9),  // 征服者
			数组(11, 10), // 主宰

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 雨鸢 (索引19)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			
			// WildRage (索引5)
			数组(5, 9),   // 征服者
			数组(5, 10),  // 主宰
			
			// 卖核弹的小女孩 (索引13)
			数组(13, 9)   // 征服者
		);
	}
}

规则("map - temple of anubis")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(阿努比斯神殿);
	}

	动作
	{
		全局.bastionPosition = 矢量(-17.188, 11.237, 105.646);
		修改全局变量(bastionPosition, 添加至数组, 矢量(-3.470, 20.350, 97.610));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-4.690, 22.570, 79.470));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-37.620, 1.910, 47.850));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-25.200, 1.070, 25.160));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-37.500, 16.800, -4.790));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-0.350, 17.870, -24.210));
		全局.endPosition = 矢量(-7.020, -0.660, -36.430);
		全局.springBoardPosition = 矢量(-47.93, 1.50, 51.33);
		全局.thirdPersonPosition = 矢量(-7.969, 4.701, 137.390);
		全局.resetPosition = 矢量(-17.160, 4.460, 137.760);
		全局.creditsPosition = 矢量(-11.300, 7.350, 149.110);
		开始强制重生室(队伍1, 1);
		全局.mapTitleRelation = 数组(
			// 豆本豆豆奶 (索引10)
			数组(10, 0),  // 开拓者
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			
			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰
			数组(12, 0),  // 开拓者

			// 尘风歌者 - 征服者和主宰
			数组(6, 9),
			数组(6, 10),
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 0),   // 开拓者
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			
			// Cold (索引9)
			数组(9, 0),   // 开拓者
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			
			// 看啊情 (索引17)
			数组(17, 9),  // 征服者
			数组(17, 0),  // 开拓者

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰
			
			// 卖核弹的小女孩 (索引13)
			数组(13, 9)   // 征服者
		);
	}
}

规则("map - volskaya industries")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(沃斯卡娅工业区);
	}

	动作
	{
		全局.bastionPosition = 矢量(-87.972, 2.020, 38.919);
		// 全局.bastionPosition = 矢量(-94.73, -0.730, 49.07);
		修改全局变量(bastionPosition, 添加至数组, 矢量(-67.835, 10.390, 49.479));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-63.809, -0.410, 77.730));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-11.250, 1.270, 76.356));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-16.279, 2.200, 41.017));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-6.364, 8.240, 35.514));
		全局.endPosition = 矢量(-11.477, -6, 19.868);
		全局.thirdPersonPosition = 矢量(-113.051, -1.980, 31.996);
		全局.resetPosition = 矢量(-115.180, -1.980, 35.240);
		全局.creditsPosition = 矢量(-128.250, 0.500, 24.750);
		开始强制重生室(队伍1, 0);
		全局.mapTitleRelation = 数组(
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			
			// 看啊情 (索引17)
			数组(17, 9),  // 征服者
			数组(17, 10), // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			数组(9, 0),   // 开拓者
			
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10)   // 主宰
		);
	}
}

规则("map - watchpoint gibraltar")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(监测站：直布罗陀);
	}

	动作
	{
		全局.bastionPosition[0] = 矢量(70.099, 9, 26.803);
		全局.bastionPosition[1] = 矢量(81.759, 6, 3.200);
		全局.bastionPosition[2] = 矢量(64.465, 9.690, -32.138);
		全局.bastionPosition[3] = 矢量(32.373, 3, -50.866);
		全局.bastionPosition[4] = 矢量(31.113, 7.300, -89.871);
		// 全局.bastionPosition[5] = 矢量(41.383, 4, -124.788);
		全局.bastionPosition[5] = 矢量(56.88, 9.23, -118.92);
		全局.bastionPosition[6] = 矢量(19.43, 6, -131.05);
		// 全局.endPosition = 矢量(46.558, 1, -146.808);
		全局.endPosition = 矢量(15.70, -2.00, -134.65);
		全局.thirdPersonPosition = 矢量(93.88, 1.060, 63.17);
		全局.resetPosition = 矢量(97.55, 1.060, 60.380);
		全局.creditsPosition = 矢量(112.23, 0, 73.590);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			
			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰
			
			// 卖核弹的小女孩 (索引13)
			数组(13, 9)   // 征服者
		);
	}
}

规则("map - 中城")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(中城);
	}

	动作
	{
		"Made by 他又 芋泥玛奇朵\n"
		"出生点左侧广告牌"
		禁用 全局.bastionPosition[0] = 矢量(134.71, 6.09, -49.77); //出生点左侧广告牌
		"出生点右侧二楼高台"
		禁用 全局.bastionPosition[0] = 矢量(100.40, 11.85, -57.56); //出生点右侧二楼高台
		"出生点正门对面小平台"
		全局.bastionPosition[0] = 矢量(127.11, 5.80, -35.75); //出生点正门对面小平台
		禁用 全局.bastionPosition[1] = 矢量(81.96, 7.88, -13.08);
		全局.bastionPosition[1] = 矢量(86.34, 11.85, -10.15);
		全局.bastionPosition[2] = 矢量(54.42, 11.10, -6.14);
		// 全局.bastionPosition[2] = 矢量(46.89, 4.73, -21.63);
		// 全局.bastionPosition[2] = 矢量(40.36, 7.87, -13.00);
		全局.bastionPosition[3] = 矢量(40.19, 10.86, 16.90);
		全局.bastionPosition[4] = 矢量(3.60, 9.97, 58.11);
		全局.bastionPosition[5] = 矢量(-3.60, 8.66, 87.62);
		// 全局.endPosition = 矢量(38.52, 3.75, 100.60);
		全局.endPosition = 矢量(-28.26, 3.75, 84.04);
		全局.thirdPersonPosition = 矢量(133.91, 1.84, -104.94);
		全局.resetPosition = 矢量(119.51, 1.84, -104.94);
		全局.creditsPosition = 矢量(126.500, 3, -125.37);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			
			// 顾北酒笙 (索引4)
			数组(4, 9),   // 征服者
			数组(4, 10),  // 主宰
			
			// bingo (需要添加到titlePlayer数组，假设索引为22)
			数组(22, 9),  // 征服者
			数组(22, 10), // 主宰

			// 雨鸢 (索引19)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10), // 主宰
			
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰
			
			// 卖核弹的小女孩 (索引13)
			数组(13, 9)   // 征服者
		);
	}
}

规则("map - 埃斯佩兰萨")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(埃斯佩兰萨) || 全局.__currentMap__ == 276) == 真;
	}

	动作
	{
		"Made by 他又 芋泥玛奇朵"
		// 全局.bastionPosition[0] = 矢量(85.68, -0.27, -54.29);
		// 全局.bastionPosition[1] = 矢量(35.77, 0, -61.65);
		// 全局.bastionPosition[2] = 矢量(-26.09, 0, -79.68);
		// // 全局.bastionPosition[3] = 矢量(5.43, 0.99, 19.65);
		// 全局.bastionPosition[3] = 矢量(15.04, 3.00, -38.40);
		// 全局.bastionPosition[4] = 矢量(2.57, 6.02, 13.96);
		// 全局.bastionPosition[5] = 矢量(-20.26, 3.00, -27.62);
		// "终点旋转机械臂"
		// 禁用 全局.bastionPosition[6] = 矢量(-76.40, -0.36, -71.07);
		// "终点右侧出生点门口"
		// 全局.bastionPosition[6] = 矢量(-107.57, -1.00, -62.15); 
		全局.bastionPosition = 数组(矢量(86.815, -0.268, -54.406), 矢量(63.789, 1, -57.796), 矢量(14.121, 3.261, -42.146), 矢量(1.238, 7.966, 13.923),
			矢量(0.025, -0.002, -33.787), 矢量(-15.80, 3.08, -39.10), 矢量(-45.384, -1.583, -60.618), 矢量(60.250, -6, -93.538), 矢量(-26.245, 0,
			-80.277), 矢量(-108.094, -1.002, -60.285), 矢量(-71.269, 1.050, -49.368), 矢量(0.047, -2, -69.042));
		// 全局.endPosition = 矢量(-95.50, -3.00, -68.9) - 矢量(0, 2, 0);
		全局.endPosition = 矢量(-117.370, -3, -45.650);
		全局.springBoardPosition = 矢量(-73.720, -3, -34.190);
		全局.thirdPersonPosition = 矢量(126.70, -1.64, -90.03);
		全局.resetPosition = 矢量(126.70, -1.640, -81.42);
		全局.creditsPosition = 矢量(116.67, -0.29, -82.29);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			数组(8, 0),   // 开拓者
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			数组(9, 0),   // 开拓者

			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰
			数组(10, 0),   // 开拓者

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰
			数组(18, 0),   // 开拓者

			// WildRage (索引5)
			数组(5, 9),   // 征服者
			数组(5, 10),  // 主宰
			数组(5, 0),   // 开拓者

			// 尘风歌者 - 征服者和主宰
			数组(6, 9),
			数组(6, 10),
			数组(6, 0),   // 开拓者

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰
			数组(12, 0)   // 开拓者
		);
	}
}

规则("map - 斗兽场")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(斗兽场) || 全局.__currentMap__ == 2147) == 真;
	}

	动作
	{
		"Made by 他又 芋泥玛奇朵"
		全局.bastionPosition = 矢量(60.94, 12.50, -13.78);
		// 全局.bastionPosition[1] = 矢量(-3.42, 20, -2.19);
		修改全局变量(bastionPosition, 添加至数组, 矢量(30.54, 5.09, 6.64));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-3.42, 20, -2.19));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-7.85, 20, -29.95));
		// 全局.bastionPosition[3] = 矢量(5.43, 0.99, 19.65);
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-54.52, 12.46, -10.10));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-21.18, 5.10, 1.35));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-21.88, 7.49, -3.00));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-54.52, 12.46, -10.10));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-9.98, 5.00, -39.50));
		// 修改全局变量(bastionPosition, 添加至数组, 矢量(-55.02, 9.77, -22.14));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-60.93, 12.21, -11.91));
		"终点"
		修改全局变量(bastionPosition, 添加至数组, 矢量(-88.63, 13.77, -23.49));
		// "终点右侧出生点门口"
		// 全局.bastionPosition[5] = 矢量(-107.57, -1.00, -62.15);
		全局.endPosition = 矢量(-90.31, 9.00, -33.55);
		全局.thirdPersonPosition = 矢量(117.38, 9.00, -38.98);
		全局.resetPosition = 矢量(111.17, 9.00, -50.91);
		全局.creditsPosition = 矢量(117.64, 13.00, -48.66);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(
			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者
			
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			数组(9, 0),   // 开拓者

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 雨鸢 (索引19)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰
			
			// 豆本豆豆奶 (索引10)
			数组(10, 10), // 主宰
			数组(10, 0)   // 开拓者
		);
	}
}

规则("map - 鲁纳塞彼")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(鲁纳塞彼) || 全局.__currentMap__ == 8048) == 真;
	}

	动作
	{
		"made by 他又"
		// 全局.bastionPosition = 矢量(70.22, 14.62, 36.56);
		全局.bastionPosition = 矢量(70.39, 7.86, 24.73);
		修改全局变量(bastionPosition, 添加至数组, 矢量(40.80, 4.01, 5.96));
		修改全局变量(bastionPosition, 添加至数组, 矢量(61.26, 5.99, -16.04));
		修改全局变量(bastionPosition, 添加至数组, 矢量(0.08, 8.340, 83.49));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-25.99, 1.21, 15.51));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-43.32, 4.00, 36.50));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-71.28, 14.62, 38.58));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-93.05, 7.06, 18.11));
		全局.endPosition = 矢量(-106.93, 7.99, 22.24);
		全局.thirdPersonPosition = 矢量(113.31, 7.09, -3.50);
		全局.resetPosition = 矢量(111.34, 7.09, -5.60);
		全局.creditsPosition = 矢量(124.60, 8.77, -15.99);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),   // 主宰

			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10) // 主宰
		);
	}
}

规则("map - 新皇后街")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(新皇后街);
	}

	动作
	{
		"made by 他又"
		全局.bastionPosition = 数组(矢量(-74.922, 14.194, -16.661), 矢量(-25.688, 4, -22.819), 矢量(-29.72, 7.12, -6.68), 矢量(-7.696, 4.850,
		35.246), 矢量(-0.035, 2.376, -11.505), 矢量(19.183, 1.477, -27.407), 矢量(15.862, 5.063, -12.591), 矢量(39.340, 8.100, -12.938), 矢量(
		51.915, 10, -17.308));
		// 全局.bastionPosition[0] = 矢量(-67.05, 11.20, -24.36);
		// // 全局.bastionPosition[1] = 矢量(-28.02, 3.27, -56.15);
		// 全局.bastionPosition[1] = 矢量(-30.62, 3.30, -39.39);
		// 全局.bastionPosition[2] = 矢量(-16.30, 4.06, 14.83);
		// 全局.bastionPosition[3] = 矢量(16.15, 4.06, 15.19);
		// 全局.bastionPosition[4] = 矢量(43.48, 10.00, -20.22);
		// // 全局.bastionPosition[5] = 矢量(86.84, 11.00, -6.84);
		// 全局.bastionPosition[5] = 矢量(74.74, 10.13, -39.00);
		全局.endPosition = 矢量(90.00, 11.00, -45.90);
		全局.thirdPersonPosition = 矢量(-111.26, 11.00, -32.03);
		全局.resetPosition = 矢量(-111.170, 11.00, -17.00);
		全局.creditsPosition = 矢量(-102.08, 17.29, -24.46);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(
			// // 尘风歌者 (索引6)
			// 数组(6, 9),   // 征服者
			// 数组(6, 10),  // 主宰
			
			// // 豆本豆豆奶 (索引10)
			// 数组(10, 9),  // 征服者
			// 数组(10, 10), // 主宰
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			数组(8, 0),   // 开拓者

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰
			数组(12, 0),   // 开拓者

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),   // 主宰
			数组(7, 0),   // 开拓者

			// // 白银之鹰 (索引22)
			// 数组(22, 9),  // 征服者
			// 数组(22, 10)  // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰
			数组(18, 0)   // 开拓者
		);
	}
}

规则("map - 皇家赛道")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(皇家赛道);
	}

	动作
	{
		"Made by 他又 芋泥玛奇朵"
		全局.bastionPosition[0] = 矢量(105.65, 15.95, 14.28);
		全局.bastionPosition[1] = 矢量(56.16, 18.97, 21.78);
		全局.bastionPosition[2] = 矢量(12.30, 13.180, -27.04);
		全局.bastionPosition[3] = 矢量(-28.93, 11.00, -3.85);
		全局.bastionPosition[4] = 矢量(-14.51, 8.00, -34.71);
		// 全局.bastionPosition[5] = 矢量(-47.95, 4.24, -79.55);
		全局.bastionPosition[5] = 矢量(-62.89, 13.30, -45.44);
		全局.bastionPosition[6] = 矢量(-46.18, 4.22, -69.18);
		全局.endPosition = 矢量(-76.75, 4.03, -74.17);
		全局.thirdPersonPosition = 矢量(135.08, 10.00, -3.31);
		全局.resetPosition = 矢量(129.68, 10.00, 0.04);
		全局.creditsPosition = 矢量(147.52, 11.50, -10.90);
		开始强制重生室(队伍1, 2);
		全局.mapTitleRelation = 数组(
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			
			// 顾北酒笙 (索引4)
			数组(4, 9),   // 征服者
			数组(4, 10),  // 主宰
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰

			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰
			
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10)   // 主宰
		);
	}
}

规则("map - 花村")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(花村) || 全局.__currentMap__ == 1848 || 全局.__currentMap__ == 地图(圣诞节花村)) == 真;
	}

	动作
	{
		"Made by 他又 芋泥玛奇朵"
		// 全局.bastionPosition[0] = 矢量(-15.46, 9.68, -89.300);
		// 全局.bastionPosition[1] = 矢量(1.87, 5.00, -41.04);
		// 全局.bastionPosition[2] = 矢量(-6.95, 8.01, -10.86);
		// // 全局.bastionPosition[3] = 矢量(29.19, 10.49, -5.70);
		// 全局.bastionPosition[3] = 矢量(27.00, 0.00, -7.87);
		// // 全局.bastionPosition[4] = 矢量(28.79, 6.52, 9.47);
		// 全局.bastionPosition[4] = 矢量(34.66, 6.00, 16.47);
		// 全局.bastionPosition[5] = 矢量(63.63, 6.00, -11.98);
		// 全局.endPosition = 矢量(72.38, -1.96, -0.16);
		全局.bastionPosition = 矢量(-20.750, 9.210, -78.140);
		修改全局变量(bastionPosition, 添加至数组, 矢量(11.870, 7.210, -47.220));
		修改全局变量(bastionPosition, 添加至数组, 矢量(28.310, 10.470, 6.600));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-6.950, 8.010, -10.860));
		修改全局变量(bastionPosition, 添加至数组, 矢量(49.130, 14.560, 17.960));
		修改全局变量(bastionPosition, 添加至数组, 矢量(52.200, -1, -0.580));
		修改全局变量(bastionPosition, 添加至数组, 矢量(15.610, 11.980, 17.470));
		修改全局变量(bastionPosition, 添加至数组, 矢量(46.870, -0.160, -15.600));
		修改全局变量(bastionPosition, 添加至数组, 矢量(60.130, -1.040, -15.610));
		全局.endPosition = 矢量(51.700, -1.870, 25.910);
		全局.thirdPersonPosition = 矢量(-33.20, 1.00, -115.04);
		全局.resetPosition = 矢量(-46.98, 1.00, -101.54);
		全局.creditsPosition = 矢量(-48.10, 2.50, -116.08);
		全局.__currentMapText__ = 自定义字符串("花村");
		// 开始强制重生室(队伍1, 0);
		全局.mapTitleRelation = 数组(
			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者

			// 吾携秋水揽星河 - 征服者和主宰
			数组(7, 9),
			数组(7, 10),
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			数组(9, 0),   // 开拓者
			
			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 0),  // 开拓者
			
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰
			数组(10, 0),  // 开拓者
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			数组(8, 0),   // 开拓者
			
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰
			数组(6, 0),   // 开拓者

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 雨鸢 (索引19)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰

			// 雨鸢 (索引19)
			数组(24, 9),  // 征服者
			数组(24, 10), // 主宰
			
			// 看啊情 (索引17)
			数组(17, 9),  // 征服者
			数组(17, 10), // 主宰
			数组(17, 0)   // 开拓者
		);
	}
}

规则("map - 伊利奥斯")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(伊利奥斯);
	}

	动作
	{
		开始强制重生室(队伍1, 2);
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		"made by 他又\n深井"
		If(数量(范围内玩家(矢量(-152.014, -1.104, -93.120), 30, 队伍1, 关闭)) != 0);
			全局.bastionPosition[0] = 矢量(-173.701, -0.460, -71.552);
			全局.bastionPosition[1] = 矢量(-207.983, 5.460, -31.971);
			全局.bastionPosition[2] = 矢量(-222.539, 0.100, -30.825);
			全局.bastionPosition[3] = 矢量(-223.926, 5.560, -16.079);
			全局.bastionPosition[4] = 矢量(-245.721, 5.560, 5.190);
			全局.bastionPosition[6] = 矢量(-257.450, 2.850, 35.113);
			全局.endPosition = 矢量(-271.140, -3.585, 33.279) - 矢量(0, 2, 0);
			全局.resetPosition = 矢量(-160.308, -1.355, -91.403);
			全局.thirdPersonPosition = 矢量(-148.168, -1.504, -88.932);
			全局.creditsPosition = 矢量(-150.880, 0.200, -97.020);
		"废墟"
		Else If(数量(范围内玩家(矢量(131.609, 64.254, -159.135), 30, 队伍1, 关闭)) != 0);
			全局.bastionPosition[0] = 矢量(111.310, 68.780, -183.068);
			全局.bastionPosition[1] = 矢量(83.250, 67.650, -179.529);
			全局.bastionPosition[2] = 矢量(28.394, 61.390, -148.333);
			全局.bastionPosition[3] = 矢量(5.918, 60.370, -170.376);
			全局.bastionPosition[4] = 矢量(-26.800, 67.620, -178.826);
			全局.bastionPosition[5] = 矢量(-52.040, 65.390, -179.058);
			"Tower goal position"
			全局.endPosition = 矢量(-47.306, 60.370, -184.722) - 矢量(0, 2, 0);
			"Base coordinates for world game settings HUD"
			全局.resetPosition = 矢量(128.072, 63.254, -165.528);
			全局.thirdPersonPosition = 矢量(129.560, 62.450, -153.472);
			全局.creditsPosition = 矢量(137.540, 63.920, -158.900);
		"灯塔"
		Else If(数量(范围内玩家(矢量(322.692, -21.520, 42.832), 30, 队伍1, 关闭)) != 0);
			全局.bastionPosition[0] = 矢量(321.799, -17.290, 26.126);
			全局.bastionPosition[1] = 矢量(314.215, -16.350, -18.283);
			全局.bastionPosition[2] = 矢量(358.768, -6.597, -47.480);
			全局.bastionPosition[3] = 矢量(353.915, -10.860, -53.746);
			全局.bastionPosition[4] = 矢量(364.601, -25.620, -54.434);
			全局.bastionPosition[5] = 矢量(304.692, -15.910, -42.049);
			全局.bastionPosition[6] = 矢量(319.744, -24.110, -69.502);
			"Town goal position"
			全局.endPosition = 矢量(321.229, -23.291, -88.556) - 矢量(0, 3, 0);
			全局.thirdPersonPosition = 矢量(318.997, -21.520, 37.660);
			全局.resetPosition = 矢量(331.080, -21.520, 41.121);
			"Base coordinates for world game settings HUD"
			全局.creditsPosition = 矢量(321.800, -20, 46);
		End;
		全局.mapTitleRelation = 数组(
			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰

			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰

			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰
			
			// 别打老顾我啊 (索引16)
			数组(16, 9),   // 征服者

			// 雨鸢 (索引19)
			数组(24, 9),  // 征服者

			// 雨鸢 (索引19)
			数组(24, 9),  // 征服者

			// 蝎子莱莱 (索引23)
			数组(23, 9),  // 征服者
			数组(23, 10) // 主宰
		);
	}
}

规则("map - 漓江塔")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(漓江塔) || 全局.__currentMap__ == 3676) == 真;
	}

	动作
	{
		"0 = X轴 1 = Y轴 2 = Z轴"
		全局.controlRespawnAxis = 1;
		"距离阈值"
		全局.controlRespawnAxisThreshold = 40;
		全局.rebootTime = 15900; // 4 小时 
		开始强制重生室(队伍1, 2);
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		// 禁用 If(数量(范围内玩家(矢量(-80.495, -150.140, 158.682), 1000, 队伍1, 关闭)) != 0);
		"夜市"
		全局.bastionPosition = 矢量(34.550, 33.850, -36.640); // 1
		修改全局变量(bastionPosition, 添加至数组, 矢量(21.250, 10, -23.950)); // 2
		修改全局变量(bastionPosition, 添加至数组, 矢量(0.93,0.00, -9.84)); // 3
		修改全局变量(bastionPosition, 添加至数组, 矢量(3.650, 8.010, -52.480)); // 4
		修改全局变量(bastionPosition, 添加至数组, 矢量(-30.810, 25.990, -14.770)); // 5

		"夜市重生点"
		全局.controlRespawnPosition = 矢量(84.410, 4.520, -31.57);

		"夜市-庭院 传送点"
		全局.controlJumpPosition = 矢量(-58.26, 6.00, -5.24);
		全局.resetPosition = 矢量(81.11, 4.580, -35.44);
		全局.thirdPersonPosition = 矢量(74.43, 4.46, -26.34);
		全局.creditsPosition = 矢量(84.29, 6.200, -29.44);

		// 禁用 Else If(数量(范围内玩家(矢量(179.470, -8.427, -236.910), 1000, 队伍1, 关闭)) != 0);
		"庭院"
		修改全局变量(bastionPosition, 添加至数组, 矢量(41.480, 95.870, 140.620)); // 6
		修改全局变量(bastionPosition, 添加至数组, 矢量(-0.080, 94, 184.970)); // 7
		修改全局变量(bastionPosition, 添加至数组, 矢量(-16.66,96.50,120.91)); // 8
		修改全局变量(bastionPosition, 添加至数组, 矢量(-66.07,94,150.20)); // 9
		"庭院重生点"
		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(86.21, 96.620, 147.70)); // 10
		"庭院-控制中心 传送点"
		修改全局变量(controlJumpPosition, 添加至数组, 矢量(-51.89, 95.00, 133.97));
		// 禁用 Else If(数量(范围内玩家(矢量(377.011, 47.028, 170.005), 1000, 队伍1, 关闭)) != 0);
		"控制中心"
		修改全局变量(bastionPosition, 添加至数组, 矢量(46.340, 267, 300.860)); // 
		修改全局变量(bastionPosition, 添加至数组, 矢量(-10.14, 270.12, 321.40)); // 11
		修改全局变量(bastionPosition, 添加至数组, 矢量(-0.200, 278.010, 290.980)); // 13
		修改全局变量(bastionPosition, 添加至数组, 矢量(2.790, 274.190, 301.820)); // 14
		修改全局变量(bastionPosition, 添加至数组, 矢量(-46.630, 267.110, 300.970)); // 15
		"控制中心重生点"
		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(62.930, 267.64, 349.53));
		// 全局.thirdPersonPosition = 矢量(365.657, 45.730, 174.464);
		// 全局.resetPosition = 矢量(365.378, 47.028, 173.797);
		// 全局.creditsPosition = 矢量(365.644, 47.028, 170.432);
		全局.endPosition = 矢量(-44.02, 271.64, 349.77);
		// 全局.thirdPersonPosition = 矢量(193.439, -8.990, -233.575);
		// 全局.resetPosition = 矢量(190.325, -9.110, -231.926);
		// 全局.creditsPosition = 矢量(321.800, -20, 46);
		// 禁用 End;
		全局.mapTitleRelation = 数组(
			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者

			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰
			
			// 草艮 (索引2)
			数组(2, 9),   // 征服者
			数组(2, 10),  // 主宰
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			
			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰
			
			// 烛台与南九 (索引3)
			数组(3, 9),   // 征服者
			数组(3, 10),  // 主宰
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			
			// 看啊情 (索引17)
			数组(17, 9),  // 征服者
			数组(17, 10)  // 主宰
		);
	}
}

规则("map - 萨摩亚")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(萨摩亚) || 全局.__currentMap__ == 13628) == 真;
	}

	动作
	{
		"0 = X轴 1 = Y轴 2 = Z轴"
		全局.controlRespawnAxis = 0; // 重生点轴向 0 = X轴 1 = Y轴 2 = Z轴
		"距离阈值"
		全局.controlRespawnAxisThreshold = 40;
		"覆盖全局自动重开时间"
		全局.rebootTime = 15900;
		开始强制重生室(队伍1, 2);
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		"海滩海滩重生点"
		全局.controlRespawnPosition = 矢量(-428, 10.500, -109);
		"海滩-城区 传送点"
		全局.controlJumpPosition = 矢量(-256.820, 14.850, -94.900);
		全局.resetPosition = 矢量(-430.710, 10.300, -105.960);
		全局.thirdPersonPosition = 矢量(-425.320, 10.230, -116.480);
		全局.creditsPosition = 矢量(-436.160, 12.200, -111.370);
		"城区城区重生点"
		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(330.120, 14.640, -216.310));
		"城区-控制中心 传送点"
		修改全局变量(controlJumpPosition, 添加至数组, 矢量(177.520, 12.300, -239.300));
		"火山火山重生点"
		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(107.830, 343, 415.600));
		全局.endPosition = 矢量(-29.300, 340.560, 410.760);
		"堡垒点位  沙滩"
		全局.bastionPosition = 矢量(-408.950, 14.400, -84.760);
		修改全局变量(bastionPosition, 添加至数组, 矢量(-384.050, 12.050, -86.880));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-330.080, 10.010, -98.040));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-276.430, 11.020, -89.160));
		"堡垒点位 城区"
		修改全局变量(bastionPosition, 添加至数组, 矢量(307.130, 18.610, -206.170));
		修改全局变量(bastionPosition, 添加至数组, 矢量(231.600, 16.280, -270.760));
		修改全局变量(bastionPosition, 添加至数组, 矢量(233.690, 9, -229.700));
		修改全局变量(bastionPosition, 添加至数组, 矢量(170.960, 12.560, -242.330));
		"堡垒点位 火山"
		修改全局变量(bastionPosition, 添加至数组, 矢量(97.680, 340.630, 397.230));
		修改全局变量(bastionPosition, 添加至数组, 矢量(46.640, 345.490, 387.040));
		修改全局变量(bastionPosition, 添加至数组, 矢量(26.690, 341.630, 376.430));
		修改全局变量(bastionPosition, 添加至数组, 矢量(27.740, 360.500, 356.070));
		修改全局变量(bastionPosition, 添加至数组, 矢量(0.960, 346.650, 390.110));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-4.400, 353.050, 407.420));
		全局.mapTitleRelation = 数组(

			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰
			
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10), // 主宰
			
			// 草艮 (索引2)
			数组(2, 9),   // 征服者
			数组(2, 10),  // 主宰
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			
			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9)  // 征服者
		);
	}
}

规则("map - 南极半岛")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(南极半岛);
	}

	动作
	{
		"0 = X轴 1 = Y轴 2 = Z轴"
		全局.controlRespawnAxis = 1;
		"距离阈值"
		全局.controlRespawnAxisThreshold = 40;
		"覆盖全局自动重开时间"
		全局.rebootTime = 15900;
		开始强制重生室(队伍1, 2);
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		"冰下层重生点"
		全局.controlRespawnPosition = 矢量(-76.020, -151.440, 153.130);
		"冰下层-破冰船 传送点"
		全局.controlJumpPosition = 矢量(-59.560, -151.500, -17.690);
		全局.resetPosition = 矢量(-75.850, -151.440, 147.300);
		全局.thirdPersonPosition = 矢量(-79.930, -151.440, 147.280);
		全局.creditsPosition = 矢量(-78.770, -148.440, 160.860);
		"破冰船重生点"
		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(182.660, -9.700, -234.070));
		"破冰船-研究中心  传送点"
		修改全局变量(controlJumpPosition, 添加至数组, 矢量(343.060, -9.100, -209.650));
		"研究中心重生点"
		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(369.700, 45.730, 169.340));
		全局.endPosition = 矢量(205.410, 48.090, 165.140);
		"堡垒点位  冰下层"
		全局.bastionPosition = 矢量(-72.040, -151.410, 119.550);
		修改全局变量(bastionPosition, 添加至数组, 矢量(-92.090, -151.170, 80.660));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-58.390, -147.630, 42.630));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-88.010, -143.330, -19.630));
		"堡垒点位 破冰船"
		修改全局变量(bastionPosition, 添加至数组, 矢量(231.060, -7.680, -232.480));
		修改全局变量(bastionPosition, 添加至数组, 矢量(281.410, -10.010, -196.390));
		修改全局变量(bastionPosition, 添加至数组, 矢量(282.200, -8.310, -247.910));
		修改全局变量(bastionPosition, 添加至数组, 矢量(314.780, -14, -262.470));
		修改全局变量(bastionPosition, 添加至数组, 矢量(320.920, -8.930, -216.010));
		修改全局变量(bastionPosition, 添加至数组, 矢量(330.850, -10.940, -249.670));
		"堡垒点位  研究中心"
		修改全局变量(bastionPosition, 添加至数组, 矢量(326.200, 51.510, 165.800));
		修改全局变量(bastionPosition, 添加至数组, 矢量(269.850, 44.150, 156.600));
		修改全局变量(bastionPosition, 添加至数组, 矢量(209.610, 52.190, 181.940));
		修改全局变量(bastionPosition, 添加至数组, 矢量(269.900, 47.010, 187.600));
		全局.controlCenterPosition = 数组(矢量(-77.850, -154.430, 59.980), 矢量(283.400, -12.750, -223.320), 矢量(270.290, 39.780, 160.080));
		全局.mapTitleRelation = 数组(
			// WildRage (索引5)
			数组(5, 9),   // 征服者
			数组(5, 10),  // 主宰

			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰
			数组(7, 0),   // 开拓者

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰

			// 豆本豆豆奶 (索引10)
			数组(10, 9),   // 征服者
			数组(10, 10),  // 主宰
			
			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10),  // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者

			// 卖核弹的小女孩 (索引13)
			数组(13, 9),  // 征服者

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10) // 主宰
		);
	}
}

规则("map - 釜山")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(釜山);
	}

	动作
	{
		"0 = X轴 1 = Y轴 2 = Z轴"
		全局.controlRespawnAxis = 0;
		"距离阈值"
		全局.controlRespawnAxisThreshold = 40;
		"覆盖全局自动重开时间"
		全局.rebootTime = 15900;
		开始强制重生室(队伍1, 2);
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		"寺庙重生点"
		全局.controlRespawnPosition = 矢量(-426.040, 11.110, 165.810);
		"寺庙-城区 传送点"
		全局.controlJumpPosition = 矢量(-248.550, 10.350, 152.770);
		全局.resetPosition = 矢量(-409.710, 10.110, 165.610);
		全局.thirdPersonPosition = 矢量(-410.400, 10.110, 162.370);
		全局.creditsPosition = 矢量(-426.040, 13.110, 165.810);
		"城区城区重生点"
		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(-30.950, 17, -125.550));
		"城区-meka基地 传送点"
		修改全局变量(controlJumpPosition, 添加至数组, 矢量(104.770, 17.740, -137.210));
		"meka基地重生点"
		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(291.620, 11.090, 208.250));
		全局.endPosition = 矢量(158.670, 10.810, 260.910);
		"堡垒点位  寺院"
		全局.bastionPosition = 矢量(-327.440, 17.730, 166.800);
		修改全局变量(bastionPosition, 添加至数组, 矢量(-328.510, 15.080, 140.810));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-277.400, 11.130, 144.400));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-379.430, 11.130, 144.410));
		"堡垒点位 城区"
		修改全局变量(bastionPosition, 添加至数组, 矢量(22.020, 13.860, -121.160));
		修改全局变量(bastionPosition, 添加至数组, 矢量(51.840, 13.480, -97.400));
		修改全局变量(bastionPosition, 添加至数组, 矢量(80.670, 20, -106.930));
		修改全局变量(bastionPosition, 添加至数组, 矢量(111.430, 18.540, -169.790));
		"堡垒点位  meka基地"
		修改全局变量(bastionPosition, 添加至数组, 矢量(268.370, 15.090, 205.620));
		修改全局变量(bastionPosition, 添加至数组, 矢量(249.270, 14.290, 236.100));
		修改全局变量(bastionPosition, 添加至数组, 矢量(228.220, 10.090, 231.080));
		修改全局变量(bastionPosition, 添加至数组, 矢量(200.310, 19.430, 223.760));
		修改全局变量(bastionPosition, 添加至数组, 矢量(177.100, 9.690, 253.190));
		修改全局变量(bastionPosition, 添加至数组, 矢量(173.930, 12.870, 267.780));
		全局.controlCenterPosition = 数组(矢量(-328.530, 8.170, 153.320), 矢量(51.890, 14.500, -114.700), 矢量(222.720, 9.240, 241.770));
		全局.mapTitleRelation = 数组(
			// 草艮 (索引2)
			数组(2, 0),   // 开拓者
			数组(2, 9),   // 征服者
			
			// 顾北酒笙 (索引4)
			数组(4, 0),   // 开拓者
			数组(4, 9),   // 征服者
			
			// WildRage (索引5)
			数组(5, 0),   // 开拓者
			数组(5, 9),   // 征服者
			
			// 尘风歌者 (索引6)
			数组(6, 0),   // 开拓者
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰
			
			// 吾携秋水揽星河 (索引7)
			数组(7, 0),   // 开拓者
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			
			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰
			
			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰
			
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10),  // 主宰

			// 卖核弹的小女孩 (索引13)
			数组(13, 9)  // 征服者
		);
	}
}

规则("map - 绿洲城")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(绿洲城);
	}

	动作
	{
		"0 = X轴 1 = Y轴 2 = Z轴"
		全局.controlRespawnAxis = 2;
		"距离阈值"
		全局.controlRespawnAxisThreshold = 40;
		"覆盖全局自动重开时间"
		全局.rebootTime = 15900;
		开始强制重生室(队伍1, 2);
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		"花园重生点"
		全局.controlRespawnPosition = 矢量(200.460, 6.420, -188.280);
		"花园-大学 传送点"
		全局.controlJumpPosition = 矢量(82.130, 5.490, -273.200);
		全局.resetPosition = 矢量(193.610, 8.420, -197.030);
		全局.thirdPersonPosition = 矢量(191.330, 8.420, -194.730);
		全局.creditsPosition = 矢量(204.410, 8.420, -184.710);
		"大学重生点"
		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(-195.030, 20, 89.710));
		"大学-中心  传送点"
		修改全局变量(controlJumpPosition, 添加至数组, 矢量(-175.400, 16, -61.350));
		"中心重生点"
		修改全局变量(controlRespawnPosition, 添加至数组, 矢量(69.730, 1, 321.160));
		全局.endPosition = 矢量(195.130, 0.850, 172.870);
		"堡垒点位  花园"
		全局.bastionPosition = 矢量(170.700, 13.570, -216.170);
		修改全局变量(bastionPosition, 添加至数组, 矢量(123.600, 12, -229.920));
		修改全局变量(bastionPosition, 添加至数组, 矢量(78.920, 10, -253.170));
		修改全局变量(bastionPosition, 添加至数组, 矢量(111.340, 13.570, -278.410));
		"堡垒点位 大学"
		修改全局变量(bastionPosition, 添加至数组, 矢量(-196.790, 21.650, 56.690));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-202.910, 9.120, -0.100));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-177.500, 20.250, 0.190));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-183.170, 20.060, -61.790));
		"堡垒点位  中心"
		修改全局变量(bastionPosition, 添加至数组, 矢量(110.540, 2, 283.010));
		修改全局变量(bastionPosition, 添加至数组, 矢量(140.160, 10, 250.390));
		修改全局变量(bastionPosition, 添加至数组, 矢量(171.910, 4.120, 277));
		修改全局变量(bastionPosition, 添加至数组, 矢量(150.980, 3.850, 223.890));
		修改全局变量(bastionPosition, 添加至数组, 矢量(173.510, 2, 217.630));
		全局.controlCenterPosition = 数组(矢量(129.500, 15.280, -235.740), 矢量(-192.080, 15, 0.260), 矢量(143.440, 2.150, 247.950));
		全局.mapTitleRelation = 数组(
			// WildRage (索引5)
			数组(5, 9),   // 征服者
			数组(5, 10),  // 主宰

			// 尘风歌者 (索引6)
			数组(6, 9),   // 征服者
			数组(6, 10),  // 主宰
			数组(6, 0),   // 开拓者

			// 吾携秋水揽星河 (索引7)
			数组(7, 9),   // 征服者
			数组(7, 10),  // 主宰

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰

			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰
			
			// 豆本豆豆奶 (索引10)
			数组(10, 9),  // 征服者
			数组(10, 10),  // 主宰
			数组(10, 0),  // 开拓者

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰

			// 初一吖 (索引19)
			数组(19, 9),  // 征服者
			数组(19, 10), // 主宰

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10) // 主宰
		);
	}
}

规则("map - 新渣客城")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(新渣客城) || 全局.__currentMap__ == 3099) == 真;
	}

	动作
	{
		全局.portalPosition = 数组(矢量(-91.45, 2, -5.21), 矢量(-118.06,30.58,-2.12));
		"0 = X轴 1 = Y轴 2 = Z轴"
		全局.controlRespawnAxis = 2;
		"距离阈值"
		全局.controlRespawnAxisThreshold = 30;
		开始强制重生室(队伍1, 1);
		全局.controlRespawnPosition = 矢量(-0.7, 8.02, 113.02);
		"大学重生点"
		修改全局变量(controlRespawnPosition, 添加至数组, 最后(全局.portalPosition));
		全局.resetPosition = 矢量(5.33,8.14,109.05);
		全局.heroRingPosition = 矢量(2.08,8.02,109.16);
		全局.creditsPosition = 矢量(0.68, 11.77, 120.02);
		全局.endPosition = 矢量(-43, 28.65, -39.96);
		全局.controlJumpPosition = 首个(全局.portalPosition);
		
		全局.bastionPosition = 数组(矢量(-45.678, 8.298, 88.433), 矢量(-74.958, 6.937, 72.937), 矢量(-76.296, 7.756, 40.010), 矢量(-74.877, 6.937,
		7.044), 矢量(-78.144, -0.941, -19.954), 矢量(-55.165, 8.251, -0.152), 矢量(-25.305, 9.706, 32.074), 矢量(13.116, 4.058, 87.188), 矢量(
		-15.766, 7.025, 0.028), 矢量(-31.324, 8.111, -39.913), 矢量(-85.606, 0.947, 44.387), 矢量(-74.415, 4.499, -63.359));

		全局.mapTitleRelation = 数组(
			// 吾携秋水揽星河 - 征服者和主宰
			数组(7, 9),
			数组(7, 10),
			数组(7, 0),  // 开拓者

			// 寒霜冰湮 (索引8)
			数组(8, 9),   // 征服者
			数组(8, 10),  // 主宰
			数组(8, 0),  // 开拓者

			// Cold (索引9)
			数组(9, 9),   // 征服者
			数组(9, 10),  // 主宰

			// 溪云初起日沉阁 (索引12)
			数组(12, 9),  // 征服者
			数组(12, 10), // 主宰
			数组(12, 0),   // 开拓者

			// 眼镜小宅 (索引18)
			数组(18, 9),  // 征服者
			数组(18, 10), // 主宰
			数组(18, 0)   // 开拓者
		);
	}
}

规则("bastion init position, unkillable status, and damage dealt scaling with difficulty setting")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		存活(事件玩家) == 真;
		已重生(事件玩家) == 真;
	}

	动作
	{
		等待(0.250, 无视条件);
		设置造成伤害(事件玩家, 100 + 50 * 全局.difficulty);
		传送(事件玩家, 全局.bastionPosition[栏位(事件玩家)]);
		If(!具有状态(事件玩家, 无法杀死));
			设置状态(事件玩家, 空, 无法杀死, 99999);
			设置受到的击退(事件玩家, 1);
	}
}

规则("set hero list")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"make default hero list, which includes all 36 heroes available in Season 2"
		全局.heroList = 数组(英雄(黑影), 英雄(死神), 英雄(莫伊拉), 英雄(雾子), 英雄(西格玛), 英雄(源氏), 英雄(奥丽莎), 英雄(秩序之光), 英雄(温斯顿), 英雄(D.Va), 英雄(猎空), 英雄(黑百合), 英雄(索杰恩),
			英雄(巴蒂斯特), 英雄(美), 英雄(回声), 英雄(布丽吉塔), 英雄(士兵：76), 英雄(破坏球), 英雄(卡西迪), 英雄(查莉娅), 英雄(卢西奥), 英雄(法老之鹰), 英雄(天使), 英雄(莱因哈特), 英雄(半藏),
			英雄(末日铁拳), 英雄(路霸), 英雄(渣客女王), 英雄(艾什), 英雄(托比昂), 英雄(安娜), 英雄(禅雅塔), 英雄(狂鼠), 英雄(堡垒));
		"remove all heroes that are not for some reason in Overwatch's list of all the heroes (at the time of making this, Mei is an example because she was removed to be patched)"
		修改全局变量(heroList, 根据值从数组中移除, 已过滤的数组(全局.heroList, !数组包含(全部英雄, 当前数组元素)));
		"add any heroes that for some reason are on Overwatch's list but not the game's (eg if I don't update the mode after a hero release). they are added as the second hero in the list"
		If(对任意为“真”(全部英雄, !数组包含(全局.heroList, 当前数组元素)));
			全局.missingHeroes = 已过滤的数组(全部英雄, !数组包含(全局.heroList, 当前数组元素));
			For 全局变量(I, 0, 数量(全局.missingHeroes), 1);
				全局.heroList = 已排序的数组(添加至数组(全局.heroList, 全局.missingHeroes[全局.I]), 当前数组元素 != 全局.missingHeroes[全局.I] ? 当前数组索引 : 0.500);
				等待(0.016, 无视条件);
			End;
		End;
		"move Bastion to the end of the hero list, and keep the rest of the list how it is"
		全局.heroList = 已排序的数组(全局.heroList, 当前数组索引 + 数量(全局.heroList) * (当前数组元素 == 英雄(堡垒)));
		// "remove Wuyang"
	}
}

规则("infinite match time")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		正在设置 == 假;
	}

	动作
	{
		禁用查看器录制;
		关闭游戏预设完成条件;
		关闭游戏预设通告模式;
		关闭游戏预设音乐模式;
		关闭游戏预设计分模式;
		等待(1, 无视条件);
		比赛时间暂停;
		设置慢动作(90);
	}
}

规则("if someone starts the game mode, restart the match")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前游戏模式 != 游戏模式(突击模式);
		(正在设置 || 正在集结英雄 || 游戏正在进行中) == 真;
	}

	动作
	{
		关闭游戏预设通告模式;
		等待(0.016, 无视条件);
		移除所有机器人;
		消除所有效果;
		消除所有HUD文本;
		消除所有图标;
		消除所有地图文本;
		消除所有进度条HUD文本;
		等待(0.016, 无视条件);
		隐藏信息(所有玩家(队伍1));
		隐藏游戏模式HUD(所有玩家(队伍1));
		隐藏游戏模式地图UI(所有玩家(队伍1));
		关闭游戏预设复生模式(所有玩家(队伍1));
		比赛时间继续;
		While(!游戏正在进行中);
			设置比赛时间(0);
			等待(0.016, 无视条件);
		End;
		创建图标(所有玩家(队伍1), 矢量(0, 101, -0.250), 警告, 颜色, 自定义颜色(220 + 弧度的正弦值(总计消耗时间 * 3.141) * 35, 0, 0, 255), 假);
		创建地图文本(所有玩家(队伍1), 自定义字符串("主机开始了游戏模式.\n这将导致智械危机.\n\n                      正在重开..."), 矢量(0,
			101, 0), 3, 不要截取, 颜色, 自定义颜色(220 + 弧度的正弦值(总计消耗时间 * 3.141) * 35, 0, 0, 255), 始终可见);
		For 全局变量(I, 0, 5, 1);
			创建效果(所有玩家(队伍1), 球, 颜色(黑色), 矢量(0, 100 + 0.500 * (全局.I + 1) / 5, 0), 2 + 2 * (全局.I + 5), 无);
			创建效果(所有玩家(队伍1), 球体, 颜色(黑色), 矢量(0, 100, 0), 2 + 2 * (全局.I + 5), 无);
			创建效果(所有玩家(队伍1), 有害光环, 颜色(黑色), 矢量(0, 100 + 3 * (全局.I + 1) / 5, 0), 2 + 2 * (全局.I + 5), 无);
			等待(0.016, 无视条件);
		End;
		开始强制玩家选择英雄(所有玩家(队伍1), 英雄(黑影));
		等待(0.016, 无视条件);
		击杀(所有玩家(队伍1), 主机玩家);
		隐藏英雄HUD(所有玩家(队伍1));
		开始镜头(所有玩家(队伍1), 矢量(0, 100, 0), 矢量(0, 101, 0.010), 0);
		等待(5, 无视条件);
		开启游戏预设音乐模式;
		宣告队伍胜利(队伍2);
		消除所有地图文本;
		消除所有图标;
		等待(2, 无视条件);
		等待直到 (总计消耗时间 > 30, 30);
		重新开始比赛;
	}
}

规则("create bastion bots")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		玩家数量(队伍2) < 数量(全局.bastionPosition);
	}

	动作
	{
		移除所有机器人;
		While(玩家数量(队伍2) < 数量(全局.bastionPosition));
			生成机器人(英雄(堡垒), 队伍2, -1, 数组随机取值(重生点(队伍2)), 矢量(0, 0, 0));
			等待(0.250, 无视条件);
		End;
		If(全局.kills == 0);
			全局.kills = 数组(0, 0, 0, 0, 0, 0);
		End;
		等待(2, 无视条件);
		如条件为“真”则循环;
	}
}

规则("bastions are numbered and list their kills (by changing their names when they spawn)")
{
	事件
	{
		玩家加入比赛;
		队伍2;
		全部;
	}

	动作
	{
		开始为机器人强制设置名称(事件玩家, 自定义字符串("看守{0} {1}", 栏位(事件玩家) + 1, 全局.kills[栏位(事件玩家)]));
	}
}

规则("damage modifier: players can't hurt bastions")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.difficulty != 5;
		单次赋值(全局.dmgReduction) == 假;
	}

	动作
	{
		开始伤害调整(所有玩家(队伍2), 已过滤的数组(所有玩家(队伍1), !数组包含(全局.devList, 自定义字符串("{0}", 当前数组元素))), 0.100, 受伤害者和伤害者);
		// 开始伤害调整(所有玩家(队伍2), 所有玩家(队伍1), 0.001, 受伤害者和伤害者);
	}
}

规则("anti crash")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.antiCrashActivated == 假;
		服务器负载 > 235;
	}

	动作
	{
		等待(1, 当为“假”时中止);
		小字体信息(所有玩家(所有队伍), 自定义字符串("  防炸房系统工作中..."));
		设置慢动作(20);
		全局.antiCrashActivated = 真;
	}
}

规则("disable anti crash")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.antiCrashActivated != 假;
		服务器负载 < 200;
	}

	动作
	{
		设置慢动作(90);
		全局.antiCrashActivated = 假;
	}
}

规则("disable gamemode hud and player collision for all players")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		隐藏游戏模式HUD(事件玩家);
		隐藏游戏模式地图UI(事件玩家);
		取消与玩家的移动碰撞(事件玩家);
	}
}

规则("enemy bastions must stay in configuration: assault (AKA machine gun/sentry/alternate form)")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		处于非初始状态(事件玩家) == 假;
		总计消耗时间 > 10;
	}

	动作
	{
		"this cancels bastion's \"standing up\" animation so he can sit back down faster"
		取消主要动作(事件玩家);
		设置技能冷却(事件玩家, 按钮(技能1), 0);
		按下按键(事件玩家, 按钮(技能1));
		等待(0.032, 无视条件);
		如条件为“真”则循环;
	}
}

规则("bastions periodically refresh their configuration when there are enemies nearby but out of sight")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		总计消耗时间 > 10;
		事件玩家.target == 假;
		首个(范围内玩家(所选位置(事件玩家), 110, 队伍1, 关闭)) != 假;
	}

	动作
	{
		等待(随机实数(0.200, 1), 当为“假”时中止);
		按下按键(事件玩家, 按钮(技能1));
		等待(随机实数(1, 3), 无视条件);
		如条件为“真”则循环;
	}
}

规则("bastion constantly searches for targets in line of sight")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		首个(范围内玩家(眼睛位置(事件玩家), 105, 队伍1, 表面)) != 假;
	}

	动作
	{
		事件玩家.temp = 已过滤的数组(所有存活玩家(队伍1), 在视线内(眼睛位置(事件玩家), 眼睛位置(当前数组元素), 屏障不会阻挡视线) || 在视线内(眼睛位置(事件玩家), 所选位置(当前数组元素), 屏障不会阻挡视线));
		等待(0.016, 无视条件);
		If(!事件玩家.temp);
			事件玩家.target = 空;
			跳过(8);
		End;
		禁用 修改玩家变量(事件玩家, temp, 根据值从数组中移除, 已过滤的数组(事件玩家.temp, !已重生(当前数组元素) || 当前数组元素.isWinner || 具有状态(当前数组元素, 相移) || (所用英雄(当前数组元素) == 英雄(黑影)
			&& 正在使用技能 1(当前数组元素))));
		修改玩家变量(事件玩家, temp, 根据值从数组中移除, 已过滤的数组(事件玩家.temp, !已重生(当前数组元素) || 当前数组元素.isWinner || 具有状态(当前数组元素, 相移) || 当前数组元素.targetSilence || 相距距离(事件玩家, 当前数组元素) >= 100));
		等待(0.016, 无视条件);
		If(数量(事件玩家.temp) > 1);
			事件玩家.temp = 已排序的数组(事件玩家.temp, 全局.bastionBotTargetPrefer == 0 ? 生命值(当前数组元素) * 相距距离(事件玩家, 当前数组元素) : (
				全局.bastionBotTargetPrefer == 1 ? 相距距离(事件玩家, 当前数组元素) : 生命值(当前数组元素)));
			等待(0.016, 无视条件);
		End;
		IF(!单次赋值(全局.dlcVishkarEvent));
			事件玩家.target = 首个(事件玩家.temp);
		ELSE;
			事件玩家.target = 首个(已排序的数组(事件玩家.temp, 当前数组元素.targetWeight * -1));
		END;
		等待(随机实数(0.256, 0.512), 无视条件);
		如条件为“真”则循环;
		事件玩家.target = 空;
	}
}

规则("bastion fires if he has a target")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		存活(事件玩家) == 真;
		正在使用主要武器(事件玩家) == 假;
		事件玩家.target != 假;
	}

	动作
	{
		开始按下按钮(事件玩家, 按钮(主要攻击模式));
		等待(0.500, 无视条件);
		如条件为“真”则循环;
	}
}

规则("bastion stops firing when there aren't targets")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		事件玩家.target == 假;
		存活(事件玩家) == 真;
	}

	动作
	{
		停止按下按钮(事件玩家, 按钮(主要攻击模式));
		等待(1, 当为“假”时中止);
		根据条件循环(正在使用主要武器(事件玩家));
	}
}

规则("bastion secondary fires if he has a target")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		// (全局.difficulty == 5 || 全局.bastionBotSeconFire) == 真;
		对任意为“真”(数组(全局.difficulty == 5, 全局.bastionBotSeconFire), 当前数组元素) == 真;
		单次赋值(是否是机器人(事件玩家)) != 假;
		存活(事件玩家) == 真;
		正在使用主要武器(事件玩家) == 真;
		技能冷却时间(事件玩家, 按钮(辅助攻击模式)) == 0;
		事件玩家.target != 假;
	}

	动作
	{
		等待(随机实数(0.032, 0.160), 当为“假”时中止);
		按下按键(事件玩家, 按钮(辅助攻击模式));
		事件玩家.target.A36TGrenade += 1;
		等待(1.488, 无视条件);
		如条件为“真”则循环;
	}
}

规则("bastion aims at whichever part of his target is most exposed")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		存活(事件玩家) == 真;
		事件玩家.target != 空;
	}

	动作
	{
		事件玩家.tempAimPosition = (所选位置(事件玩家.target) + 眼睛位置(事件玩家.target)) / 2;
		If(在视线内(眼睛位置(事件玩家), 事件玩家.tempAimPosition, 屏障不会阻挡视线));
			事件玩家.aimPosition = 事件玩家.tempAimPosition;
		Else If(在视线内(眼睛位置(事件玩家), 眼睛位置(事件玩家.target), 屏障不会阻挡视线));
			事件玩家.aimPosition = 眼睛位置(事件玩家.target);
		Else;
			事件玩家.aimPosition = 所选位置(事件玩家.target);
		End;
		等待(0.064, 无视条件);
		如条件为“真”则循环;
	}
}

规则("bastion places his crosshair near the closest potential target if he doesn't currently have one")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		存活(事件玩家) == 真;
		事件玩家.target == 假;
	}

	动作
	{
		等待(服务器负载 / 100, 当为“假”时中止);
		禁用 事件玩家.nearestTargetOutOfLoS = 首个(已排序的数组(已过滤的数组(所有存活玩家(队伍1), 已重生(当前数组元素) && !事件玩家.isWinner && !(所用英雄(当前数组元素) == 英雄(黑影) && 正在使用技能 1(
			当前数组元素))), 相距距离(眼睛位置(事件玩家), 眼睛位置(当前数组元素))));
		事件玩家.nearestTargetOutOfLoS = 首个(已排序的数组(已过滤的数组(所有存活玩家(队伍1), 已重生(当前数组元素) && !事件玩家.isWinner), 相距距离(眼睛位置(事件玩家), 眼睛位置(当前数组元素))));
		根据条件跳过(事件玩家.nearestTargetOutOfLoS == 空, 1);
		事件玩家.aimPosition = 眼睛位置(事件玩家.nearestTargetOutOfLoS) + 矢量(随机实数(-1, 1), 随机实数(-1, 1), 随机实数(-1, 1));
		等待(随机实数(1, 4), 无视条件);
		如条件为“真”则循环;
	}
}

规则("determine bastion's aim speed, to improve smooth tracking")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		存活(事件玩家) == 真;
		事件玩家.target != 假;
	}

	动作
	{
		事件玩家.turnSpeed = 矢量间夹角(面朝方向(事件玩家), 方向(眼睛位置(事件玩家), 眼睛位置(事件玩家.target))) * 全局.turnSpeedMultiplier;
		事件玩家.turnSpeed += 速度(事件玩家.target) * 全局.turnSpeedMultiplier;
		等待(服务器负载平均值 / 1000, 无视条件);
		如条件为“真”则循环;
	}
}

规则("increase bastion's aim speed to prep for flicking to a target entering range")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		存活(事件玩家) == 真;
		事件玩家.target == 假;
		矢量间夹角(面朝方向(事件玩家), 方向(眼睛位置(事件玩家), 所选位置(事件玩家.aimPosition))) >= 1;
	}

	动作
	{
		事件玩家.turnSpeed = 矢量间夹角(面朝方向(事件玩家), 方向(眼睛位置(事件玩家), 所选位置(事件玩家.aimPosition)) * 全局.turnSpeedMultiplier);
		等待(服务器负载峰值 / 1000, 无视条件);
		如条件为“真”则循环;
	}
}

规则("start facing bastion bots")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		存活(事件玩家) == 真;
		已重生(事件玩家) == 真;
		总计消耗时间 > 10;
	}

	动作
	{
		开始朝向(事件玩家, 方向(眼睛位置(事件玩家), 事件玩家.aimPosition), 具有状态(事件玩家, 沉睡) ? 0 : 事件玩家.turnSpeed, 至地图, 方向及角速率);
	}
}

规则("set bastion's target to null once he kills them")
{
	事件
	{
		玩家造成最后一击;
		队伍2;
		全部;
	}

	动作
	{
		事件玩家.target = 空;
		事件玩家.nearestTargetOutOfLoS = 空;
		根据条件跳过(全局.difficulty != 5, 3);
		IF(事件技能 == 按钮(辅助攻击模式) && 全局.A36TGrenadeFB == 空);
			全局.A36TGrenadeFB = 被攻击方;
		END;
	}
}

规则("bastion punches the ground a few times at first to destroy railings")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		总计消耗时间 < 10;
		总计消耗时间 > 5;
	}

	动作
	{
		设置朝向(事件玩家, 下, 至地图);
		For 玩家变量(事件玩家, I, 0, 3, 1);
			按下按键(事件玩家, 按钮(近身攻击));
			等待(1.200, 无视条件);
		End;
	}
}

规则("bastion fully heals periodically")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		存活(事件玩家) == 真;
		标准化生命值(事件玩家) < 1;
	}

	动作
	{
		等待(60, 无视条件);
		开始持续治疗(事件玩家, 空, 59.500, 9999);
		如条件为“真”则循环;
	}
}

规则("bastion immediately respawns upon death")
{
	事件
	{
		玩家阵亡;
		队伍2;
		堡垒;
	}

	动作
	{
		等待(0.016, 无视条件);
		复生(事件玩家);
	}
}

规则("teleport bastions back and reset velocity when they are displaced")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		相距距离(所选位置(事件玩家), 全局.bastionPosition[栏位(事件玩家)]) > 2;
	}

	动作
	{
		等待(0.500, 当为“假”时中止);
		事件玩家.isInPosition = 假;
		开启与环境的移动碰撞(事件玩家);
		设置状态(事件玩家, 空, 相移, 7);
		传送(事件玩家, 全局.bastionPosition[栏位(事件玩家)]);
		等待(0.016, 无视条件);
		开始强制设置玩家位置(事件玩家, 全局.bastionPosition[栏位(事件玩家)], 假);
		等待(0.016, 无视条件);
		等待直到 (速度(事件玩家) < 1, 2);
		停止强制设置玩家位置(事件玩家);
		如条件为“真”则循环;
	}
}

规则("bastions stay where they initially land")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		总计消耗时间 > 10;
		事件玩家.isInPosition == 假;
		正在移动(事件玩家) == 假;
	}

	动作
	{
		等待(5, 当为“假”时中止);
		等待直到 (正在使用技能 1(事件玩家), 2);
		等待(0.500, 当为“假”时中止);
		开始强制设置玩家位置(事件玩家, 所选位置(事件玩家), 假);
		取消与环境的移动碰撞(事件玩家, 真);
		事件玩家.isInPosition = 真;
	}
}

规则("bastions whose position is far above the ground instead stay at that position")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		事件玩家.isInPosition == 假;
		已重生(事件玩家) == 真;
		存活(事件玩家) == 真;
		相距距离(射线命中位置(全局.bastionPosition[栏位(事件玩家)] + 上, 全局.bastionPosition[栏位(事件玩家)] + 下 * 5, 空, 空, 假), 全局.bastionPosition[栏位(事件玩家)] + 下 * 5)
			== 0;
	}

	动作
	{
		传送(事件玩家, 全局.bastionPosition[栏位(事件玩家)]);
		等待(0.016, 无视条件);
		开始强制设置玩家位置(事件玩家, 全局.bastionPosition[栏位(事件玩家)], 假);
	}
}

规则("bastion A-36 Tactical Grenade hit player")
{
	事件
	{
		玩家受到击退;
		队伍1;
		全部;
	}

	条件
	{
		全局.difficulty == 5;
		所用英雄(攻击方) == 英雄(堡垒);
		攻击方 != 事件玩家;
		事件技能 == 按钮(辅助攻击模式);
	}

	动作
	{
		被攻击方.A36TGrenadeHit += 1;
		等待(0.032, 无视条件);
	}
}

规则("bastion A-36 Tactical Grenade hit player")
{
	事件
	{
		玩家受到伤害;
		队伍1;
		全部;
	}

	条件
	{
		全局.difficulty == 5;
		所用英雄(攻击方) == 英雄(堡垒);
		攻击方 != 事件玩家;
		事件技能 == 按钮(辅助攻击模式);
	}

	动作
	{
		被攻击方.A36TGrenadeDmg += 事件伤害;
		等待(0.016, 无视条件);
	}
}

规则("push players away from bastions")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.debugInfo != 真;
		首个(范围内玩家(事件玩家, 2, 队伍2, 关闭)) != 假;
	}

	动作
	{
		施加推力(事件玩家, 与此角度的相对方向(与此方向的水平角度(所选位置(事件玩家) - 所选位置(距离最近的玩家(事件玩家, 队伍2))), -20), 15, 至地图, 取消相反运动);
		等待(0.500, 当为“真”时重新开始);
	}
}

规则("players heal after not taking damage for 3 seconds")
{
	事件
	{
		玩家受到伤害;
		队伍1;
		全部;
	}

	条件
	{
		// 单次赋值(全局.dlcVishkarEvent) == 假;
		(事件玩家.eventType == 0 && (事件玩家.eventId == 4 || 事件玩家.eventId == 7)) != 真;
		// 对任意为“真”(数组(事件玩家.eventId == 4), 当前数组元素) != 真;
	}

	动作
	{
		停止持续治疗(事件玩家.healID);
		等待(0.500, 无视条件);
		等待(1.500, 当为“真”时重新开始);
		根据条件中止(死亡(事件玩家) || 标准化生命值(事件玩家) == 1);
		根据条件跳过(事件玩家.A36TGrenadeAlive, 3);
		IF(事件技能 == 按钮(辅助攻击模式) && 生命值(事件玩家) <= 5);
			事件玩家.A36TGrenadeAlive = 真;
		END;
		等待(0.032, 无视条件);
		开始持续治疗(事件玩家, 事件玩家, 9999, 最大生命值(事件玩家) * 0.400);
		事件玩家.healID = 上一个持续治疗效果ID;
		
	}
}

规则("players pick up speed while not targeted for 3 seconds")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 假;
		首个(范围内玩家(事件玩家, 60, 队伍2, 表面)) == 假;
		正在移动(事件玩家) == 真;
	}

	动作
	{
		等待(3, 当为“假”时中止);
		设置移动速度(事件玩家, 160);
		等待直到 (首个(范围内玩家(事件玩家, 60, 队伍2, 表面)) || !正在移动(事件玩家), 9999);
		设置移动速度(事件玩家, 100);
	}
}

规则("player deaths are counted manually rather than relying on in-game statistics")
{
	事件
	{
		玩家阵亡;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.isWinner == 假;
	}

	动作
	{
		等待(0.500 * 服务器负载 / 100, 无视条件);
		事件玩家.runDeathCount += 1;
		If(数组包含(全局.savedIndex, 事件玩家));
			等待(0.032, 无视条件);
			全局.savedDeaths[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.runDeathCount;
	}
}

规则("when a mercy might rez, respawn time is increased")
{
	事件
	{
		玩家阵亡;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.controlRespawnPosition) == 空;
		正在使用英雄(英雄(天使), 队伍1) == 真;
		事件玩家.controlPlayerRespawn == 假;
	}

	动作
	{
		根据条件中止(单次赋值(全局.dlcVishkarEvent) && 事件玩家.eventType == 0 && 事件玩家.eventId == 8);
		If(对任意为“真”(选择英雄的玩家(英雄(天使), 队伍1), 相距距离(所选位置(事件玩家), 所选位置(当前数组元素)) < 40 && 存活(当前数组元素) && 技能冷却时间(当前数组元素, 按钮(技能2)) < 8));
			大字体信息(事件玩家, 自定义字符串("附近有 天使 等待复活..."));
			关闭游戏预设复生模式(事件玩家);
			等待(5, 无视条件);
			开启游戏预设复生模式(事件玩家);
	}
}

规则("when a mercy might rez, respawn time is increased")
{
	事件
	{
		玩家阵亡;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.controlRespawnPosition) != 空;
		正在使用英雄(英雄(天使), 队伍1) == 真;
		事件玩家.controlPlayerRespawn == 假;
	}

	动作
	{
		If(对任意为“真”(选择英雄的玩家(英雄(天使), 队伍1), 相距距离(所选位置(事件玩家), 所选位置(当前数组元素)) < 15 && 存活(当前数组元素) && 技能冷却时间(当前数组元素, 按钮(技能2)) < 8));
			大字体信息(事件玩家, 自定义字符串("附近有 天使 等待复活..."));
			关闭游戏预设复生模式(事件玩家);
			等待(5, 无视条件);
			开启游戏预设复生模式(事件玩家);
	}
}

规则("symmetra auto-breaks tp after going through")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		秩序之光;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		技能冷却时间(事件玩家, 按钮(技能2)) > 0;
	}

	动作
	{
		等待(0.500, 无视条件);
		While(正在使用技能 2(事件玩家));
			根据条件中止(在重生室中(事件玩家));
			按下按键(事件玩家, 按钮(技能2));
			等待(0.250, 无视条件);
		End;
	}
}

规则("symmetra auto-breaks tp after time limit")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		秩序之光;
	}

	条件
	{
		技能冷却时间(事件玩家, 按钮(技能2)) > 0;
	}

	动作
	{
		等待(1.250, 当为“假”时中止);
		While(正在使用技能 2(事件玩家));
			根据条件中止(在重生室中(事件玩家));
			按下按键(事件玩家, 按钮(技能2));
			等待(0.250, 无视条件);
		End;
	}
}

规则("when d.va demechs, set starting point (for goal) and enable remech")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(D.Va);
		处于非初始状态(事件玩家) == 真;
		正在使用终极技能(事件玩家) == 假;
	}

	动作
	{
		设置状态(事件玩家, 空, 无敌, 1.500);
		设置启用终极技能(事件玩家, 假);
		等待(0.050, 无视条件);
		事件玩家.dvaStart = 所选位置(事件玩家) * 矢量(1, 0, 1);
		等待(1, 无视条件);
		设置启用终极技能(事件玩家, 真);
	}
}

规则("while d.va is out of mech and alive, update ult charge to reflect goal distance")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		D.Va;
	}

	条件
	{
		处于非初始状态(事件玩家) == 真;
		存活(事件玩家) == 真;
		事件玩家.dvaStart != 0;
		终极技能充能百分比(事件玩家) != 100;
	}

	动作
	{
		设置终极技能充能(事件玩家, 3.333 * 相距距离(所选位置(事件玩家) * 矢量(1, 0, 1), 事件玩家.dvaStart));
		等待(0.500 * 服务器负载平均值 / 100, 无视条件);
		如条件为“真”则循环;
	}
}

规则("once baby d.va is far enough from where she lost mech, she can remech")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		D.Va;
	}

	条件
	{
		处于非初始状态(事件玩家) == 真;
		事件玩家.dvaStart != 0;
	}

	动作
	{
		等待直到 (相距距离(所选位置(事件玩家) * 矢量(1, 0, 1), 事件玩家.dvaStart) >= 30 || 死亡(事件玩家), 9999);
		事件玩家.dvaStart = 0;
		根据条件中止(死亡(事件玩家));
		设置终极技能充能(事件玩家, 100);
	}
}

规则("reinhardt cannot charge bastions")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		莱因哈特;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		等待直到 (首个(范围内玩家(事件玩家, 2, 队伍2, 关闭)) || !正在使用技能 1(事件玩家), 5);
		根据条件中止(!正在使用技能 1(事件玩家));
		等待(0.016, 无视条件);
		取消主要动作(事件玩家);
	}
}

规则("ana can only sleep each bastion once per limited amount of time")
{
	事件
	{
		玩家造成伤害;
		队伍1;
		安娜;
	}

	条件
	{
		事件技能 == 按钮(技能1);
	}

	动作
	{
		If(总计消耗时间 - 事件玩家.anaSleepLimit[栏位(被攻击方)] > 30);
			"taking damage won't wake bastion"
			设置状态(被攻击方, 空, 无敌, 5);
			事件玩家.anaSleepLimit[栏位(被攻击方)] = 总计消耗时间;
		Else;
			大字体信息(事件玩家, 自定义字符串("{0} 我起了！ {0}时间到了！", 图标字符串(警告)));
			等待(0.100, 无视条件);
			While(具有状态(被攻击方, 沉睡));
				清除状态(被攻击方, 沉睡);
				等待(0.100, 无视条件);
			End;
	}
}

规则("ana's sleep limit refreshes when she spawns")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		安娜;
	}

	条件
	{
		存活(事件玩家) == 真;
	}

	动作
	{
		等待(服务器负载平均值 / 100, 无视条件);
		事件玩家.anaSleepLimit = 映射的数组(全局.bastionPosition, -30);
	}
}

规则("[Zenyatta] Snap Kick (Self Ground)  - created by 他又 from 77QS1")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		禅雅塔;
	}

	条件
	{
		正在近战攻击(事件玩家) == 真;
		垂直朝向角度(事件玩家) >= 45;
	}

	动作
	{
		// 等待直到 (相距距离(眼睛位置(事件玩家), 射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 3, 空, 空, 假)) <= 2, 0.200);
		// If(相距距离(眼睛位置(事件玩家), 射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 3, 空, 空, 假)) <= 2);
		// 	施加推力(事件玩家, 面朝方向(事件玩家) * 矢量(-1, -0.750, -1) + 上 * 0.200, 12 * (Y方向分量(面朝方向(事件玩家)) > -0.750 ? 1 : 2 * (1.250 + Y方向分量(面朝方向(事件玩家)))),
		// 		至地图, 取消相反运动);
		If(相距距离(射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 2.510, 所有玩家(所有队伍), 事件玩家, 真), 眼睛位置(事件玩家)) <= 2.500);
			// 事件玩家.KnockbackDirection = ;
			等待(0.016, 无视条件);
			施加推力(事件玩家, 面朝方向(事件玩家) * -1, 15.500, 至地图, 取消相反运动);
			施加推力(事件玩家, 上, 15.500 * 0.300, 至地图, 取消相反运动);
		End;
	}
}

规则("[Zenyatta] Snap Kick (Self Wall)  - created by 他又 from 77QS1")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		禅雅塔;
	}

	条件
	{
		正在近战攻击(事件玩家) == 按钮(近身攻击);
		垂直朝向角度(事件玩家) < 45;
	}

	动作
	{
		If(相距距离(射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 2.510, 所有玩家(所有队伍), 事件玩家, 真), 眼睛位置(事件玩家)) <= 2.500);
			If(射线命中玩家(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 5, 所有玩家(所有队伍), 事件玩家, 真) == 空);
				施加推力(事件玩家, 面朝方向(事件玩家) * -1, 15.500, 至地图, 取消相反运动);
			施加推力(事件玩家, 上, 15.500 * 0.300, 至地图, 取消相反运动);
			End;
		End;
	}
}

禁用 规则("zenyatta's melee knocks him back")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		禅雅塔;
	}

	条件
	{
		正在近战攻击(事件玩家) == 真;
		垂直朝向角度(事件玩家) >= 45;
	}

	动作
	{
		// 等待直到 (相距距离(眼睛位置(事件玩家), 射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 3, 空, 空, 假)) <= 2, 0.200);
		// If(相距距离(眼睛位置(事件玩家), 射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 3, 空, 空, 假)) <= 2);
		// 	施加推力(事件玩家, 面朝方向(事件玩家) * 矢量(-1, -0.750, -1) + 上 * 0.200, 12 * (Y方向分量(面朝方向(事件玩家)) > -0.750 ? 1 : 2 * (1.250 + Y方向分量(面朝方向(事件玩家)))),
		// 		至地图, 取消相反运动);
		If(相距距离(射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 2.510, 所有玩家(所有队伍), 事件玩家, 真), 眼睛位置(事件玩家)) <= 2.500);
			// 事件玩家.KnockbackDirection = ;
			等待(0.016, 无视条件);
			施加推力(事件玩家, 面朝方向(事件玩家) * -1, 15.500, 至地图, 取消相反运动);
			施加推力(事件玩家, 上, 15.500 * 0.300, 至地图, 取消相反运动);
		End;
	}
}

规则("zenyatta's jump can levitate if held")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		// 单次赋值(全局.dlcVishkarEvent) != 真;
		所用英雄(事件玩家) == 英雄(禅雅塔);
		正在跳跃(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
	}

	动作
	{
		"don't activate the rule if the player is just jumping normally and not holding jump"
		等待(0.120, 当为“假”时中止);
		设置引力(事件玩家, 0);
		开始加速(事件玩家, Y方向分量(速率(事件玩家)) < 2 ? 上 : 下, Y方向分量(速率(事件玩家)) < 2.050 ? 5 : (Y方向分量(速率(事件玩家)) > 1.950 ? 17.500 : 0), 100, 至地图,
			方向，速率，及最大速度);
		等待直到 (!按钮被按下(事件玩家, 按钮(跳跃)), 1.500);
		设置引力(事件玩家, 100);
		停止加速(事件玩家);
		"ability is only available again once you touch the ground"
		等待直到 (在地面上(事件玩家), 10);
	}
}

规则("Lifeweaver disable Life Grip if no winners")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(生命之梭);
		事件玩家.isWinner != 真;
	}

	动作
	{
		禁用按钮(事件玩家, 按钮(技能2));
		设置启用技能 2(事件玩家, 假);
		等待直到 (事件玩家.isWinner == 真 || 所用英雄(事件玩家) != 英雄(生命之梭), 999999986991104.000);
		可用按钮(事件玩家, 按钮(技能2));
		设置启用技能 2(事件玩家, 真);
	}
}

规则("Hashtag")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		弗蕾娅;
	}

	条件
	{
		数量(已过滤的数组(所有玩家(队伍1), 当前数组元素.isWinner && !当前数组元素.isDev)) == 0;
		正在使用英雄(英雄(雾子), 队伍1) != 真;
		具有状态(事件玩家, 相移) != 真;
		具有状态(事件玩家, 无敌) != 真;
		正在使用技能 2(事件玩家) == 真;
		全局.hashTag == 真;
	}

	动作
	{
		等待直到 (!正在使用技能 2(事件玩家), 0.160);
		全局.hashTag = 单次赋值(技能冷却时间(事件玩家, 按钮(技能2)) < 3 ? 假 : 真);
		等待(60, 无视条件);
	}
}

禁用 规则("Hashtag")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		死神;
	}

	条件
	{
		正在使用英雄(英雄(雾子), 队伍1) != 真;
		// 具有状态(事件玩家, 相移) != 真;
		// 具有状态(事件玩家, 无敌) != 真;
		正在使用技能 2(事件玩家) == 真;
		全局.hashTag == 真;
	}

	动作
	{
		等待直到 (!正在使用技能 2(事件玩家), 0.160);
		全局.hashTag = 单次赋值(技能冷却时间(事件玩家, 按钮(技能2)) < 30 ? 假 : 真);
		等待(60, 无视条件);
	}
}

规则("Hashtag")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		朱诺;
	}

	条件
	{
		正在使用英雄(英雄(雾子), 队伍1) != 真;
		// 具有状态(事件玩家, 相移) != 真;
		// 具有状态(事件玩家, 无敌) != 真;
		正在使用技能 1(事件玩家) == 真;
		全局.hashTag == 真;
	}

	动作
	{
		等待直到 (!正在使用技能 1(事件玩家), 3);
		全局.hashTag = 单次赋值(技能冷却时间(事件玩家, 按钮(技能1)) < 3.8 ? 假 : 真);
		等待(60, 无视条件);
	}
}

规则("Hashtag")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		毛加;
	}

	条件
	{
		正在使用英雄(英雄(雾子), 队伍1) != 真;
		// 具有状态(事件玩家, 相移) != 真;
		// 具有状态(事件玩家, 无敌) != 真;
		正在使用技能 1(事件玩家) == 真;
		全局.hashTag == 真;
	}

	动作
	{
		等待直到 (!正在使用技能 1(事件玩家), 4);
		全局.hashTag = 单次赋值(技能冷却时间(事件玩家, 按钮(技能1)) < 3.8 ? 假 : 真);
		等待(60, 无视条件);
	}
}

禁用 规则("Sym disable Ability 1 if no winners")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(秩序之光);
		事件玩家.isWinner != 真;
	}

	动作
	{
		禁用按钮(事件玩家, 按钮(技能1));
		设置启用技能 1(事件玩家, 假);
		等待直到 (事件玩家.isWinner == 真 || 所用英雄(事件玩家) != 英雄(秩序之光), 999999986991104.000);
		可用按钮(事件玩家, 按钮(技能1));
		设置启用技能 1(事件玩家, 真);
	}
}

禁用 规则("Trob disable Ability 1 if no winners")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(托比昂);
		事件玩家.isWinner != 真;
	}

	动作
	{
		禁用按钮(事件玩家, 按钮(技能1));
		设置启用技能 1(事件玩家, 假);
		等待直到 (事件玩家.isWinner == 真 || 所用英雄(事件玩家) != 英雄(托比昂), 999999986991104.000);
		可用按钮(事件玩家, 按钮(技能1));
		设置启用技能 1(事件玩家, 真);
	}
}

规则("Lifeweaver auto-breaks Petal Platform after time limit")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		生命之梭;
	}

	条件
	{
		技能冷却时间(事件玩家, 按钮(技能1)) > 0;
		
	}

	动作
	{
		等待(3, 当为“假”时中止);
		While(正在使用技能 1(事件玩家));
			禁用 根据条件中止(在重生室中(事件玩家));
			按下按键(事件玩家, 按钮(技能1));
			等待(0.250, 无视条件);
		End;
	}
}

规则("when players in the 2nd or 3rd map, no bastions within their field of vision can save respawn vectors.")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.controlRespawnPosition) != 空;
		单次赋值(全局.portalPosition) == 空;
		事件玩家.isWinner != 真;
		已重生(事件玩家) == 真;
		首个(范围内玩家(事件玩家, 60, 队伍2, 表面)) == 假;
		正在移动(事件玩家) != 真;
		事件玩家.controlJumpIndex > 0;
		事件玩家.controlPlayerRespawnPosition == 空;
		事件玩家.controlPlayerRespawn == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
	}

	动作
	{
		小字体信息(事件玩家, 自定义字符串("  {0} 正在尝试设置存档点...", 技能图标字符串(英雄(天使), 按钮(技能2))));
		等待(1, 当为“假”时中止);
		事件玩家.controlPlayerRespawn = 真;
		事件玩家.controlPlayerRespawnPosition = 数组(所选位置(事件玩家), 面朝方向(事件玩家), 所用英雄(事件玩家), 事件玩家.controlJumpIndex);
		播放效果(所有玩家(所有队伍), “黑影”位移传动材料效果, 颜色(白色), 事件玩家, 200);
		小字体信息(事件玩家, 自定义字符串("  {0} 存档点已设置，阵亡后将自动复活", 技能图标字符串(英雄(天使), 按钮(技能2))));
	}
}

规则("when player died and controlPlayerRespawn set, respawn to controlPlayerRespawnPosition")
{
	事件
	{
		玩家阵亡;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.controlRespawnPosition) != 空;
		单次赋值(全局.portalPosition) == 空;
		事件玩家.isWinner != 真;
		事件玩家.controlPlayerRespawn == 真;
		事件玩家.controlPlayerRespawnPosition != 空;
		事件玩家.controlJumpIndex > 0;
		所用英雄(事件玩家) == 事件玩家.controlPlayerRespawnPosition[2];
	}

	动作
	{
		大字体信息(事件玩家, 自定义字符串("正在复活至存档点"));
		关闭游戏预设复生模式(事件玩家);
		等待(3, 无视条件);
		开启游戏预设复生模式(事件玩家);
		复活(事件玩家);
		传送(事件玩家, 首个(事件玩家.controlPlayerRespawnPosition));
		设置朝向(事件玩家, 事件玩家.controlPlayerRespawnPosition[1], 至地图);
		事件玩家.controlPlayerRespawn = 假;
		"0.5秒后回退跳跃索引，防止玩家图2复活后无法传送到下一个存档点"
		等待(0.500, 无视条件);
		If(事件玩家.controlJumpIndex > 事件玩家.controlPlayerRespawnPosition[3]);
			事件玩家.controlJumpIndex = 事件玩家.controlPlayerRespawnPosition[3];
		End;
		小字体信息(事件玩家, 自定义字符串("  {0} 存档点已消耗", 技能图标字符串(英雄(天使), 按钮(技能2))));
		小字体信息(事件玩家, 自定义字符串("  {0} 在切换至下一个英雄前，存档点不可用", 技能图标字符串(英雄(天使), 按钮(技能2))));
	}
}

规则("when player died and controlPlayerRespawn not set, respawn to first respawn point")
{
	事件
	{
		玩家阵亡;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.controlRespawnPosition) != 空;
		事件玩家.controlPlayerRespawn != 真;
	}

	动作
	{
		// If(对任意为“真”(选择英雄的玩家(英雄(天使), 队伍1), 相距距离(所选位置(事件玩家), 所选位置(当前数组元素)) > 40 && 存活(当前数组元素) && 技能冷却时间(当前数组元素, 按钮(技能2)) > 0));
		// 根据条件跳过(对任意为“真”(选择英雄的玩家(英雄(天使), 队伍1), 相距距离(所选位置(事件玩家), 所选位置(当前数组元素)) < 12 && 存活(当前数组元素) && 技能冷却时间(当前数组元素, 按钮(技能2)) < 8 && 事件玩家.mercyResurrect), 7);
		等待(0.5, 无视条件);
		根据条件跳过(数量(已过滤的数组(
            选择英雄的玩家(英雄(天使), 队伍1),
            存活(当前数组元素) && 
            相距距离(所选位置(事件玩家), 所选位置(当前数组元素)) < 全局.controlRespawnPosition == 空 ? 15 : 40 && 
            技能冷却时间(当前数组元素, 按钮(技能2)) < 5 && 
            玩家变量(当前数组元素, mercyResurrect) == 真
        )) > 0, 6);
		事件玩家.controlJumpIndex = 0;
		// END;
		等待(0.016, 无视条件);
		等待直到(已重生(事件玩家), 7);
		IF(在重生室中(事件玩家));
			传送(事件玩家, 首个(全局.controlRespawnPosition));
			设置朝向(事件玩家, 方向(眼睛位置(事件玩家), 所选位置(首个(全局.controlRespawnPosition))), 至地图);
			// 事件玩家.controlJumpIndex = 0;

	}
}

规则("Mercy disable Resurrect when control")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.controlRespawnPosition != 空) == 真;
		所用英雄(事件玩家) == 英雄(天使);
		// 数量(已过滤的数组(已过滤的数组(所有死亡玩家(队伍1), (当前数组元素.controlPlayerRespawnPosition == 空 && 当前数组元素.controlPlayerRespawn == 假) || (当前数组元素.controlPlayerRespawn == 假 && 当前数组元素.controlRespawnPosition != 空数组)), 相距距离(所选位置(事件玩家), 所选位置(当前数组元素)) < 40))
		事件玩家.mercyResurrect == 假;
	}

	动作
	{
		禁用按钮(事件玩家, 按钮(技能2));
		设置启用技能 2(事件玩家, 假);
		等待直到 (所用英雄(事件玩家) != 英雄(天使) || 事件玩家.mercyResurrect, 999999986991104.000);
		可用按钮(事件玩家, 按钮(技能2));
		设置启用技能 2(事件玩家, 真);
		等待(0.032, 无视条件);
		如条件为“真”则循环;
	}
}

规则("Mercy disable Resurrect when control")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.controlRespawnPosition != 空) == 真;
		所用英雄(事件玩家) == 英雄(天使);
		数量(
			已过滤的数组(
				已过滤的数组(所有死亡玩家(队伍1), (当前数组元素.controlPlayerRespawn == 假 && 当前数组元素.controlPlayerRespawnPosition != 空)), 相距距离(所选位置(事件玩家), 所选位置(当前数组元素)) < 15)) > 0;
		事件玩家.mercyResurrect == 假;
	}

	动作
	{
		事件玩家.mercyResurrect = 真;
		等待直到(数量(已过滤的数组(
				已过滤的数组(所有死亡玩家(队伍1), (当前数组元素.controlPlayerRespawn == 假 && 当前数组元素.controlPlayerRespawnPosition != 空)), 相距距离(所选位置(事件玩家), 所选位置(当前数组元素)) < 15)) == 0, 8);
		事件玩家.mercyResurrect = 假;
	}
}

规则("when players reaches the end and not respawn at first respawn point, they move to the first respawn point.")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.controlRespawnPosition) != 空;
		已重生(事件玩家) == 真;
		在重生室中(事件玩家) == 真;
		// 相距距离(矢量(0, 全局.controlRespawnAxis == 0 ? X方向分量(所选位置(事件玩家)) : Y方向分量(所选位置(事件玩家)), 全局.controlRespawnAxis == 2 ? Z方向分量(所选位置(事件玩家)) : 0), 矢量(0, 全局.controlRespawnAxis == 0 ? X方向分量(首个(全局.controlRespawnPosition)) : Y方向分量(首个(全局.controlRespawnPosition)), 全局.controlRespawnAxis == 2 ? Z方向分量(首个(全局.controlRespawnPosition)) : 0)) >= 全局.controlRespawnAxisThreshold;
		对任意为“真”(
			数组(
				全局.controlRespawnAxis == 0 && 相距距离(矢量(X方向分量(所选位置(事件玩家)), 0, 0), 矢量(X方向分量(首个(全局.controlRespawnPosition)), 0, 0)) >= 全局.controlRespawnAxisThreshold,
				全局.controlRespawnAxis == 1 && 相距距离(矢量(0, Y方向分量(所选位置(事件玩家)), 0), 矢量(0, Y方向分量(首个(全局.controlRespawnPosition)), 0)) >= 全局.controlRespawnAxisThreshold,
				全局.controlRespawnAxis == 2 && 相距距离(矢量(0, 0, Z方向分量(所选位置(事件玩家))), 矢量(0, 0, Z方向分量(首个(全局.controlRespawnPosition)))) >= 全局.controlRespawnAxisThreshold
			), 当前数组元素) == 真;
		事件玩家.controlJumpIndex == 0;
	}

	动作
	{
		传送(事件玩家, 全局.controlRespawnPosition[事件玩家.controlJumpIndex]);
		设置朝向(事件玩家, 方向(眼睛位置(事件玩家), 所选位置(全局.controlJumpPosition[事件玩家.controlJumpIndex])), 至地图);
		等待(0.032, 无视条件);
	}
}

规则("when a player reaches the control jump point, they move on to the next map")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.controlRespawnPosition) != 空;
		已重生(事件玩家) == 真;
		在重生室中(事件玩家) != 真;
		正在移动(事件玩家) == 真;
		禁用 Y方向分量(所选位置(事件玩家)) >= Y方向分量(全局.controlJumpPosition[事件玩家.controlJumpIndex]);
		禁用 相距距离(所选位置(事件玩家) * 矢量(1, 0, 1), 全局.controlJumpPosition[事件玩家.controlJumpIndex] * 矢量(1, 0, 1)) <= 4;
	}

	动作
	{
		等待(0.032, 当为“假”时中止);
		等待(0.2, 无视条件);
		IF(对全部为“真”(
			数组(
				Y方向分量(所选位置(事件玩家)) >= Y方向分量(全局.controlJumpPosition[事件玩家.controlJumpIndex]), 
				相距距离(所选位置(事件玩家) * 矢量(1, 0, 1), 全局.controlJumpPosition[事件玩家.controlJumpIndex] * 矢量(1, 0, 1)) <= 4
			), 当前数组元素));
			根据条件跳过(全局.controlJumpPosition[事件玩家.controlJumpIndex] == 空, 9);
			事件玩家.controlJumpIndex += 1;
			等待(0.016, 无视条件);
			传送(事件玩家, 全局.controlRespawnPosition[事件玩家.controlJumpIndex]);
			设置朝向(事件玩家, 方向(眼睛位置(事件玩家), 所选位置(全局.controlJumpPosition[事件玩家.controlJumpIndex])), 至地图);
			等待(2.160, 无视条件);
			根据条件跳过(事件玩家.controlPlayerRespawn == 真 || 事件玩家.controlPlayerRespawnPosition != 空 || 事件玩家.isWinner == 真 || 全局.portalPosition != 空, 3);
			小字体信息(事件玩家, 自定义字符串("  存档点可设置"));
			等待(0.032, 无视条件);
			小字体信息(事件玩家, 自定义字符串("  请考虑在合适的位置 长按 {0} 设置存档点（每个英雄仅限 1 次）", 按钮(装填)));
		End;
		循环;
		// 事件玩家.controlPlayerRespawn = 假;
		// 事件玩家.controlPlayerRespawnPosition = 空;
	}
}

规则("when a player reaches the end, they move on to the next hero or win if they're bastion")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		Y方向分量(所选位置(事件玩家)) >= Y方向分量(全局.endPosition);
		相距距离(所选位置(事件玩家) * 矢量(1, 0, 1), 全局.endPosition * 矢量(1, 0, 1)) <= 4;
	}

	动作
	{
		复生(事件玩家);
		等待(0.032, 无视条件);
		根据条件跳过(全局.controlRespawnPosition == 空, 2);
		事件玩家.controlJumpIndex = 0;
		传送(事件玩家, 首个(全局.controlRespawnPosition));
		等待(0.032, 无视条件);
		设置朝向(事件玩家, 方向(眼睛位置(事件玩家), 所选位置(首个(全局.controlJumpPosition))), 至地图);
		If(事件玩家.heroNumber + 1 < 数量(全局.heroList) && 所用英雄(事件玩家) == 全局.heroList[事件玩家.heroNumber]);
			调用子程序(progressHero);
		Else If(所用英雄(事件玩家) == 最后(全局.heroList) && !事件玩家.isWinner);
			事件玩家.isWinner = 真;
			事件玩家.winnerTime = 单次赋值(总计消耗时间) - 事件玩家.joinTime;
			// 大字体信息(所有玩家(队伍1), 自定义字符串("恭喜 {0} 以 {1} 耗时 {2} 通关!", 事件玩家, 自定义字符串("{0} 次阵亡 & {1} 次跳过", 事件玩家.runDeathCount, 事件玩家.skipCount), 自定义字符串("{0}{1}{2}", 总计消耗时间 - 事件玩家.joinTime > 3599 ? 自定义字符串("{0}小时{1} ", 取整(取整(总计消耗时间 - 事件玩家.joinTime, 上) / 3600, 下),
			// 总计消耗时间 - 事件玩家.joinTime / 3600 >= 2 ? 自定义字符串("") : 自定义字符串("")) : 自定义字符串(""), 总计消耗时间 - 事件玩家.joinTime > 59 ? 自定义字符串("{0}分{1} ", 取整(取整(总计消耗时间 - 事件玩家.joinTime, 上) % 3600 / 60,
			// 下), 取整(取整(总计消耗时间 - 事件玩家.joinTime, 上) % 3600 / 60, 下) != 1 ? 自定义字符串("") : 自定义字符串("")) : 自定义字符串(""), 自定义字符串("{0}秒{1}", 取整(总计消耗时间 - 事件玩家.joinTime, 上) % 60, 取整(
			// 总计消耗时间 - 事件玩家.joinTime, 上) % 60 != 1 ? 自定义字符串("") : 自定义字符串("")))));
			根据条件跳过(对任意为“真”(数组(事件玩家.dmgReduc, 事件玩家.invincible, 事件玩家.isPortalEnabled, 事件玩家.isAirWalkEnabled), 当前数组元素), 1);
			大字体信息(
				所有玩家(队伍1), 
				自定义字符串("祝贺 {0} 以 {1} 耗时 {2} 通关!", 
					事件玩家, 
					自定义字符串("{0} 次阵亡 & {1} 次跳过", 事件玩家.runDeathCount, 事件玩家.skipCount), 
					自定义字符串("{0}{1}{2}", 
						// 小时部分
						事件玩家.winnerTime != 空 && 事件玩家.winnerTime >= 3600 ? 
							自定义字符串("{0}小时", 取整(事件玩家.winnerTime / 3600, 下)) : 
							自定义字符串(""),
						
						// 分钟部分
						事件玩家.winnerTime != 空 && 事件玩家.winnerTime >= 60 ? 
							自定义字符串("{0}分", 取整((事件玩家.winnerTime % 3600) / 60, 下)) : 
							自定义字符串(""),
						
						// 秒部分
						事件玩家.winnerTime != 空 ? 
							自定义字符串("{0}秒", 取整(事件玩家.winnerTime % 60, 下)) : 
							自定义字符串("0秒")
					)
				)
			);
			小字体信息(事件玩家, 自定义字符串("  {0} 你已通关，可以加入聊天群 发送截图 获取通关称号", 图标字符串(对号)));
			调用子程序(savePlayerData);
	}
}

规则("winners earn their ult once per minute")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.isWinner != 假;
		终极技能充能百分比(事件玩家) < 100;
		正在使用终极技能(事件玩家) == 假;
	}

	动作
	{
		设置终极技能充能(事件玩家, 终极技能充能百分比(事件玩家) + 5);
		等待(3, 无视条件);
		如条件为“真”则循环;
	}
}

规则("initialize effects")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.hashTag = 真;
		等待(随机实数(1, 2), 无视条件);
		调用子程序(setDifficulty);
		"player HUD"
		禁用 创建HUD文本(所有玩家(所有队伍), 空, 空, 自定义字符串(
			" \n\n                                                                                                                        "),
			左边, 0, 空, 空, 空, 可见和字符串, 始终可见);
		创建HUD文本(本地玩家.heroNumber + 1 < 数量(全局.heroList) && 所用英雄(本地玩家) == 全局.heroList[本地玩家.heroNumber] ? 本地玩家 : 空, 自定义字符串("{0}: {1}", 自定义字符串(
			"阵亡"), 自定义字符串("{0} / {1}", 本地玩家.progressionDeathCount, 全局.difficulty != 5 ? 全局.maxDeath : 自定义字符串("∞"))), 自定义字符串(""), 空, 左边, 2, 颜色(白色), 空, 空, 可见和字符串, 默认可见度);
		创建HUD文本(本地玩家, 自定义字符串("{0}: {1}", 自定义字符串("英雄"), 自定义字符串("{0} / {1}", 数组值的索引(全局.heroList, 所用英雄(本地玩家)) + 1, 数量(全局.heroList))),
			自定义字符串(""), 空, 左边, 3, 颜色(白色), 空, 空, 可见和字符串, 默认可见度);
		根据条件跳过(全局.controlJumpPosition == 空 || 全局.portalPosition != 空, 1);
		创建HUD文本(!本地玩家.isWinner ? 本地玩家 : 空, 空, 自定义字符串("存档点（{1}）: {0}", 本地玩家.controlPlayerRespawnPosition == 空 && 本地玩家.controlPlayerRespawn == 假 && 本地玩家.controlJumpIndex != 0 ? 自定义字符串("可用") : 自定义字符串("不可用"), 按钮(装填)), 空, 左边, 3, 空, 本地玩家.controlPlayerRespawnPosition == 空 && 本地玩家.controlPlayerRespawn == 假 && 本地玩家.controlJumpIndex != 0 ? 颜色(绿色) : 颜色(红色), 空, 可见，字符串和颜色, 默认可见度);
		创建HUD文本(本地玩家.isWinner || 所用英雄(本地玩家) != 全局.heroList[本地玩家.heroNumber] ? 空数组 : 本地玩家, 本地玩家.heroNumber + 1 < 数量(全局.heroList) ? 英雄图标字符串(
			全局.heroList[本地玩家.heroNumber + 1]) : 图标字符串(旗帜), 自定义字符串("下一个英雄"), 本地玩家.heroNumber + 1 < 数量(全局.heroList)
			? 全局.heroList[本地玩家.heroNumber + 1] : 自定义字符串("逃脱成功"), 左边, 4, 自定义颜色(36, 205, 244, 255), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(本地玩家.isWinner || 所用英雄(本地玩家) == 全局.heroList[本地玩家.heroNumber] ? 空数组 : 本地玩家, 图标字符串(拒绝), 自定义字符串("下一个英雄"), 自定义字符串(
			"{0} 已解锁！", 英雄图标字符串(全局.heroList[本地玩家.heroNumber])), 左边, 4, 自定义颜色(235, 45, 79, 255), 自定义颜色(235, 45, 79, 255), 自定义颜色(235,
			45, 79, 255), 可见和字符串, 默认可见度);
		创建HUD文本(本地玩家.isWinner ? 本地玩家 : 空, 图标字符串(对号), 自定义字符串("下一个英雄"), 自定义字符串("挑战完成"), 左边, 4, 颜色(绿色), 颜色(绿色), 颜色(绿色), 可见和字符串, 默认可见度);
		创建HUD文本(全局.hashTag ? 空 : 本地玩家, 空, 自定义字符串("成就挑战已禁用 {0}", 图标字符串(警告)), 空, 左边, 4, 空, 自定义颜色(160, 169, 186, 255), 空, 可见和字符串, 始终不可见);
		创建HUD文本(本地玩家 == 全局.A36TGrenadeFB ? 本地玩家 : 空,技能图标字符串(英雄(堡垒), 按钮(辅助攻击模式)), 自定义字符串("你已获得"), 自定义字符串("第一颗蛋"), 左边, 4, 颜色(红色), 颜色(红色), 颜色(红色), 可见和字符串, 始终不可见);
		创建HUD文本(全局.difficulty != 5 ? 本地玩家 : 空, 空, 自定义字符串("本轮共计 {0} 次阵亡", 本地玩家.runDeathCount), 空, 左边, 5, 空, 自定义颜色(160,169,186,255), 空, 可见和字符串, 始终不可见);
		创建HUD文本(本地玩家, 空, 自定义字符串("本轮共计 {0} 次跳过", 本地玩家.skipCount), 空, 左边, 5, 空, 自定义颜色(160,169,186,255), 空, 可见和字符串, 始终不可见);
		// 根据条件跳过(全局.difficulty != 5, 3);
		创建HUD文本(全局.difficulty != 5 ? 空 : 本地玩家, 空, 自定义字符串("榴弹共计 {0} 点伤害", 取整(本地玩家.A36TGrenadeDmg, 上)), 空, 左边, 5, 空, 自定义颜色(160,169,186,255), 空, 可见和字符串, 始终不可见);
		创建HUD文本(全局.difficulty != 5 ? 空 : 本地玩家, 空, 自定义字符串("榴弹共计 {0}/{1} 命中/锁定", 本地玩家.A36TGrenadeHit, 本地玩家.A36TGrenade), 空, 左边, 5, 空, 自定义颜色(160,169,186,255), 空, 可见和字符串, 始终不可见);
		创建HUD文本(本地玩家.A36TGrenadeAlive == 真 ? 本地玩家 : 空, 空, 自定义字符串("大难不死 {0} ", 本地玩家.A36TGrenadeAlive == 真 ? 图标字符串(对号) : 空), 空, 左边, 5, 空, 自定义颜色(160,169,186,255), 空, 可见和字符串, 始终不可见);
		
		创建HUD文本(
			本地玩家.isWinner ? 本地玩家 : 空, 
			空, 
			自定义字符串("通关总计耗时 {0}", 
				自定义字符串("{0}{1}{2}", 
					// 小时部分
					本地玩家.winnerTime != 空 && 本地玩家.winnerTime >= 3600 ? 
						自定义字符串("{0} 小时", 取整(本地玩家.winnerTime / 3600, 下)) : 
						自定义字符串(""),
					
					// 分钟部分
					本地玩家.winnerTime != 空 && 本地玩家.winnerTime >= 60 ? 
						自定义字符串("{0} 分", 取整((本地玩家.winnerTime % 3600) / 60, 下)) : 
						自定义字符串(""),
					
					// 秒部分
					本地玩家.winnerTime != 空 ? 
						自定义字符串("{0} 秒", 取整(本地玩家.winnerTime % 60, 下)) : 
						自定义字符串("0 秒")
				)
			), 
			空, 
			左边, 
			51, 
			空, 
			自定义颜色(160,169,186,255), 
			空, 
			可见和字符串, 
			始终不可见
		);
		创建HUD文本(全局.difficulty != 5 && 本地玩家.progressionDeathCount == 全局.maxDeath ? 本地玩家 : 空, 空, 自定义字符串("[秘籍] 使用终极技能跳过({0}) ", 输入绑定字符串(按钮(终极技能))), 空, 左边, 6,
			空, 颜色(蓝色), 空, 可见和字符串, 默认可见度);
		"goal effects"
		等待(0.500, 无视条件);
		创建效果(所有玩家(队伍1), 环, 颜色(队伍1), 全局.endPosition, 4, 可见，位置和半径);
		创建效果(所有玩家(队伍1), 光柱, 颜色(队伍1), 全局.endPosition, 4, 可见，位置和半径);
		创建图标(全局.controlJumpPosition == 空 ? 所有玩家(队伍1) : 已过滤的数组(所有玩家(队伍1), 当前数组元素.controlJumpIndex == 单次赋值(数量(全局.controlRespawnPosition)) - 1), 全局.endPosition + 矢量(0, 5, 0), 旗帜, 可见和位置, 颜色(蓝色), 真);
		IF(全局.controlJumpPosition != 空);
			创建效果(所有玩家(队伍1), 环, 颜色(黄色), 首个(全局.controlJumpPosition), 4, 可见，位置和半径);
			创建效果(所有玩家(队伍1), 光柱, 颜色(黄色), 首个(全局.controlJumpPosition), 4, 可见，位置和半径);
			// 创建图标(所有玩家(所有队伍), 首个(全局.controlJumpPosition) + 矢量(0, 5, 0), 旗帜, 可见和位置, 颜色(蓝色), 真);
			创建图标(已过滤的数组(所有玩家(队伍1), 当前数组元素.controlJumpIndex == 0), 首个(全局.controlJumpPosition) + 矢量(0, 5, 0), 旗帜, 可见和位置, 颜色(黄色), 真);
			根据条件跳过(全局.controlJumpPosition[1] == 空, 3);
			创建效果(所有玩家(队伍1), 环, 颜色(绿色), 全局.controlJumpPosition[1], 4, 可见，位置和半径);
			创建效果(所有玩家(队伍1), 光柱, 颜色(绿色), 全局.controlJumpPosition[1], 4, 可见，位置和半径);
			创建图标(已过滤的数组(所有玩家(队伍1), 当前数组元素.controlJumpIndex == 1), 全局.controlJumpPosition[1] + 矢量(0, 5, 0), 旗帜, 可见和位置, 颜色(绿色), 真);
		END;
		"mode info"
		等待(0.500, 无视条件);
		IF(全局.controlJumpPosition != 空 && 单次赋值(全局.portalPosition) == 空);
			创建HUD文本(所有玩家(所有队伍), 空, 空, 全局.difficulty != 5 ? 自定义字符串("欢迎来到三合一大地图！你需要依次挑战所有小地图并到达终点！阵亡 {0} 次之后可跳过英雄", 全局.maxDeath) : 自定义字符串("欢迎来到三合一大地图！你需要依次挑战所有小地图并到达终点！当前难度无法跳过英雄，加油吧！"), 顶部, 0, 空, 空, 自定义颜色(255, 255, 255,
				125), 可见和字符串, 默认可见度);
		ELSE;
			创建HUD文本(所有玩家(所有队伍), 空, 空, 全局.difficulty != 5 ? 自定义字符串("使用全部英雄通关，一旦你解锁了一个英雄就可以在后续的游戏中随时使用！当阵亡 {0} 次之后可跳过英雄", 全局.maxDeath) : 自定义字符串("使用全部英雄通关！当前难度无法跳过英雄，加油吧！"), 顶部, 0, 空, 空, 自定义颜色(255, 255, 255,
				125), 可见和字符串, 默认可见度);
		END;
		创建HUD文本(所有玩家(所有队伍), 空, 自定义字符串("{0}代码：SVMQK | 加群拿称号：445152554 | Kook.vip/44qoov \n", 全局.controlJumpPosition == 空 || 全局.portalPosition != 空 ? 自定义字符串("") : 自定义字符串("存档点每个英雄只能使用 1 次，请把握存档时机\n")), 空, 顶部, 1, 空, 自定义颜色(255, 255, 255, 125), 空, 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 空, 空, 自定义字符串("难度：{0}", 首个(全局.difficultyText)), 右边, -6, 空, 空, 全局.difficultyText[1], 可见，字符串和颜色, 默认可见度);
		IF(单次赋值(全局.dlcVishkarEvent));
			创建HUD文本(本地玩家, 空, 自定义字符串("{0}/{1}/{2} 增益/减益/总计", 首个(本地玩家.eventCount), 本地玩家.eventCount[1], 首个(本地玩家.eventCount) + 本地玩家.eventCount[1] + 最后(本地玩家.eventCount)), 空, 左边, 5, 空, 自定义颜色(X方向分量(全局.heroColor[5]),Y方向分量(全局.heroColor[5]),Z方向分量(全局.heroColor[5]),255), 空, 可见和字符串, 始终不可见);

			创建HUD文本(所有玩家(所有队伍), 空, 自定义字符串("［随机事件］"), 空, 右边, -5, 空, 全局.difficultyText[1], 空, 可见，字符串和颜色, 默认可见度);
			创建HUD文本(本地玩家, 空, 自定义字符串(" \r\n\n"), 空, 左边, 69, 空, 空, 空, 字符串, 始终不可见);
			创建HUD文本(本地玩家.eventId == -1 ? 空 : 本地玩家, 空, 自定义字符串("{0} {1}（{2}）", 技能图标字符串(英雄(黑影), 按钮(终极技能)), 本地玩家.eventName, 本地玩家.eventDuration > 0 ? 自定义字符串("{0}秒", 取整(本地玩家.eventDurationHud, 上)) : 自定义字符串("一次性")), 空, 左边, 70, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
			创建HUD文本(本地玩家.eventId == -1 ? 空 : 本地玩家, 空, 自定义字符串("{0} {1}", 技能图标字符串(英雄(黑影), 按钮(终极技能)), 本地玩家.eventDesc), 空, 左边, 71, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		End;
		创建HUD文本(
			所有玩家(所有队伍), 
			空, 
			自定义字符串("距自动重开 {0}", 
				自定义字符串("{0}{1}{2}", 
					(全局.rebootTime - 总计消耗时间) > 3599 ? 
						自定义字符串("{0} 小时 ", 取整((全局.rebootTime - 总计消耗时间) / 3600, 下)) : 
						自定义字符串(""),
					(全局.rebootTime - 总计消耗时间) > 59 ? 
						自定义字符串("{0} 分 ", 取整(((全局.rebootTime - 总计消耗时间) % 3600) / 60, 下)) : 
						自定义字符串(""),
					自定义字符串("{0} 秒", 取整((全局.rebootTime - 总计消耗时间) % 60, 下))
				)
			), 
			空, 
			右边, 
			-4, 
			空, 
			// 颜色条件判断：剩余时间小于10分钟(600秒)显示黄色，否则灰色
			(全局.rebootTime - 总计消耗时间) <= 600 ? 颜色(黄色) : 颜色(灰色), 
			空, 
			可见，字符串和颜色, 
			默认可见度
		);
		创建HUD文本(
			全局.devPlayer, 
			空, 
			自定义字符串("已运行 {0}", 
				自定义字符串("{0}{1}{2}", 
					// 小时部分
					总计消耗时间 >= 3600 ? 
						自定义字符串("{0} 小时 ", 取整(总计消耗时间 / 3600, 下)) : 
						自定义字符串(""),
					
					// 分钟部分
					总计消耗时间 >= 60 ? 
						自定义字符串("{0} 分 ", 取整((总计消耗时间 % 3600) / 60, 下)) : 
						自定义字符串(""),
					
					// 秒部分
					自定义字符串("{0} 秒", 取整(总计消耗时间 % 60, 下))
				)
			), 
			空, 
			右边, 
			-4, 
			空, 
			颜色(灰色), 
			空, 
			可见和字符串, 
			默认可见度
		);
		创建HUD文本(全局.devPlayer, 空, 自定义字符串("  服务器负载 {0}", 服务器负载平均值), 空, 右边, -2, 空, 颜色(灰色), 空, 可见和字符串,
			始终不可见);
		创建HUD文本(所有玩家(所有队伍), 空, 自定义字符串("版本 25.1023.2"), 空, 右边, -3, 空, 颜色(灰色), 空, 可见和字符串, 始终不可见);
		创建HUD文本(所有玩家(所有队伍), 空, 自定义字符串("版本 25.1023.2"), 空, 右边, -3, 空, 颜色(灰色), 空, 可见和字符串, 始终不可见);
		创建效果(所有玩家(所有队伍), 有害光环, 颜色(水绿色), 全局.creditsPosition, 随机实数(1, 2), 可见);
		创建效果(所有玩家(所有队伍), 有害光环, 颜色(天蓝色), 全局.creditsPosition, 随机实数(1, 2), 可见);
		创建效果(所有玩家(所有队伍), 有害光环, 颜色(白色), 全局.creditsPosition, 随机实数(1, 2), 可见);
		
		等待(0.500, 无视条件);
		// 创建效果(本地玩家, 环, 颜色(亮紫色), 全局.heroRingPosition, 1.200, 可见);
		// 创建地图文本(本地玩家, 自定义字符串("      按{0}切换第三人称视角\n                    {1}", 输入绑定字符串(按钮(跳跃)), 图标字符串(箭头：向下)),
		// 	全局.heroRingPosition + 上 * 1.300, 1.200, 根据表面截取, 可见，位置和字符串, 颜色(白色), 默认可见度);
		"3rd person camera"
		创建效果(本地玩家, 环, 颜色(亮紫色), 全局.thirdPersonPosition, 1.200, 可见);
		创建地图文本(本地玩家, 自定义字符串("      按{0}切换第三人称视角\n                    {1}", 输入绑定字符串(按钮(跳跃)), 图标字符串(箭头：向下)),
			全局.thirdPersonPosition + 上 * 1.300, 1.200, 根据表面截取, 可见，位置和字符串, 颜色(白色), 默认可见度);
		"reset progress ring"
		等待(0.500, 无视条件);
		创建效果(本地玩家.heroNumber > 0 || 本地玩家.runDeathCount > 0 ? 本地玩家 : 空, 环, 颜色(红色), 全局.resetPosition, 1.200, 可见);
		创建地图文本(本地玩家.heroNumber > 0 || 本地玩家.runDeathCount > 0 ? 本地玩家 : 空, 自定义字符串("重置进度\n                {0}", 图标字符串(箭头：向下)),
			全局.resetPosition + 上 * 1.300, 1.200, 根据表面截取, 可见，位置和字符串, 颜色(白色), 默认可见度);
		IF(全局.springBoardPosition != 空);
			创建效果(本地玩家, 环, 颜色(绿色), 全局.springBoardPosition, 1.200, 可见);
			创建地图文本(本地玩家, 自定义字符串("      按{0}向上弹射\n                    {1}", 输入绑定字符串(按钮(跳跃)), 图标字符串(箭头：向下)),
			全局.springBoardPosition + 上 * 1.300, 1.200, 根据表面截取, 可见，位置和字符串, 颜色(白色), 默认可见度);
		END;
		// "3rd person camera"
		// 等待(0.500, 无视条件);
		// 创建效果(本地玩家.heroNumber > 0 || 本地玩家.runDeathCount > 0 ? 本地玩家 : 空, 环, 颜色(红色), 全局.thirdPersonPosition, 1.200, 可见);
		// 创建地图文本(本地玩家.heroNumber > 0 || 本地玩家.runDeathCount > 0 ? 本地玩家 : 空, 自定义字符串("按{0}第三人称视角\n                {1}", 图标字符串(箭头：向下)),
		// 	全局.thirdPersonPosition + 上 * 1.300, 1.200, 根据表面截取, 可见，位置和字符串, 颜色(白色), 默认可见度);
	}
}

规则("bastion counts kills and marks himself after killing you")
{
	事件
	{
		玩家造成最后一击;
		队伍2;
		全部;
	}

	动作
	{
		全局.kills[栏位(事件玩家)] += 1;
		开始为机器人强制设置名称(事件玩家, 自定义字符串("看守{0} 击杀{1}", 栏位(事件玩家) + 1, 全局.kills[栏位(事件玩家)]));
		停止强制设置玩家轮廓(被攻击方.attacker, 被攻击方);
		等待(0.032, 无视条件);
		被攻击方.attacker = 攻击方;
		开始强制设置玩家轮廓(被攻击方.attacker, 被攻击方, 真, 颜色(红色), 总是);
	}
}

规则("create baby d.va goal header")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		正在使用英雄(英雄(D.Va), 队伍1) == 真;
	}

	动作
	{
		等待(2, 当为“假”时中止);
		创建HUD文本(所用英雄(本地玩家) == 英雄(D.Va) && 处于非初始状态(本地玩家) && 存活(本地玩家) && 本地玩家.dvaStart != 0 ? 本地玩家 : 空, 自定义字符串("目标距离:{0} m", 较大(0,
			30 - 相距距离(所选位置(本地玩家) * 矢量(1, 0, 1), 本地玩家.dvaStart * 矢量(1, 0, 1)))), 空, 空, 顶部, 5, 颜色(白色), 空, 空, 可见和字符串, 默认可见度);
		全局.textIDs[1] = 上一个文本ID;
		等待直到 (!正在使用英雄(英雄(D.Va), 队伍1), 9999);
		消除HUD文本(全局.textIDs[1]);
	}
}

规则("create ana sleep timer and instructions")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		正在使用英雄(英雄(安娜), 队伍1) == 真;
	}

	动作
	{
		创建HUD文本(所用英雄(本地玩家) == 英雄(安娜) && 在重生室中(本地玩家) ? 本地玩家 : 空, 自定义字符串(
			"{0} 麻醉镖限制: \n 每个堡垒每 {1} 秒只能被麻醉一次", 技能图标字符串(英雄(安娜), 按钮(技能1)), 30), 空, 空, 顶部, 5,
			颜色(白色), 空, 空, 可见, 默认可见度);
		等待(0.016, 无视条件);
		全局.textIDs[4] = 上一个文本ID;
		全局.textIDs[3] = 映射的数组(全局.bastionPosition, 0);
		For 全局变量(I, 0, 数量(全局.bastionPosition), 1);
			创建进度条地图文本(所用英雄(本地玩家) == 英雄(安娜) && 总计消耗时间 - 本地玩家.anaSleepLimit[单次赋值(全局.I)] < 30 && 相距距离(相距距离(眼睛位置(本地玩家), 全局.bastionPosition[单次赋值(
				全局.I)]) * 面朝方向(本地玩家) + 眼睛位置(本地玩家), 全局.bastionPosition[单次赋值(全局.I)]) <= 4 ? 本地玩家 : 空, (30 - (总计消耗时间 - 本地玩家.anaSleepLimit[单次赋值(
				全局.I)])) / 30 * 100, 自定义字符串("麻醉限制: 剩余 {0} 秒 ", 较小(30, 30 - 取整(总计消耗时间 - 本地玩家.anaSleepLimit[单次赋值(全局.I)], 下))),
				全局.bastionPosition[单次赋值(全局.I)], 1, 不要截取, 颜色(蓝色), 颜色(白色), 可见和值, 默认可见度);
			全局.textIDs[3] = 映射的数组(全局.textIDs[3], 当前数组索引 == 全局.I ? 上一个文本ID : 当前数组元素);
		End;
		等待直到 (!正在使用英雄(英雄(安娜), 队伍1), 9999);
		For 全局变量(I, 0, 数量(全局.textIDs[3]), 1);
			消除进度条地图文本(全局.textIDs[3][全局.I]);
		End;
		消除HUD文本(全局.textIDs[4]);
	}
}

禁用 规则("create zen instructions")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		正在使用英雄(英雄(禅雅塔), 队伍1) == 真;
	}

	动作
	{
		创建HUD文本(所用英雄(本地玩家) == 英雄(禅雅塔) && 在重生室中(本地玩家) ? 本地玩家 : 空, 自定义字符串(
			"踹击地面可以向后击退 {0}\n按住跳跃可以悬浮 {1}", 技能图标字符串(英雄(禅雅塔), 按钮(近身攻击)), 图标字符串(箭头：向上)), 空, 空, 顶部,
			5, 颜色(白色), 空, 空, 可见, 默认可见度);
		全局.textIDs[2] = 上一个文本ID;
		等待直到 (!正在使用英雄(英雄(禅雅塔), 队伍1), 9999);
		消除HUD文本(全局.textIDs[2]);
	}
}

禁用 规则("[JunkerQueen]: Fix Commanding Shout cd")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		渣客女王;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		等待直到(!正在使用技能 1(事件玩家), 12.16);
		设置技能冷却(事件玩家, 按钮(技能1), 4);
	}
}

禁用 规则("update scoreboard every few seconds")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		首个(所有玩家(队伍1)) != 假;
	}

	动作
	{
		全局.scoreboardArray = 已排序的数组(已过滤的数组(所有玩家(队伍1), !当前数组元素.isWinner), 0 - 当前数组元素.heroNumber);
		全局.firstPlace = 首个(全局.scoreboardArray);
		全局.secondPlace = 全局.scoreboardArray[1];
		全局.thirdPlace = 全局.scoreboardArray[2];
		等待(服务器负载平均值 / 50, 无视条件);
		如条件为“真”则循环;
	}
}

禁用 规则("outline devs who made or edited this mode, using random colors")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.rainbowOff == 假;
	}

	动作
	{
		开始强制设置玩家轮廓(事件玩家, 所有玩家(所有队伍), 真, 自定义颜色(随机实数(0, 255), 随机实数(0, 255), 随机实数(0, 255), 255), 总是);
		等待(0.128, 无视条件);
		如条件为“真”则循环;
	}
}

禁用 规则("devs can toggle rainbow effect")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
	}

	动作
	{
		事件玩家.rainbowOff = 事件玩家.rainbowOff ? 假 : 真;
		停止强制设置玩家轮廓(事件玩家, 所有玩家(所有队伍));
		小字体信息(事件玩家, 自定义字符串("DEV 特效{0}", 事件玩家.rainbowOff ? 自定义字符串("关闭") : 自定义字符串("开启")));
	}
}

规则("outline winners in green periodically")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.isWinner != 假;
		存活(事件玩家) == 真;
	}

	动作
	{
		等待(服务器负载平均值 / 100, 无视条件);
		开始强制设置玩家轮廓(事件玩家, 所有玩家(队伍1), 真, 颜色(绿色), 总是);
		等待(30, 当为“真”时重新开始);
		如条件为“真”则循环;
	}
}

规则("outline winners for new players as soon as they join")
{
	事件
	{
		玩家加入比赛;
		队伍1;
		全部;
	}

	条件
	{
		对任意为“真”(所有玩家(队伍1), 当前数组元素.isWinner) == 真;
	}

	动作
	{
		等待(服务器负载平均值 / 100, 无视条件);
		开始强制设置玩家轮廓(已过滤的数组(所有玩家(队伍1), 当前数组元素.isWinner), 事件玩家, 真, 颜色(绿色), 总是);
	}
}

规则("stop outline for non-winners")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.isWinner == 假;
	}

	动作
	{
		等待(服务器负载平均值 / 100, 无视条件);
		停止强制设置玩家轮廓(事件玩家, 所有玩家(队伍1));
	}
}

规则("increment death counter (progressionDeathCount) on death")
{
	事件
	{
		玩家阵亡;
		队伍1;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 全局.heroList[事件玩家.heroNumber];
		事件玩家.progressionDeathCount < 全局.maxDeath;
		事件玩家.heroNumber + 1 < 数量(全局.heroList);
		攻击方 != 空;
		攻击方 != 事件玩家;
	}

	动作
	{
		事件玩家.progressionDeathCount += 1;
	}
}

规则("display death progress as ult charge")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.difficulty != 5; // 地狱难度不使用此规则
		已重生(事件玩家) == 真;
		事件玩家.progressionDeathCount < 全局.maxDeath;
		(所用英雄(事件玩家) == 英雄(D.Va) && 处于非初始状态(事件玩家)) == 假;
		取整(终极技能充能百分比(事件玩家) / (100 / 全局.maxDeath), 至最近) != 事件玩家.progressionDeathCount;
		事件玩家.isWinner == 假;
	}

	动作
	{
		等待(随机实数(0.100, 0.500) * 服务器负载平均值 / 100, 当为“假”时中止);
		设置终极技能充能(事件玩家, 100 * 事件玩家.progressionDeathCount / 全局.maxDeath);
		如条件为“真”则循环;
	}
}

规则("display message if hero available")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.difficulty != 5; // 地狱难度不使用此规则
		事件玩家.progressionDeathCount == 全局.maxDeath;
		事件玩家.heroNumber + 1 < 数量(全局.heroList);
		(所用英雄(事件玩家) == 英雄(D.Va) && 处于非初始状态(事件玩家)) == 假;
		存活(事件玩家) == 真;
	}

	动作
	{
		等待(服务器负载 / 100, 无视条件);
		If(终极技能充能百分比(事件玩家) == 100);
			设置终极技能充能(事件玩家, 0);
			等待(0.200, 无视条件);
		End;
		大字体信息(事件玩家, 自定义字符串("可跳过当前英雄"));
		事件玩家.I = 0;
		While(终极技能充能百分比(事件玩家) != 100);
			设置终极技能充能(事件玩家, 100);
			等待(0.050, 无视条件);
			事件玩家.I += 1;
			根据条件中止(全局.I == 5);
		End;
	}
}

规则("players can use ultimate to progress to the next hero after dying a number of times (maxDeath)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.progressionDeathCount >= 全局.maxDeath;
		(正在使用终极技能(事件玩家) || 正在人格复制(事件玩家)) == 真;
		事件玩家.heroNumber + 1 < 数量(全局.heroList);
		所用英雄(事件玩家) != 英雄(堡垒);
	}

	动作
	{
		等待(1, 无视条件);
		复生(事件玩家);
		事件玩家.progressionDeathCount = 0;
		事件玩家.skipCount += 1;
		调用子程序(progressHero);
	}
}

// 禁用 规则("display instructions when a player enters the hero change ring")
// {
// 	事件
// 	{
// 		持续 - 每名玩家;
// 		队伍1;
// 		全部;
// 	}

// 	条件
// 	{
// 		事件玩家.heroNumber > 0;
// 		相距距离(所选位置(事件玩家) * 矢量(1, 0, 1), 全局.heroRingPosition * 矢量(1, 0, 1)) <= 1.200;
// 		数组包含(范围内玩家(全局.heroRingPosition, 20, 队伍1, 关闭), 事件玩家) == 真;
// 	}

// 	动作
// 	{
// 		大字体信息(事件玩家, 自定义字符串("   跳跃:下一个英雄 下蹲:上一个英雄"));
// 	}
// }

// 禁用 规则("pressing jump while in the hero change ring makes you the next available hero")
// {
// 	事件
// 	{
// 		持续 - 每名玩家;
// 		队伍1;
// 		全部;
// 	}

// 	条件
// 	{
// 		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
// 		事件玩家.heroNumber > 0;
// 		相距距离(事件玩家 * 矢量(1, 0, 1), 全局.heroRingPosition * 矢量(1, 0, 1)) <= 1.200;
// 	}

// 	动作
// 	{
// 		禁用按钮(事件玩家, 按钮(跳跃));
// 		While(按钮被按下(事件玩家, 按钮(跳跃)) && 相距距离(事件玩家 * 矢量(1, 0, 1), 全局.heroRingPosition * 矢量(1, 0, 1)) <= 1.200 && 事件玩家.heroNumber > 0);
// 			If(所用英雄(事件玩家) == 全局.heroList[事件玩家.heroNumber]);
// 				小字体信息(事件玩家, 自定义字符串("  英雄不可用"));
// 			Else;
// 				开始强制玩家选择英雄(事件玩家, 全局.heroList[数组值的索引(全局.heroList, 所用英雄(事件玩家)) + 1]);
// 				停止强制玩家选择英雄(事件玩家);
// 			End;
// 			等待(0.800, 无视条件);
// 		End;
// 		可用按钮(事件玩家, 按钮(跳跃));
// 	}
// }

规则("display instructions when a player enters the reset ring")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		(事件玩家.heroNumber > 0 || 事件玩家.runDeathCount > 0) == 真;
		数组包含(范围内玩家(全局.resetPosition, 20, 队伍1, 关闭), 事件玩家) == 真;
		相距距离(所选位置(事件玩家) * 矢量(1, 0, 1), 全局.resetPosition * 矢量(1, 0, 1)) <= 1.200;
	}

	动作
	{
		大字体信息(事件玩家, 自定义字符串("长按装填键重置"));
	}
}

规则("holding rel﻿oad while in the reset ring resets your progress")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		(事件玩家.runDeathCount > 0 || 事件玩家.heroNumber > 0) == 真;
		相距距离(事件玩家 * 矢量(1, 0, 1), 全局.resetPosition * 矢量(1, 0, 1)) <= 1.200;
	}

	动作
	{
		预加载英雄(事件玩家, 首个(全局.heroList));
		小字体信息(事件玩家, 自定义字符串("  正在重置进度..."));
		等待(2, 当为“假”时中止);
		播放效果(事件玩家, 负面状态施加声音, 空, 所选位置(事件玩家), 100);
		事件玩家.runDeathCount = 0;
		事件玩家.progressionDeathCount = 0;
		事件玩家.isWinner = 假;
		事件玩家.winnerTime = 0;
		事件玩家.heroNumber = 0;
		事件玩家.skipCount = 0;
		小字体信息(所有玩家(所有队伍), 自定义字符串("  {0} 重置了进度", 事件玩家));
		等待(0.016, 无视条件);
		开始强制玩家选择英雄(事件玩家, 首个(全局.heroList));
		等待(0.016, 无视条件);
		停止强制玩家选择英雄(事件玩家);
		调用子程序(savePlayerData);
	}
}

// 禁用 规则("pressing crouch while in the hero change ring makes you the previous available hero")
// {
// 	事件
// 	{
// 		持续 - 每名玩家;
// 		队伍1;
// 		全部;
// 	}

// 	条件
// 	{
// 		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
// 		事件玩家.heroNumber > 0;
// 		相距距离(事件玩家 * 矢量(1, 0, 1), 全局.heroRingPosition * 矢量(1, 0, 1)) <= 1.200;
// 	}

// 	动作
// 	{
// 		If(数组值的索引(全局.heroList, 所用英雄(事件玩家)) < 1);
// 			小字体信息(事件玩家, 自定义字符串("英雄不可用"));
// 		Else;
// 			开始强制玩家选择英雄(事件玩家, 全局.heroList[数组值的索引(全局.heroList, 所用英雄(事件玩家)) - 1]);
// 			停止强制玩家选择英雄(事件玩家);
// 		End;
// 		等待(0.800, 无视条件);
// 		如条件为“真”则循环;
// 	}
// }

规则("3rd person")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		相距距离(事件玩家 * 矢量(1, 0, 1), 全局.thirdPersonPosition * 矢量(1, 0, 1)) <= 1.200;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		存活(事件玩家) == 真;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 无视条件);
		调用子程序(setThirdPerson);
	}
}

规则("springboard")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		单次赋值(全局.springBoardPosition) != 空;
		相距距离(事件玩家 * 矢量(1, 0, 1), 全局.springBoardPosition * 矢量(1, 0, 1)) <= 1.200;
		Y方向分量(所选位置(事件玩家)) >= Y方向分量(全局.springBoardPosition);
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		存活(事件玩家) == 真;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 当为“假”时中止);
		播放效果(所有玩家(所有队伍), 环状爆炸声音, 颜色(白色), 事件玩家, 200);
		施加推力(事件玩家, 上, 14, 至玩家, 取消相反运动XYZ);
		等待(0.032, 无视条件);
		施加推力(事件玩家, 地图矢量(前, 事件玩家, 旋转), 3.500, 至地图, 取消相反运动XYZ);
		等待(5, 无视条件);
	}
}

规则("portalPosition")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		单次赋值(全局.portalPosition) != 空;
		相距距离(事件玩家 * 矢量(1, 0, 1), 首个(全局.portalPosition) * 矢量(1, 0, 1)) <= 1.200;
		Y方向分量(所选位置(事件玩家)) >= Y方向分量(首个(全局.portalPosition));
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		存活(事件玩家) == 真;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 当为“假”时中止);
		播放效果(所有玩家(所有队伍), 环状爆炸声音, 颜色(白色), 事件玩家, 200);
		传送(事件玩家, 最近的可行走位置(最后(全局.portalPosition)));
		等待(5, 无视条件);
	}
}

规则("dev menu in game")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		禁用 (单次赋值(数组包含(全局.devList, 自定义字符串("{0}", 事件玩家))) != 假 || 主机玩家 == 事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		禁用 (所用英雄(事件玩家) == 英雄(生命之梭) || 所用英雄(事件玩家) == 英雄(秩序之光)) == 假;
	}

	动作
	{
		根据条件中止((按钮被按下(事件玩家, 按钮(互动)) && 按钮被按下(事件玩家, 按钮(蹲下))) == 真);
		根据条件跳过(事件玩家.menu != 0, 11);
		禁用按钮(事件玩家, 按钮(主要攻击模式));
		禁用按钮(事件玩家, 按钮(辅助攻击模式));
		禁用按钮(事件玩家, 按钮(技能1));
		禁用按钮(事件玩家, 按钮(技能2));
		禁用按钮(事件玩家, 按钮(终极技能));
		禁用按钮(事件玩家, 按钮(跳跃));
		禁用按钮(事件玩家, 按钮(蹲下));
		禁用按钮(事件玩家, 按钮(近身攻击));
		禁用按钮(事件玩家, 按钮(装填));
		事件玩家.menu = 1;
		中止;
		事件玩家.menu = 0;
		消除HUD文本(事件玩家.menuTextID[0]);
		消除HUD文本(事件玩家.menuTextID[1]);
		消除HUD文本(事件玩家.menuTextID[2]);
		可用按钮(事件玩家, 按钮(主要攻击模式));
		// 根据条件跳过(所用英雄(事件玩家) == 英雄(生命之梭), 1);
		可用按钮(事件玩家, 按钮(辅助攻击模式));
		// 根据条件跳过(所用英雄(事件玩家) == 英雄(美), 4);
		可用按钮(事件玩家, 按钮(技能1));
		// 根据条件跳过(所用英雄(事件玩家) == 英雄(伊拉锐) || 所用英雄(事件玩家) == 英雄(骇灾), 1);
		可用按钮(事件玩家, 按钮(技能2));
		可用按钮(事件玩家, 按钮(终极技能));
		可用按钮(事件玩家, 按钮(跳跃));
		可用按钮(事件玩家, 按钮(近身攻击));
		可用按钮(事件玩家, 按钮(装填));
		// 根据条件中止(所用英雄(事件玩家) == 英雄(破坏球) == 真);
		可用按钮(事件玩家, 按钮(蹲下));
	}
}


规则("dev menu disable")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		禁用 (单次赋值(数组包含(全局.devList, 自定义字符串("{0}", 事件玩家))) != 假 || 主机玩家 == 事件玩家) == 真;
		事件玩家.menu == 0;
	}

	动作
	{
		消除HUD文本(事件玩家.menuTextID[0]);
		消除HUD文本(事件玩家.menuTextID[1]);
		消除HUD文本(事件玩家.menuTextID[2]);
		可用按钮(事件玩家, 按钮(主要攻击模式));
		// 根据条件跳过(所用英雄(事件玩家) == 英雄(生命之梭), 1);
		可用按钮(事件玩家, 按钮(辅助攻击模式));
		// 根据条件跳过(所用英雄(事件玩家) == 英雄(美), 4);
		可用按钮(事件玩家, 按钮(技能1));
		// 根据条件跳过(所用英雄(事件玩家) == 英雄(伊拉锐) || 所用英雄(事件玩家) == 英雄(骇灾), 1);
		可用按钮(事件玩家, 按钮(技能2));
		可用按钮(事件玩家, 按钮(终极技能));
		可用按钮(事件玩家, 按钮(跳跃));
		可用按钮(事件玩家, 按钮(近身攻击));
		可用按钮(事件玩家, 按钮(装填));
		// 根据条件中止(所用英雄(事件玩家) == 英雄(破坏球) == 真);
		可用按钮(事件玩家, 按钮(蹲下));
	}
}

// 禁用 规则("page up in dev menu")
// {
// 	事件
// 	{
// 		持续 - 每名玩家;
// 		双方;
// 		全部;
// 	}

// 	条件
// 	{
// 		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
// 		事件玩家.isDev == 真;
// 		事件玩家.menu != 0;
// 	}

// 	动作
// 	{
// 		事件玩家.menu += 1;
// 		中止;
// 		事件玩家.menu = 4;
// 	}
// }

规则("page down in dev menu")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		事件玩家.menu != 0;
	}

	动作
	{
		根据条件跳过(事件玩家.menu >= 3, 2);
		事件玩家.menu += 1;
		中止;
		事件玩家.menu = 1;
	}
}

规则("menu mode settings display")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.menu == 1;
		禁用 (单次赋值(数组包含(全局.devList, 自定义字符串("{0}", 事件玩家))) != 假 || 主机玩家 == 事件玩家) == 真;
	}

	动作
	{
		消除HUD文本(事件玩家.menuTextID[0]);
		消除HUD文本(事件玩家.menuTextID[1]);
		消除HUD文本(事件玩家.menuTextID[2]);
		创建HUD文本(事件玩家, 自定义字符串("{0}", 事件玩家.isDev ? 自定义字符串("开发者模式") : 自定义字符串("游戏内面板")), 空, 空, 顶部, 2, 颜色(白色), 颜色(白色), 颜色(白色), 可见，字符串和颜色,
			始终不可见);
		事件玩家.menuTextID[0] = 上一个文本ID;
		IF(事件玩家.isDev);
			创建HUD文本(事件玩家, 空, 自定义字符串("{0}    自动重开：延长5分钟    \n{1}", 输入绑定字符串(按钮(主要攻击模式)), 
				自定义字符串("{0}    自动重开：缩短5分钟    \n{1}", 输入绑定字符串(按钮(辅助攻击模式)),
					自定义字符串("{0}    上一个称号    \n{1}", 输入绑定字符串(按钮(终极技能)), 
						自定义字符串("{0}    下一个称号    \n{1}", 输入绑定字符串(按钮(技能2)),
							自定义字符串("{0}    增加难度    \n{1}", 输入绑定字符串(按钮(技能1)),
								自定义字符串("{0}    降低难度    \n{1}", 输入绑定字符串(按钮(装填)),
									自定义字符串("{0}    第三人称视角    {1}\n{2}", 输入绑定字符串(按钮(跳跃)), 事件玩家.third == 真 ? 自定义字符串("O") : 自定义字符串("X"),
										自定义字符串("{0}    下一页    ", 输入绑定字符串(按钮(蹲下)))
									)
								)
							)
						)
					)
				)
			), 空, 顶部, 3, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
		ELSEIF(主机玩家 == 事件玩家);
			创建HUD文本(事件玩家, 空, 自定义字符串("{0}    自动重开：延长5分钟    \n{1}", 输入绑定字符串(按钮(主要攻击模式)), 
				自定义字符串("{0}    自动重开：缩短5分钟    \n{1}", 输入绑定字符串(按钮(辅助攻击模式)),
					自定义字符串("{0}    上一个称号    \n{1}", 输入绑定字符串(按钮(终极技能)), 
						自定义字符串("{0}    下一个称号    \n{1}", 输入绑定字符串(按钮(技能2)),
							自定义字符串("{0}    第三人称视角    {1}\n", 输入绑定字符串(按钮(跳跃)), 事件玩家.third == 真 ? 自定义字符串("O") : 自定义字符串("X"),
								自定义字符串("{0}    下一页    ", 输入绑定字符串(按钮(蹲下)))
							)
						)
					)
				)
			), 空, 顶部, 3, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
		ELSEIF(数量(事件玩家.playerTitles) > 0);
			创建HUD文本(事件玩家, 空, 自定义字符串("{0}    上一个称号    \n{1}", 输入绑定字符串(按钮(终极技能)), 
				自定义字符串("{0}    下一个称号    \n{1}", 输入绑定字符串(按钮(技能2)),
					自定义字符串("{0}    第三人称视角    {1}\n", 输入绑定字符串(按钮(跳跃)), 事件玩家.third == 真 ? 自定义字符串("O") : 自定义字符串("X"),
						自定义字符串("{0}    下一页    ", 输入绑定字符串(按钮(蹲下)))
					)
				)
			), 空, 顶部, 3, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
		END;
		事件玩家.menuTextID[1] = 上一个文本ID;
	}
}

规则("menu dev control display")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 2;
	}

	动作
	{
		消除HUD文本(事件玩家.menuTextID[0]);
		消除HUD文本(事件玩家.menuTextID[1]);
		消除HUD文本(事件玩家.menuTextID[2]);
		创建HUD文本(事件玩家, 自定义字符串("开发者模式"), 空, 空, 顶部, 2, 颜色(白色), 颜色(白色), 颜色(白色), 可见，字符串和颜色,
			始终不可见);
		事件玩家.menuTextID[0] = 上一个文本ID;
		创建HUD文本(事件玩家, 空, 自定义字符串("{0}    Debug 信息    {1}\n{2}", 输入绑定字符串(按钮(主要攻击模式)), 全局.debugInfo ? 自定义字符串("O") : 自定义字符串("X"), 
			自定义字符串("{0}    解锁全英雄    {1}\n{2}", 输入绑定字符串(按钮(辅助攻击模式)), 事件玩家.isWinner == 真 ? 自定义字符串("O") : 自定义字符串("X"), 
				自定义字符串("{0}    立即重开    \n{1}", 输入绑定字符串(按钮(装填)), 
					自定义字符串("{0}    标记玩家    {1}\n{2}", 输入绑定字符串(按钮(跳跃)), 全局.targetPlayer != 空 ? 自定义字符串("{0}（{1}）", 全局.targetPlayer, 所用英雄(全局.targetPlayer)) : 自定义字符串("空"),
						自定义字符串("{0}    移除标记玩家    \n{1}", 输入绑定字符串(按钮(终极技能)),
							自定义字符串("{0}    传送到标记玩家    \n{1}", 输入绑定字符串(按钮(技能2)),
								自定义字符串("{0}    受到伤害降低    {1}\n{2}", 输入绑定字符串(按钮(近身攻击)), 事件玩家.dmgReduc == 真 ? 自定义字符串("O") : 自定义字符串("X"),
									自定义字符串("{0}    无敌    {1}\n{2}", 输入绑定字符串(按钮(技能1)), 事件玩家.invincible == 真 ? 自定义字符串("O") : 自定义字符串("X"),
										自定义字符串("{0}    下一页    ", 输入绑定字符串(按钮(蹲下)))
									)
								)
							)
						)
					)
				)
			)
		), 空, 顶部, 3, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
		事件玩家.menuTextID[1] = 上一个文本ID;
	}
}

规则("menu dev devlop display")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 3;
	}

	动作
	{
		消除HUD文本(事件玩家.menuTextID[0]);
		消除HUD文本(事件玩家.menuTextID[1]);
		消除HUD文本(事件玩家.menuTextID[2]);
		创建HUD文本(事件玩家, 自定义字符串("开发者面板"), 空, 空, 顶部, 2, 颜色(白色), 颜色(白色), 颜色(白色), 可见，字符串和颜色,
			始终不可见);
		事件玩家.menuTextID[0] = 上一个文本ID;
		创建HUD文本(事件玩家, 空, 自定义字符串("{0}    浮空    {1}\n{2}", 输入绑定字符串(按钮(主要攻击模式)), 事件玩家.isAirWalkEnabled ? 自定义字符串("O") : 自定义字符串("X"), 
			自定义字符串("{0}    穿墙    {1}\n{2}", 输入绑定字符串(按钮(辅助攻击模式)), 事件玩家.isPortalEnabled == 真 ? 自定义字符串("O") : 自定义字符串("X"), 
				自定义字符串("{0}    选择目标点索引    {1}\n{2}", 输入绑定字符串(按钮(技能1)), 事件玩家.controlCenterIndex,
					自定义字符串("{0}    传送到目标点    \n{1}", 输入绑定字符串(按钮(技能2)),
						自定义字符串("{0}    下一页    ", 输入绑定字符串(按钮(蹲下)))
					)
				)
			)
		), 空, 顶部, 3, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 始终不可见);
		事件玩家.menuTextID[1] = 上一个文本ID;
	}
}

规则("3rd camera toggle")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		禁用 事件玩家.isDev == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		事件玩家.menu == 1;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 无视条件);
		调用子程序(setThirdPerson);
	}
}

规则("dev debug mode toggle")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
		事件玩家.menu == 2;
	}

	动作
	{
		全局.debugInfo = !全局.debugInfo;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		// 事件玩家.debugInfo = !事件玩家.debugInfo;
		全局.devPlayer.debugInfo = 全局.debugInfo;
	}
}

规则("dev set difficulty")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.difficulty < 5;
		事件玩家.menu == 1;
		事件玩家.isDev == 真;
		按钮被按下(事件玩家, 按钮(技能1)) == 真;
	}

	动作
	{
		全局.difficulty += 1;
		调用子程序(setDifficulty);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		// 全局.hashTag = 假;
		小字体信息(全局.devPlayer, 自定义字符串("  {0}  开发者模式： 已将难度设置为 {1}({2})", 图标字符串(箭矢), 首个(全局.difficultyText), 全局.difficulty));
		// 等待(服务器负载 / 100 * 0.032, 无视条件);
		// 小字体信息(全局.devPlayer, 自定义字符串("  {0}  成就挑战已禁用", 图标字符串(警告)));
	}
}

规则("dev set difficulty")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.difficulty > 0;
		事件玩家.menu == 1;
		事件玩家.isDev == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
	}

	动作
	{
		全局.difficulty -= 1;
		调用子程序(setDifficulty);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		小字体信息(全局.devPlayer, 自定义字符串("  {0}  开发者模式： 已将难度设置为 {1}({2})", 图标字符串(箭矢), 首个(全局.difficultyText), 全局.difficulty));
	}
}

规则("dev add auto reboot time")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.menu == 1;
		(事件玩家.isDev || 主机玩家 == 事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
	}

	动作
	{
		If(全局.rebootTime + 300 <= 15900);
			全局.rebootTime += 300;
			IF(事件玩家.isDev);
				小字体信息(全局.devPlayer, 自定义字符串("  {0}  开发者模式： 已将自动重开时间延长 {1} 分钟", 图标字符串(箭矢), 300 / 60));
			Else;
				小字体信息(所有玩家(所有队伍), 自定义字符串("  {0}  模式调整： 房主已将自动重开时间延长 {1} 分钟", 图标字符串(箭矢), 300 / 60));
			End;
	}
}

规则("dev remove auto reboot time")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.menu == 1;
		(事件玩家.isDev || 主机玩家 == 事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
	}

	动作
	{
		禁用 等待(0.160, 当为“假”时中止);
		If(全局.rebootTime - 300 >= 300);
			全局.rebootTime -= 300;
			IF(事件玩家.isDev);
				小字体信息(全局.devPlayer, 自定义字符串("  {0}  开发者模式： 已将自动重开时间缩短 {1} 分钟", 图标字符串(箭矢), 300 / 60));
			Else;
				小字体信息(所有玩家(所有队伍), 自定义字符串("  {0}  模式调整： 房主已将自动重开时间缩短 {1} 分钟", 图标字符串(箭矢), 300 / 60));
			End;
	}
}

规则("player title menu - next")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.menu == 1;
		禁用 事件玩家.isDev == 真;
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		数量(事件玩家.playerTitles) > 0;
	}

	动作
	{
		禁用 等待(0.160, 当为“假”时中止);
		If(事件玩家.playerTitleIndex == 空);
			事件玩家.playerTitleIndex = 0;
		End;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		事件玩家.playerTitleIndex = (事件玩家.playerTitleIndex + 1) % 数量(事件玩家.playerTitles);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		// 停止追踪玩家变量(事件玩家, rgb_vect);
		// 等待(服务器负载 / 100 * 0.032, 无视条件);
		事件玩家.playerTitleAndColor = 数组(首个(事件玩家.playerTitles[事件玩家.playerTitleIndex]), 最后(事件玩家.playerTitles[事件玩家.playerTitleIndex]));
		等待(0.016, 无视条件);
		IF(事件玩家.playerTitleAndColor[1] == 空 && 数量(事件玩家.playerTitleAndColor[1]) == 0);
			停止追踪玩家变量(事件玩家, rgb_vect);
			事件玩家.info_pvar = 0;
			事件玩家.rgb_vect = 全局.rgbList[首个(事件玩家.info_pvar)];
			事件玩家.rgb_activated = 真;
		ELSEIF(事件玩家.playerTitleAndColor[1] != 空 && 数量(事件玩家.playerTitleAndColor[1]) >= 1);
			停止追踪玩家变量(事件玩家, rgb_vect);
			事件玩家.info_pvar = 0;
			事件玩家.rgb_vect = 首个(事件玩家.playerTitleAndColor[1]);
			事件玩家.rgb_activated = 真;
		ELSE;
			事件玩家.rgb_vect = 事件玩家.playerTitleAndColor[1];
			事件玩家.rgb_activated = 假;
		END;
		// IF(事件玩家.isDev && 事件玩家.playerTitleAndColor[1] == 空);
		// 	事件玩家.playerTitleAndColor[1] = 全局.rgbList;
		// 	事件玩家.rgb_vect = 全局.rgbList[首个(事件玩家.info_pvar)];
		// END;
		小字体信息(事件玩家, 自定义字符串("  {0}  已将称号更改为 {1}", 图标字符串(箭矢), 首个(事件玩家.playerTitles[事件玩家.playerTitleIndex])));
		等待(服务器负载 / 100 * 0.032, 无视条件);
	}
}

规则("player title menu - previous")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}
	
	条件
	{
		事件玩家.menu == 1;
		禁用 事件玩家.isDev == 真;
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		数量(事件玩家.playerTitles) > 0;
	}

	动作
	{
		禁用 等待(0.160, 当为“假”时中止);
		If(事件玩家.playerTitleIndex == 空 || 事件玩家.playerTitleIndex <= 0);
			事件玩家.playerTitleIndex = 数量(事件玩家.playerTitles);
		End;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		事件玩家.playerTitleIndex -= 1;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		// 停止追踪玩家变量(事件玩家, rgb_vect);
		事件玩家.playerTitleAndColor = 数组(首个(事件玩家.playerTitles[事件玩家.playerTitleIndex]), 最后(事件玩家.playerTitles[事件玩家.playerTitleIndex]));
		等待(0.016, 无视条件);
		IF(事件玩家.playerTitleAndColor[1] == 空 && 数量(事件玩家.playerTitleAndColor[1]) == 0);
			停止追踪玩家变量(事件玩家, rgb_vect);
			事件玩家.info_pvar = 0;
			事件玩家.rgb_vect = 全局.rgbList[首个(事件玩家.info_pvar)];
			事件玩家.rgb_activated = 真;
		ELSEIF(事件玩家.playerTitleAndColor[1] != 空 && 数量(事件玩家.playerTitleAndColor[1]) >= 1);
			停止追踪玩家变量(事件玩家, rgb_vect);
			事件玩家.info_pvar = 0;
			事件玩家.rgb_vect = 首个(事件玩家.playerTitleAndColor[1]);
			事件玩家.rgb_activated = 真;
		ELSE;
			事件玩家.rgb_vect = 事件玩家.playerTitleAndColor[1];
			事件玩家.rgb_activated = 假;
		END;
		// 事件玩家.rgb_vect = 事件玩家.playerTitleAndColor[1] != 空 && 数量(事件玩家.playerTitleAndColor[1]) <= 1 ? 首个(事件玩家.playerTitleAndColor[1]) : 全局.rgbList[首个(事件玩家.info_pvar)];
		// 根据条件跳过(数量(事件玩家.playerTitleAndColor[1]) <= 1, 2);
		// 事件玩家.rgb_activated = 数量(事件玩家.playerTitleAndColor[1]) <= 1 ? 假 : 真;
		// IF(事件玩家.isDev && 事件玩家.playerTitleAndColor[1] == 空);
		// 	事件玩家.playerTitleAndColor[1] = 全局.rgbList;
		// 	事件玩家.rgb_vect = 全局.rgbList[首个(事件玩家.info_pvar)];
		// END;
		小字体信息(事件玩家, 自定义字符串("  {0}  已将称号更改为 {1}", 图标字符串(箭矢), 首个(事件玩家.playerTitleAndColor)));
		等待(服务器负载 / 100 * 0.032, 无视条件);
	}
}

规则("dev reboot")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.menu == 2;
		事件玩家.isDev == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
	}

	动作
	{
		小字体信息(全局.devPlayer, 自定义字符串("  {0}  开发者模式： 长按 {1} 进行重启", 图标字符串(箭矢), 输入绑定字符串(按钮(装填))));
		等待(2, 当为“假”时中止);
		小字体信息(全局.devPlayer, 自定义字符串("  {0}  开发者模式： 正在重启...", 图标字符串(箭矢)));
		等待(2, 当为“假”时中止);
		重新开始比赛;
	}
}

规则("dev set target player")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 2;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
	}

	动作
	{
		If(全局.targetPlayerIndex == 空 || 全局.targetPlayerIndex >= 数量(已排序的数组(所有玩家(队伍1), 当前数组元素)));
			全局.targetPlayerIndex = 0;
			等待(服务器负载 / 100 * 0.032, 无视条件);
		End;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		全局.targetPlayer = 已排序的数组(所有玩家(队伍1), 当前数组元素.joinTime)[全局.targetPlayerIndex];
		全局.targetPlayerIndex += 1;
		// 根据条件跳过(全局.targetPlayer == 空 || 全局.targetPlayer == 0, 1);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		小字体信息(全局.devPlayer, 全局.targetPlayer == 空 ? 自定义字符串("  {0}  没有可标记的玩家", 图标字符串(箭矢)) : 自定义字符串("  {0}  开发者模式： 已标记 {1}（{2}）", 图标字符串(箭矢), 全局.targetPlayer, 所用英雄(全局.targetPlayer)));
	}
}

规则("dev remove target player")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 2;
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
	}

	动作
	{
		根据条件中止(全局.targetPlayer == 空 || 数组包含(全局.devPlayer, 全局.targetPlayer));
		小字体信息(全局.devPlayer, 自定义字符串("  {0}  开发者模式： 长按 {1} 移除 {2}", 图标字符串(箭矢), 输入绑定字符串(按钮(终极技能)), 全局.targetPlayer));
		等待(2, 当为“假”时中止);
		小字体信息(全局.devPlayer, 自定义字符串("  {0}  开发者模式： 即将移除玩家 {1}", 图标字符串(箭矢), 全局.targetPlayer));
		等待(1, 当为“假”时中止);
		小字体信息(全局.devPlayer, 自定义字符串("  {0}  开发者模式： 已移除玩家 {1}", 图标字符串(箭矢), 全局.targetPlayer));
		移除玩家(全局.targetPlayer);
		全局.targetPlayerIndex = 0;
		全局.targetPlayer = 空;
	}
}

规则("dev set dmg reduction")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 2;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		// 事件玩家.isWinner == 假;
	}

	动作
	{
		事件玩家.dmgReduc = !事件玩家.dmgReduc;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		If(事件玩家.dmgReduc);
			设置受到伤害(事件玩家, 1);
			创建效果(所有玩家(所有队伍), 安娜纳米激素强化效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
			事件玩家.nanoEffect = 最后创建的实体;
			小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 已将伤害减免设置为 -{1}%", 图标字符串(箭矢), 99));
		Else;
			设置受到伤害(事件玩家, 100);
			消除效果(事件玩家.nanoEffect);
			小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 已取消伤害减免", 图标字符串(箭矢)));
		End;
	}
}

规则("dev set invincible")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 2;
		按钮被按下(事件玩家, 按钮(技能1)) == 真;
		// 事件玩家.isWinner == 假;
	}

	动作
	{
		事件玩家.invincible = !事件玩家.invincible;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		IF(事件玩家.invincible);
			设置状态(事件玩家, 空, 无敌, 999999986991104.000);
			创建效果(所有玩家(所有队伍), 巴蒂斯特维生力场保护效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
			事件玩家.invincibleEffect = 最后创建的实体;
			小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 已设置为无敌状态", 图标字符串(箭矢)));
		ELSE;
			清除状态(事件玩家, 无敌);
			消除效果(事件玩家.invincibleEffect);
			小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 已取消无敌状态", 图标字符串(箭矢)));
	}
}

规则("dev air walk toggle")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
		事件玩家.menu == 3;
	}

	动作
	{
		根据条件跳过(事件玩家.isAirWalkEnabled == 真, 4);
		设置引力(事件玩家, 0);
		事件玩家.isAirWalkEnabled = 真;
		小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 已开启浮空", 图标字符串(箭矢)));
		中止;
		设置引力(事件玩家, 100);
		事件玩家.isAirWalkEnabled = 假;
		小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 已关闭浮空", 图标字符串(箭矢)));
	}
}

规则("dev air lock")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.isAirWalkEnabled == 真;
		阈值(事件玩家) == 矢量(0, 0, 0);
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
	}

	动作
	{
		施加推力(事件玩家, 上, 0.001, 至地图, 取消相反运动);
		施加推力(事件玩家, 速率(事件玩家) * -1, 0.001, 至地图, 取消相反运动);
	}
}

规则("dev portal toggle")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 3;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
	}

	动作
	{
		根据条件跳过(事件玩家.isPortalEnabled == 真, 3);
		事件玩家.isPortalEnabled = 真;
		小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 已开启穿墙", 图标字符串(箭矢)));
		中止;
		事件玩家.isPortalEnabled = 假;
		小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 已关闭穿墙", 图标字符串(箭矢)));
	}
}

规则("dev R portal")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 0;
		事件玩家.isPortalEnabled == 真;
		存活(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		正在使用表情交流(事件玩家) == 假;
		(当前地图 == 地图(“地平线”月球基地) && 相距距离(事件玩家, 矢量(-9.380, 8.740, 2.050)) < 1) == 假;
	}

	动作
	{
		设置引力(事件玩家, 绝对值(0));
		根据条件跳过(按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真, 2);
		传送(事件玩家, 所选位置(事件玩家) + 面朝方向(事件玩家) * 4);
		跳过(1);
		传送(事件玩家, 所选位置(事件玩家) + 面朝方向(事件玩家) * 20);
		等待(0.160, 无视条件);
		如条件为“真”则循环;
		根据条件中止(事件玩家.isAirWalkEnabled == 真);
		设置引力(事件玩家, 绝对值(100));
	}
}

规则("dev pick control center Position")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 3;
		按钮被按下(事件玩家, 按钮(技能1)) == 真;
	}

	动作
	{
		If(全局.controlCenterPosition == 空);
			小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 目标点坐标为空", 图标字符串(箭矢)));
			中止;
		Else;
			根据条件跳过(事件玩家.controlCenterIndex >= 2, 3);
			事件玩家.controlCenterIndex += 1;
			小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 已选择目标点坐标：{1}", 图标字符串(箭矢), 全局.controlCenterPosition[事件玩家.controlCenterIndex]));
			中止;
			事件玩家.controlCenterIndex = 0;
			小字体信息(事件玩家, 自定义字符串("  {0}  开发者模式： 已选择目标点坐标：{1}", 图标字符串(箭矢), 全局.controlCenterPosition[事件玩家.controlCenterIndex]));
		End;
	}
}

规则("dev to control center Position")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 3;
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		全局.controlCenterPosition != 空;
	}

	动作
	{
		传送(事件玩家, 最近的可行走位置(全局.controlCenterPosition[事件玩家.controlCenterIndex]));
	}
}

规则("dev to Target Player Position")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		事件玩家.menu == 2;
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		全局.targetPlayer != 空;
	}

	动作
	{
		传送(事件玩家, 最近的可行走位置(所选位置(全局.targetPlayer) - 矢量(0, 0, -1)));
		// 传送(事件玩家, 最近的可行走位置(所选位置(全局.targetPlayer) - 地图矢量(矢量(0, 0, 7), 事件玩家, 旋转)));
		设置朝向(事件玩家, 面朝方向(全局.targetPlayer), 至地图);
	}
}

规则("when a player joins, load player data if they have it and initialize them")
{
	事件
	{
		玩家加入比赛;
		队伍1;
		全部;
	}

	动作
	{
		事件玩家.isDev = 单次赋值(数组包含(全局.devList, 自定义字符串("{0}", 事件玩家)));
		根据条件跳过(!单次赋值(全局.dlcVishkarEvent),2);
		事件玩家.eventId = -1;
		事件玩家.sizeHealth = 1;
		等待(服务器负载 / 200 * 随机实数(1, 3), 无视条件);
		// IF(事件玩家.joinTime == 空 || 事件玩家.joinTime == 0);
		// 	// 事件玩家.joinTime = 总计消耗时间;
		// 	// 全局.savedJoinTime[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.joinTime;
		// 	等待(服务器负载 / 100 * 0.032, 无视条件);
		// 	事件玩家.joinTime = 全局.savedJoinTime[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] == 空 ? 单次赋值(总计消耗时间) : 全局.savedJoinTime[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
		// 	// 全局.savedJoinTime[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.joinTime;
		// End;
		If(数组包含(全局.savedIndex, 自定义字符串("{0}", 事件玩家)));
			事件玩家.heroNumber = 全局.savedHero[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			等待(服务器负载 / 100 * 0.032, 无视条件);
			事件玩家.runDeathCount = 全局.savedDeaths[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			等待(服务器负载 / 100 * 0.032, 无视条件);
			事件玩家.isWinner = 全局.savedIsWinner[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			等待(服务器负载 / 100 * 0.032, 无视条件);
			事件玩家.skipCount = 全局.savedSkipCount[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			等待(服务器负载 / 100 * 0.032, 无视条件);
			事件玩家.winnerTime = 全局.savedWinnerTime[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			等待(服务器负载 / 100 * 0.032, 无视条件);
			事件玩家.A36TGrenade = 全局.savedA36TGrenade[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			等待(服务器负载 / 100 * 0.032, 无视条件);
			事件玩家.A36TGrenadeHit = 全局.savedA36TGrenadeHit[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			等待(服务器负载 / 100 * 0.032, 无视条件);
			事件玩家.A36TGrenadeDmg = 全局.savedA36TGrenadeDmg[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			等待(服务器负载 / 100 * 0.032, 无视条件);
			事件玩家.A36TGrenadeAlive = 全局.savedA36TGrenadeAlive[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			事件玩家.joinTime = 全局.savedJoinTime[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
		ELSE;
			事件玩家.joinTime = 单次赋值(总计消耗时间);
		End;
		事件玩家.dmgReduc = 假;
		事件玩家.invincible = 假;
		// IF(单次赋值(数组包含(全局.devList, 自定义字符串("{0}", 事件玩家))));
		// 	事件玩家.debugInfo = 全局.debugInfo;
		// END;
		开始强制玩家选择英雄(事件玩家, 全局.heroList[事件玩家.heroNumber]);
		停止强制玩家选择英雄(事件玩家);
		设置玩家可选的英雄(事件玩家, 数组分割(全局.heroList, 0, 事件玩家.heroNumber + 1));
		等待(6, 无视条件);
		// 事件玩家.playerTitles = 已过滤的数组(全局.allTitle, 数量(当前数组元素) > 0 && 当前数组元素[0] == 自定义字符串("{0}", 事件玩家));
		// IF(数量(事件玩家.playerTitles) > 0);
		// 	事件玩家.playerTitleAndColor = 数组(最后(事件玩家.playerTitles)[1], 最后(事件玩家.playerTitles)[2]);
		// END;
		IF(数组包含(全局.titlePlayer, 自定义字符串("{0}", 事件玩家)));
			事件玩家.playerTitleRelationIndex = 数组值的索引(全局.titlePlayer, 自定义字符串("{0}", 事件玩家));
			调用子程序(setPlayerTitle);
			等待(0.032, 无视条件);
			小字体信息(事件玩家, 自定义字符串("  称号已加载"));
			事件玩家.playerTitleAndColor = 数组(首个(最后(事件玩家.playerTitles)), 最后(最后(事件玩家.playerTitles)));
			事件玩家.rgb_vect = 事件玩家.playerTitleAndColor[1] != 空 ? 首个(事件玩家.playerTitleAndColor[1]) : 全局.rgbList[首个(事件玩家.info_pvar)];
		END;
		事件玩家.obstrucVis = 空数组;
		根据条件跳过(全局.controlRespawnPosition == 空 || 全局.portalPosition != 空,1);
		小字体信息(事件玩家, 自定义字符串("  通过第一个传送点可以按 {0} 使用存档点功能（单英雄仅限一次）", 按钮(装填)));
		If(数组包含(全局.savedIndex, 自定义字符串("{0}", 事件玩家)));
			小字体信息(事件玩家, 自定义字符串("  你的进度已成功加载"));
			小字体信息(从数组中移除(所有玩家(所有队伍), 事件玩家), 自定义字符串("  {0} 载入 {1}{2}", 事件玩家, 英雄图标字符串(全局.heroList[事件玩家.heroNumber]), 全局.heroList[事件玩家.heroNumber]));
	}
}

规则("initialize player title")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		存活(事件玩家) == 真;
		事件玩家.playerTitleAndColor != 空;
		事件玩家.titleTextID == 空;
	}

	动作
	{
		等待(栏位(事件玩家) * 0.080, 无视条件);
		// If(单次赋值(数组包含(全局.devList, 自定义字符串("{0}", 事件玩家))));
			事件玩家.info_pvar = 0;
		// 	事件玩家.rgb_vect = 全局.rgbList[首个(事件玩家.info_pvar)];
			创建地图文本(已过滤的数组(所有玩家(所有队伍), 在视线内(事件玩家, 当前数组元素, 屏障不会阻挡视线)), 自定义字符串("{0}{1}", 事件玩家.isDev ? 技能图标字符串(英雄(托比昂), 按钮(技能2)) : 自定义字符串(""), 事件玩家.playerTitleAndColor[0]), 事件玩家, 事件玩家.isDev ? 1 : 0.800, 不要截取, 可见，位置，字符串和颜色, 自定义颜色(X方向分量(
				事件玩家.rgb_vect), Y方向分量(事件玩家.rgb_vect), Z方向分量(事件玩家.rgb_vect), 255), 默认可见度);
		// Else;
			// 创建地图文本(已过滤的数组(所有玩家(所有队伍), 在视线内(事件玩家, 当前数组元素, 屏障不会阻挡视线)), 事件玩家.playerTitleAndColor[0], 事件玩家, 0.800, 不要截取, 可见，位置，字符串和颜色,
			// 	事件玩家.playerTitleAndColor[1], 默认可见度);
		// End;
		事件玩家.titleTextID = 上一个文本ID;
	}
}

规则("update title color")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.isDev == 真;
		全局.antiCrashActivated == 假;
		事件玩家.playerTitleAndColor[1] == 空;
		数量(事件玩家.playerTitleAndColor[1]) == 0;
		// 事件玩家.rgb_activated == 真;
	}

	动作
	{
		等待(0.016, 当为“假”时中止);
		事件玩家.info_pvar = (事件玩家.info_pvar + 1) % 数量(全局.rgbList);
		持续追踪玩家变量(事件玩家, rgb_vect, 全局.rgbList[事件玩家.info_pvar], 1.500, 全部禁用);
		等待直到 (事件玩家.rgb_vect == 全局.rgbList[事件玩家.info_pvar], 999999986991104.000);
		如条件为“真”则循环;
		停止追踪玩家变量(事件玩家, rgb_vect);
		事件玩家.info_pvar = 0;
		// 事件玩家.rgb_vect = 首个(事件玩家.playerTitleAndColor[1]);
	}
}

规则("update title color")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		// 事件玩家.isDev == 真;
		全局.antiCrashActivated == 假;
		事件玩家.playerTitleAndColor[1] != 空;
		数量(事件玩家.playerTitleAndColor[1]) > 1;
		事件玩家.rgb_activated == 真;
	}

	动作
	{
		等待(0.016, 当为“假”时中止);
		事件玩家.info_pvar = (事件玩家.info_pvar + 1) % 数量(事件玩家.playerTitleAndColor[1]);
		持续追踪玩家变量(事件玩家, rgb_vect, 事件玩家.playerTitleAndColor[1][事件玩家.info_pvar], 2.500, 全部禁用);
		等待直到 (事件玩家.rgb_vect == 事件玩家.playerTitleAndColor[1][事件玩家.info_pvar] || !事件玩家.rgb_activated, 999999986991104.000);
		如条件为“真”则循环;
		等待(0.016, 无视条件);
		停止追踪玩家变量(事件玩家, rgb_vect);
		事件玩家.info_pvar = 0;
		事件玩家.rgb_vect = 首个(事件玩家.playerTitleAndColor[1]);
	}
}

规则("Dev b﻿ackdoor to release heros")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		单次赋值(数组包含(全局.devList, 自定义字符串("{0}", 事件玩家))) != 假;
		事件玩家.menu == 2;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
		事件玩家.isWinner == 假;
	}

	动作
	{
		If(事件玩家.heroNumber < 数量(全局.heroList) - 1);
			事件玩家.heroNumber = 数量(全局.heroList) - 1;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			设置玩家可选的英雄(事件玩家, 数组分割(全局.heroList, 0, 事件玩家.heroNumber + 1));
			等待(服务器负载 / 100 * 0.500, 无视条件);
			小字体信息(事件玩家, 自定义字符串("  {0} 开发者模式：已解锁全英雄", 图标字符串(箭矢)));
			禁用 调用子程序(savePlayerData);
		Else If(事件玩家.isWinner == 假);
			事件玩家.isWinner = 真;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			小字体信息(事件玩家, 自定义字符串("  {0} 开发者模式：已通关", 图标字符串(箭矢)));
	}
}

规则("auto reboot")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		总计消耗时间 >= 全局.rebootTime - 60;
	}

	动作
	{
		大字体信息(所有玩家(所有队伍), 自定义字符串("游戏将在 1 分钟后自动重开"));
		等待(60, 无视条件);
		重新开始比赛;
	}
}

规则("[debug.opy]: player debug (Top Right)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		单次赋值(事件玩家.debugInfo) == 真;
		单次赋值(数组包含(全局.devList, 自定义字符串("{0}", 事件玩家))) != 假;
	}

	动作
	{
		创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("难度 = {0}", 首个(全局.difficultyText)), 空, 右边, 10, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("当前位置 = {0}", 所选位置(事件玩家)), 空, 右边, 26, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("当前速度 = {0}", 速度(事件玩家)), 空, 右边, 27, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("当前速率 = {0}", 速率(事件玩家)), 空, 右边, 28, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("当前地图 = {0}/{1}", 全局.__currentMap__, 当前地图), 空, 右边, 29, 空, 颜色(白色), 空, 可见和字符串,
			始终不可见);
		创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("重生室位置 = {0}", 所选位置(重生点(队伍1))), 空, 右边, 30, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		禁用 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("重生室距离 X = {0}/{1}/{2}", X方向分量(所选位置(事件玩家)), X方向分量(首个(全局.controlRespawnPosition)), 相距距离(矢量(X方向分量(所选位置(事件玩家)),
			0, 0), 矢量(Y方向分量(首个(全局.controlRespawnPosition)), 0, 0))), 空, 右边, 31, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		禁用 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("重生室距离 Y = {0}/{1}/{2}", Y方向分量(所选位置(事件玩家)), Y方向分量(首个(全局.controlRespawnPosition)), 相距距离(矢量(0,
			Y方向分量(所选位置(事件玩家)), 0), 矢量(0, Y方向分量(首个(全局.controlRespawnPosition)), 0))), 空, 右边, 32, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		禁用 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("重生室距离 Z = {0}/{1}/{2}", Z方向分量(所选位置(事件玩家)), Z方向分量(首个(全局.controlRespawnPosition)), 相距距离(矢量(0,
			0, Z方向分量(所选位置(事件玩家))), 矢量(0, 0, Z方向分量(首个(全局.controlRespawnPosition))))), 空, 右边, 33, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		// 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("转向速度 = {0}", 首个(已排序的数组(所有玩家(队伍2), 相距距离(事件玩家, 当前数组元素))).turnSpeed), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("当前事件 = {0}/{1}", 本地玩家.eventName, 本地玩家.eventId), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("上一个事件 = {0}/{1}", 首个(全局.buffEvent[本地玩家.eventLastId]), 本地玩家.eventLastId), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("随机取值 = {0}/{1}", 数组值的索引(全局.buffEvent, 数组随机取值(已过滤的数组(全局.buffEvent, 当前数组元素 != 空))), 数组随机取值(已过滤的数组(全局.buffEvent, 当前数组元素 != 空))), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		
		// 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("开发者RGB = {0}", 事件玩家.playerTitleAndColor[1] == 空), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		// 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("称号颜色组 = {0}", 数量(事件玩家.playerTitleAndColor[1])), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		// 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("称号变色效果 = {0}", 事件玩家.rgb_activated), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		// 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("称号颜色 = {0}", 首个(事件玩家.playerTitleAndColor[1])), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		// 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("当前称号颜色 = {0}", 事件玩家.rgb_vect), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
		// 创建HUD文本(事件玩家.debugInfo == 真 ? 事件玩家 : 空, 空, 自定义字符串("当前称号XYZ = {0}/{1}/{2}", X方向分量(
		// 		事件玩家.rgb_vect), Y方向分量(事件玩家.rgb_vect), Z方向分量(事件玩家.rgb_vect)), 空, 右边, 34, 空, 颜色(白色), 空, 可见和字符串, 始终不可见);
	}
}

禁用 规则("未经原作者许可，任何人不得将以下代码进行二次创作与发布")
{
	事件
	{
		持续 - 全局;
	}
}

规则("[VishkarEvent]: 疾风祝福")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 0;
		事件玩家.eventId == 1;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 无视条件);
		// 调用子程序(setEventDuration);
		创建效果(所有玩家(所有队伍), “士兵：76”疾跑效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
		事件玩家.eventEffect = 最后创建的实体;
		事件玩家.mov_speed_buff = 50;
		调用子程序(setPlayerMovSpeed);
		等待(事件玩家.eventDuration, 无视条件);
		事件玩家.mov_speed_buff *= 0;
		调用子程序(setPlayerMovSpeed);
		消除效果(事件玩家.eventEffect);
		事件玩家.eventEffect = 空;
	}
}

规则("[VishkarEvent]: 钢铁防线")
// 规则("[VishkarEvent]: 纳米战甲")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 0;
		事件玩家.eventId == 2;
		事件玩家.healthId[1] == 空;
	}

	动作
	{
		等待(0.032, 无视条件);
		// 调用子程序(setEventDuration);
		为玩家添加生命池(事件玩家, 护甲, 2500, 假, 假);
		事件玩家.healthId[1] = 最后创建的生命池;
		事件玩家.dmg_reduction += 25;
		调用子程序(setPlayerDmgReduc);
		等待(事件玩家.eventDuration, 无视条件);
		移除玩家的生命池(事件玩家.healthId[1]);
		事件玩家.dmg_reduction = 0;
		调用子程序(setPlayerDmgReduc);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		事件玩家.healthId[1] = 空;
	}
}

规则("[VishkarEvent]: 肾上腺素")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 0;
		事件玩家.eventId == 3;
	}

	动作
	{
		// 等待(0.016, 无视条件);
		// 调用子程序(setEventDuration);
		创建效果(所有玩家(所有队伍), 安娜纳米激素强化效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
		事件玩家.nanoEffect = 最后创建的实体;
		事件玩家.dmg_reduction += 50;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		调用子程序(setPlayerDmgReduc);
		等待(事件玩家.eventDuration, 无视条件);
		事件玩家.dmg_reduction = 0;
		调用子程序(setPlayerDmgReduc);
		消除效果(事件玩家.nanoEffect);
		事件玩家.nanoEffect = 空;
	}
}

规则("[VishkarEvent]: 生命源泉")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 0;
		事件玩家.eventId == 4;
	}

	动作
	{
		停止持续治疗(事件玩家.healID);
		等待(0.032, 无视条件);
		开始持续治疗(事件玩家, 事件玩家, 20, 最大生命值(事件玩家) * 0.15);
		事件玩家.healID = 上一个持续治疗效果ID;
		等待(事件玩家.eventDuration, 无视条件);
		停止持续治疗(事件玩家.healID);
		事件玩家.healID = 0;
	}
}

规则("[VishkarEvent]: 黑粉来袭")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 0;
		事件玩家.eventId == 5;
	}

	动作
	{
		// 创建HUD文本(事件玩家, 空, 空, 自定义字符串("\r\n\r\n\r\n{0}/{1}", 数量(已过滤的数组(所有玩家(队伍2), 当前数组元素.target == 事件玩家)), 数量(全局.bastionPosition)), 顶部, 9, 空, 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		创建HUD文本(事件玩家, 空, 自定义字符串("\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r"), 自定义字符串("{0}/{1}", 数量(已过滤的数组(所有玩家(队伍2), 当前数组元素.target == 事件玩家)), 数量(全局.bastionPosition)), 顶部, 9, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.hudTextId = 上一个文本ID;
		// 事件玩家.hudText = 自定义字符串("{0}/{1}", 数量(已过滤的数组(所有玩家(队伍2), 当前数组元素.target == 事件玩家)), 数量(全局.bastionPosition));
		等待直到(事件玩家.eventId != 5, 事件玩家.eventDuration);
		等待(服务器负载 / 100 * 0.032, 无视条件);
		消除HUD文本(事件玩家.hudTextId);
	}
}

规则("[VishkarEvent]: 足力健")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 0;
		事件玩家.eventId == 6;
		// 数量(已过滤的数组(所有存活玩家(队伍1), 相距距离(事件玩家, 当前数组元素) < 5)) > 0;
		// 首个(范围内玩家(事件玩家, 2.5, 队伍1, 表面)) != 假;
		正在移动(事件玩家) == 真;
		速度(事件玩家) != 0;
	}

	动作
	{
		等待(1, 当为“假”时中止);
		根据条件跳过(事件玩家.eventEffect != 空, 2);
		创建效果(所有玩家(所有队伍), “士兵：76”疾跑效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
		事件玩家.eventEffect = 最后创建的实体;
		事件玩家.mov_speed_buff += 3;
		调用子程序(setPlayerMovSpeed);
		如条件为“真”则循环;
		等待(0.032, 无视条件);
		// 消除效果(事件玩家.eventEffect);
		// 事件玩家.eventEffect = 空;
		事件玩家.mov_speed_buff = 0;
		调用子程序(setPlayerMovSpeed);
	}
}

规则("[VishkarEvent]: 不朽意志")
{
	事件
	{
		玩家受到伤害;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 0;
		事件玩家.eventId == 7;
		// 数量(已过滤的数组(所有存活玩家(队伍1), 相距距离(事件玩家, 当前数组元素) < 5)) > 0;
		// 首个(范围内玩家(事件玩家, 2.5, 队伍1, 表面)) != 假;
		所用英雄(攻击方) == 英雄(堡垒);
		攻击方 != 事件玩家;
	}

	动作
	{
		停止持续治疗(事件玩家.healID);
		等待(0.500, 无视条件);
		等待(0.500, 当为“真”时重新开始);
		根据条件中止(死亡(事件玩家) || 标准化生命值(事件玩家) == 1);
		开始持续治疗(事件玩家, 事件玩家, 2, 最大生命值(事件玩家) * 0.20);
		事件玩家.healID = 上一个持续治疗效果ID;
		等待(2, 无视条件);
	}
}

规则("[VishkarEvent]: 心之钢 Effect")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 0;
		事件玩家.eventId == 8;
	}

	动作
	{
		等待(0.016, 无视条件);
		// 根据条件跳过(事件玩家.eventEffect != 空, 2);
		创建效果(所有玩家(所有队伍), 温斯顿原始暴怒效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
		事件玩家.eventEffect = 最后创建的实体;
		等待直到(事件玩家.eventId == 空, 事件玩家.eventDuration);
		消除效果(事件玩家.eventEffect);
		事件玩家.eventEffect = 空;
	}
}

规则("[VishkarEvent]: 心之钢")
{
	事件
	{
		玩家阵亡;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 0;
		事件玩家.eventId == 8;
		所用英雄(攻击方) == 英雄(堡垒);
	}

	动作
	{
		事件玩家.heart_steel += 1;
		小字体信息(事件玩家, 自定义字符串("  {0}  已获得 1% 额外最大生命值", 技能图标字符串(英雄(黑影), 按钮(终极技能))));
		等待(0.032, 无视条件);
		等待直到(存活(事件玩家), 0.5);
		调用子程序(setPlayerHP);
		等待(0.032, 无视条件);
	}
}

规则("[VishkarEvent]: 重力异常")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 1;
		事件玩家.eventId == 0;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 无视条件);
		事件玩家.mov_speed_penalty += 40;
		调用子程序(setPlayerMovSpeed);
		设置引力(事件玩家, 100 + 70);
		等待(事件玩家.eventDuration, 无视条件);
		事件玩家.mov_speed_penalty -= 50;
		调用子程序(setPlayerMovSpeed);
		设置引力(事件玩家, 100);
	}
}

规则("[VishkarEvent]: 电磁脉冲")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 1;
		事件玩家.eventId == 1;
	}

	动作
	{
		停止追踪玩家变量(事件玩家, hack_timer);
		设置状态(事件玩家, 首个(选择英雄的玩家(英雄(堡垒), 队伍2)), 被入侵, 8);
		事件玩家.hack_timer = 8;
		追踪玩家变量频率(事件玩家, hack_timer, 0, 1, 全部禁用);
	}
}

规则("[VishkarEvent]: 粉丝狂热")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 1;
		事件玩家.eventId == 2;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 无视条件);
		创建效果(所有玩家(所有队伍), 托比昂热力过载效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
		事件玩家.eventEffect = 最后创建的实体;
		事件玩家.targetWeight = 100;
		等待(事件玩家.eventDuration, 无视条件);
		消除效果(事件玩家.eventEffect);
		事件玩家.eventEffect = 空;
		事件玩家.targetWeight = 0;
	}
}

规则("[VishkarEvent]: 易损")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 1;
		事件玩家.eventId == 3;
	}

	动作
	{
		事件玩家.dmg_increase += 25;
		等待(服务器负载 / 100 * 0.032, 无视条件);
		调用子程序(setPlayerDmgReduc);
		等待(事件玩家.eventDuration, 无视条件);
		事件玩家.dmg_increase = 0;
		调用子程序(setPlayerDmgReduc);
	}
}

规则("[VishkarEvent]: 限速40")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 1;
		事件玩家.eventId == 4;
		// 数量(已过滤的数组(所有存活玩家(队伍1), 相距距离(事件玩家, 当前数组元素) < 5)) > 0;
		// 首个(范围内玩家(事件玩家, 2.5, 队伍1, 表面)) != 假;
		正在移动(事件玩家) == 真;
		速度(事件玩家) != 0;
	}

	动作
	{
		等待(1, 当为“假”时中止);
		根据条件跳过(具有状态(事件玩家, 燃烧), 1);
		设置状态(事件玩家, 空, 燃烧, 2.500);
		开始持续伤害(事件玩家, 空, 1, 50 + 取整(最大生命值(事件玩家) * 0.075, 至最近));
		等待(0.032, 无视条件);
		如条件为“真”则循环;
		清除状态(事件玩家, 燃烧);
	}
}


规则("[VishkarEvent]: 痛苦转化")
{
	事件
	{
		玩家受到伤害;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 2;
		事件玩家.eventId == 0;
		// 数量(已过滤的数组(所有存活玩家(队伍1), 相距距离(事件玩家, 当前数组元素) < 5)) > 0;
		// 首个(范围内玩家(事件玩家, 2.5, 队伍1, 表面)) != 假;
		所用英雄(攻击方) == 英雄(堡垒);
		事件伤害 >= 最大生命值(事件玩家) * 0.3;
	}

	动作
	{
		等待(0.016, 无视条件);
		// 根据条件中止(死亡(事件玩家) || 标准化生命值(事件玩家) == 1);
		// 开始持续治疗(事件玩家, 事件玩家, 2, 最大生命值(事件玩家) * 0.20);
		治疗(事件玩家, 空, 最大生命值(事件玩家) * 0.25);
		等待(1, 无视条件);
	}
}

// 规则("[VishkarEvent]: 钢铁防线")
规则("[VishkarEvent]: 纳米战甲")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 2;
		事件玩家.eventId == 1;
	}

	动作
	{
		等待(0.016, 无视条件);
		为玩家添加生命池(事件玩家, 生命值, 最大生命值(事件玩家) * 10, 假, 假);
		事件玩家.healthId[0] = 最后创建的生命池;
		// 停止追踪玩家变量(事件玩家, hack_timer);
		// 设置状态(事件玩家, 首个(选择英雄的玩家(英雄(堡垒), 队伍2)), 被入侵, 15);
		// 事件玩家.hack_timer = 15;
		// 追踪玩家变量频率(事件玩家, hack_timer, 0, 1, 全部禁用);
		事件玩家.mov_speed_buff -= 25;
		调用子程序(setPlayerMovSpeed);
		等待(事件玩家.eventDuration, 无视条件);
		事件玩家.mov_speed_buff = 0;
		调用子程序(setPlayerMovSpeed);
		移除玩家的生命池(事件玩家.healthId[0]);
		事件玩家.healthId[0] = 空;
		// 根据条件中止(死亡(事件玩家) || 标准化生命值(事件玩家) == 1);
		// 开始持续治疗(事件玩家, 事件玩家, 2, 最大生命值(事件玩家) * 0.20);
		// 等待(2, 无视条件);
	}
}

规则("[VishkarEvent]: 赌徒")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 2;
		事件玩家.eventId == 2;
		对任意为“真”(数组(
			正在使用技能 1(事件玩家),
			正在使用技能 2(事件玩家)
		), 当前数组元素) == 真;
	}

	动作
	{
		等待(0.016, 无视条件);
		IF(随机整数(0, 100) <= 50);
			// 设置玩家生命值(事件玩家, 1);
			事件玩家.heart_steel -= 10;
			小字体信息(事件玩家, 自定义字符串("  {0}  输！失去 10% 最大生命值", 图标字符串(方块)));
		Else;
			// 设置状态(事件玩家, 空, 无敌, 2);
			// 创建效果(所有玩家(所有队伍), 巴蒂斯特维生力场保护效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
			// 事件玩家.invincibleEffect = 最后创建的实体;
			// 等待(2, 无视条件);
			// 消除效果(事件玩家.invincibleEffect);
			事件玩家.heart_steel += 10;
			小字体信息(事件玩家, 自定义字符串("  {0}  赢！获得 10% 最大生命值", 图标字符串(梅花)));
		End;
		等待(0.032, 无视条件);
		调用子程序(setPlayerHP);
		// 消除效果(事件玩家.invincibleEffect);
		// 事件玩家.invincibleEffect = 空;
	}
}

规则("[VishkarEvent]: 有点松弛")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 2;
		事件玩家.eventId == 3;
		// 对任意为“真”(数组(
		// 	正在使用技能 1(事件玩家),
		// 	正在使用技能 2(事件玩家)
		// ), 当前数组元素) == 真;
		正在移动(事件玩家) == 真;
		速度(事件玩家) != 0;
	}

	动作
	{
		等待(0.016, 无视条件);
		根据条件跳过(事件玩家.eventEffect != 空, 2);
		创建效果(所有玩家(所有队伍), “破坏球”重力坠击火焰效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
		事件玩家.eventEffect = 最后创建的实体;
		创建效果(所有玩家(所有队伍), 云, 数组随机取值(数组(颜色(黄色), 颜色(绿色), 颜色(亮紫色), 颜色(橙色), 颜色(灰绿色), 颜色(紫色))), 单次赋值(所选位置(事件玩家)), 30, 可见，位置和半径);
		等待(0.016, 无视条件);
		修改玩家变量(事件玩家, obstrucVis, 添加至数组, 最后创建的实体);
		等待(1.000, 无视条件);
		如条件为“真”则循环;
		消除效果(事件玩家.eventEffect);
		事件玩家.eventEffect = 空;
	}
}

规则("[VishkarEvent]: 有点松弛")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		事件玩家.obstrucVis != 空数组;
		数量(事件玩家.obstrucVis) > 0;
	}

	动作
	{
		等待(30, 当为“假”时中止);
		消除效果(首个(事件玩家.obstrucVis));
		修改玩家变量(事件玩家, obstrucVis, 根据值从数组中移除, 首个(事件玩家.obstrucVis));
		等待(0.500, 无视条件);
		如条件为“真”则循环;
	}
}

规则("[VishkarEvent]: 体积膨胀")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 2;
		事件玩家.eventId == 4;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 无视条件);
		事件玩家.sizeHealth = 5;
		开始调整玩家大小(事件玩家, 2, 假);
		开始调整障碍大小(事件玩家, 2, 假);
		开始修改英雄语音(事件玩家, 0.500, 假);
		调用子程序(setPlayerHP);
		等待直到(事件玩家.eventId == -1, 事件玩家.eventDuration);
		事件玩家.sizeHealth = 1;
		调用子程序(setPlayerHP);
		停止调整玩家大小(事件玩家);
		停止调整障碍大小(事件玩家);
		停止修改英雄语音(事件玩家);
	}
}

规则("[VishkarEvent]: 迷你形态")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 2;
		事件玩家.eventId == 5;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.032, 无视条件);
		事件玩家.sizeHealth = 0.5;
		开始调整玩家大小(事件玩家, 0.4, 假);
		开始调整障碍大小(事件玩家, 0.4, 假);
		开始修改英雄语音(事件玩家, 1.500, 假);
		调用子程序(setPlayerHP);
		等待直到(事件玩家.eventId == -1, 事件玩家.eventDuration);
		事件玩家.sizeHealth = 1;
		调用子程序(setPlayerHP);
		停止调整玩家大小(事件玩家);
		停止调整障碍大小(事件玩家);
		停止修改英雄语音(事件玩家);
	}
}

规则("[VishkarEvent]: 悄悄地进村")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 2;
		事件玩家.eventId == 6;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
	}

	动作
	{
		创建效果(所有玩家(所有队伍), “死神”幽灵形态效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
		事件玩家.eventEffect = 最后创建的实体;
		事件玩家.targetSilence = 真;
		事件玩家.mov_speed_penalty += 25;
		调用子程序(setPlayerMovSpeed);
		等待直到(按钮被按下(事件玩家, 按钮(蹲下)) == 假, 事件玩家.eventDuration);
		事件玩家.targetSilence = 假;
		事件玩家.mov_speed_penalty -= 25;
		调用子程序(setPlayerMovSpeed);
		消除效果(事件玩家.eventEffect);
		事件玩家.eventEffect = 空;
		等待(0.250, 无视条件);
	}
}

规则("[VishkarEvent]: 胜利意志")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		查莉娅;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 3;
		事件玩家.eventId == 0;
		生命值(事件玩家) <= 最大生命值(事件玩家) * 0.300;
	}

	动作
	{
		大字体信息(事件玩家, 自定义字符串("胜利意志！")); //Воля к победе
		// 设置状态(事件玩家, 空, 无法杀死, 1);
		设置状态(事件玩家, 空, 无敌, 2);
		设置状态(事件玩家, 空, 相移, 2);
		创建效果(所有玩家(所有队伍), 巴蒂斯特维生力场保护效果, 颜色(队伍1), 事件玩家, 200, 位置和半径);
		事件玩家.invincibleEffect = 最后创建的实体;
		设置技能冷却(事件玩家, 按钮(技能1), 0);
		设置技能冷却(事件玩家, 按钮(技能2), 0);
		开始持续治疗(事件玩家, 事件玩家, 30, 最大生命值(事件玩家) * 0.4);
		等待(2.000, 无视条件);
		消除效果(事件玩家.invincibleEffect);
		事件玩家.invincibleEffect = 空;
	}
}

规则("[Orisa]: fly  - created by 他又 from 77QS1")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		奥丽莎;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 3;
		事件玩家.eventId == 1;
		正在使用技能 2(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
	}

	动作
	{
		根据条件跳过(事件玩家.dmg_reduction != 0, 2);
		事件玩家.dmg_reduction += 25;
		调用子程序(setPlayerDmgReduc);
		施加推力(事件玩家, 面朝方向(事件玩家), 10, 至地图, 取消相反运动);
		等待(0.016, 无视条件);
		如条件为“真”则循环;
		事件玩家.dmg_reduction = 0;
		调用子程序(setPlayerDmgReduc);
	}
}

规则("[Zenyatta]: 我佛慈悲 - created by 他又 from 77QS1")
{
	事件
	{
		玩家造成伤害;
		队伍1;
		禅雅塔;
	}

	条件
	{
		单次赋值(全局.dlcVishkarEvent) == 真;
		具有状态(被攻击方, 击晕) != 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 3;
		事件玩家.eventId == 2;
	}

	动作
	{
		设置状态(被攻击方, 攻击方, 击晕, 1.250);
		等待(0.200, 无视条件);
	}
}

规则("[Mei]: Endothermic Blaster - created by 他又 from 77QS1")
{
	事件
	{
		玩家造成伤害;
		队伍1;
		美;
	}

	条件
	{
		// 具有状态(被攻击方, 冰冻) != 真;
		// 事件暴击 == 真;
		// 事件技能 == 按钮(辅助攻击模式);
		单次赋值(全局.dlcVishkarEvent) == 真;
		已重生(事件玩家) == 真;
		事件玩家.eventType == 3;
		事件玩家.eventId == 3;
	}

	动作
	{
		设置状态(被攻击方, 攻击方, 冰冻, 随机实数(0.750, 5.000));
		等待(0.200, 无视条件);
	}
}